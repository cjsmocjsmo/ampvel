import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, v as validate_slots, U as TVlocalplayURL, e as element, t as text, p as space, c as claim_element, a as children, b as claim_text, f as detach_dev, q as claim_space, j as add_location, h as attr_dev, k as insert_dev, l as append_dev, m as listen_dev, r as run_all, B as validate_each_argument, A as empty, C as destroy_each, O as is_function, w as set_data_dev, n as noop, o as onMount, V as set_store_value, E as create_component, F as claim_component, G as mount_component, H as transition_in, I as transition_out, J as destroy_component, u as query_selector_all, P as check_outros, Q as group_outros } from './client.97a679cb.js';
import { C as Controls } from './Controls.0f255e0e.js';

/* src/components/TVComps/Discovery.svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;
const file = "src/components/TVComps/Discovery.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleDis}
function create_if_block(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file, 73, 8, 2015);
			add_location(button1, file, 74, 8, 2071);
			add_location(nav, file, 72, 4, 2001);
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file, 76, 4, 2134);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleDiscovery1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleDiscovery2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(72:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (78:8) {#if showlistcount > 0}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShow*/ 65) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(78:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each showlist as sshow }
function create_each_block(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file, 80, 20, 2251);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file, 81, 20, 2349);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file, 79, 16, 2226);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(79:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Discovery");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Discovery");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file, 69, 0, 1933);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	console.log("this is y");
	console.log(y);
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	// onMount(
	async function getDiscovery(x) {
		let addr = `http://192.168.0.42:8888/intDiscovery?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	//)
	let handleDiscovery1 = () => {
		let promise = getDiscovery(`01`).catch(err => console.log(err));
	};

	let handleDiscovery2 = () => {
		let promise = getDiscovery(`02`).catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + "/" + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Discovery> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Discovery", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getDiscovery,
		handleDiscovery1,
		handleDiscovery2,
		fuckDis,
		getPlayMedia,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleDiscovery1" in $$props) $$invalidate(3, handleDiscovery1 = $$props.handleDiscovery1);
		if ("handleDiscovery2" in $$props) $$invalidate(4, handleDiscovery2 = $$props.handleDiscovery2);
		if ("fuckDis" in $$props) $$invalidate(5, fuckDis = $$props.fuckDis);
		if ("handlePlayShow" in $$props) $$invalidate(6, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleDiscovery1,
		handleDiscovery2,
		fuckDis,
		handlePlayShow,
		LP
	];
}

class Discovery extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Discovery",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1.warn("<Discovery> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Discovery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Discovery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Enterprise.svelte generated by Svelte v3.24.0 */

const { console: console_1$1 } = globals;
const file$1 = "src/components/TVComps/Enterprise.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleEnt}
function create_if_block$1(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*Entshowlistcount*/ ctx[1] > 0 && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$1, 73, 8, 2108);
			add_location(button1, file$1, 74, 8, 2165);
			add_location(button2, file$1, 75, 8, 2222);
			add_location(button3, file$1, 76, 8, 2279);
			add_location(nav, file$1, 72, 4, 2094);
			attr_dev(ul, "class", "svelte-13j0val");
			add_location(ul, file$1, 79, 4, 2344);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleEnterprise1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleEnterprise2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleEnterprise3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleEnterprise4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*Entshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(72:0) {#if visibleEnt}",
		ctx
	});

	return block;
}

// (81:8) {#if Entshowlistcount > 0}
function create_if_block_1$1(ctx) {
	let each_1_anchor;
	let each_value = /*Entshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Entshowlist, handlePlayShow*/ 257) {
				each_value = /*Entshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(81:8) {#if Entshowlistcount > 0}",
		ctx
	});

	return block;
}

// (82:12) {#each Entshowlist as sshow }
function create_each_block$1(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-13j0val");
			add_location(a, file$1, 83, 20, 2467);
			attr_dev(span, "class", "svelte-13j0val");
			add_location(span, file$1, 84, 20, 2565);
			attr_dev(li, "class", "svelte-13j0val");
			add_location(li, file$1, 82, 16, 2442);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].tvfspath))) /*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*Entshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*Entshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(82:12) {#each Entshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleEnt*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Enterprise");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Enterprise");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$1, 69, 0, 2024);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckEnt*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleEnt*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$1(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$1($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let Entshowlist;
	let Entshowlistcount;
	let visibleEnt = false;

	async function getEnterprise(x) {
		let addr = `http://192.168.0.42:8888/intEnterprise?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, Entshowlist = data);
			$$invalidate(1, Entshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleEnterprise1 = () => {
		let promise = getEnterprise(`01`).catch(err => console.log(err));
	};

	let handleEnterprise2 = () => {
		let promise = getEnterprise(`02`).catch(err => console.log(err));
	};

	let handleEnterprise3 = () => {
		let promise = getEnterprise(`03`).catch(err => console.log(err));
	};

	let handleEnterprise4 = () => {
		let promise = getEnterprise(`04`).catch(err => console.log(err));
	};

	let fuckEnt = () => {
		if (visibleEnt) {
			$$invalidate(2, visibleEnt = false);
		} else {
			$$invalidate(2, visibleEnt = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log("this is media");
			console.log(media);

			// let foo = media.split("TVShows", 2)
			let newpath = `http://192.168.0.42:8063` + "/" + media;

			console.log("this is newpath");
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleEnt = false);
		} else {
			let promise = getPlayMedia$1(media).catch(err => console.log(err));
			$$invalidate(2, visibleEnt = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Enterprise> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Enterprise", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		getEnterprise,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		getPlayMedia: getPlayMedia$1,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("Entshowlist" in $$props) $$invalidate(0, Entshowlist = $$props.Entshowlist);
		if ("Entshowlistcount" in $$props) $$invalidate(1, Entshowlistcount = $$props.Entshowlistcount);
		if ("visibleEnt" in $$props) $$invalidate(2, visibleEnt = $$props.visibleEnt);
		if ("handleEnterprise1" in $$props) $$invalidate(3, handleEnterprise1 = $$props.handleEnterprise1);
		if ("handleEnterprise2" in $$props) $$invalidate(4, handleEnterprise2 = $$props.handleEnterprise2);
		if ("handleEnterprise3" in $$props) $$invalidate(5, handleEnterprise3 = $$props.handleEnterprise3);
		if ("handleEnterprise4" in $$props) $$invalidate(6, handleEnterprise4 = $$props.handleEnterprise4);
		if ("fuckEnt" in $$props) $$invalidate(7, fuckEnt = $$props.fuckEnt);
		if ("handlePlayShow" in $$props) $$invalidate(8, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		handlePlayShow,
		LP
	];
}

class Enterprise extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Enterprise",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$1.warn("<Enterprise> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Enterprise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Enterprise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Orville.svelte generated by Svelte v3.24.0 */

const { console: console_1$2 } = globals;
const file$2 = "src/components/TVComps/Orville.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (60:0) {#if visibleOrv}
function create_if_block$2(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*ORVshowlistcount*/ ctx[1] > 0 && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$2, 61, 8, 1699);
			add_location(button1, file$2, 62, 8, 1748);
			add_location(nav, file$2, 60, 4, 1685);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$2, 65, 4, 1805);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleOR1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleOR2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*ORVshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(60:0) {#if visibleOrv}",
		ctx
	});

	return block;
}

// (67:8) {#if ORVshowlistcount > 0}
function create_if_block_1$2(ctx) {
	let each_1_anchor;
	let each_value = /*ORVshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ORVshowlist, handlePlayShowOr*/ 65) {
				each_value = /*ORVshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(67:8) {#if ORVshowlistcount > 0}",
		ctx
	});

	return block;
}

// (68:12) {#each ORVshowlist as sshow }
function create_each_block$2(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$2, 69, 20, 1928);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$2, 70, 20, 2028);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$2, 68, 16, 1903);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*ORVshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*ORVshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(68:12) {#each ORVshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleOrv*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Orville");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Orville");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$2, 57, 0, 1619);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckOrv*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleOrv*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$2(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$2($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let ORVshowlist;
	let ORVshowlistcount;
	let visibleOrv = false;

	async function getOrville(x) {
		let addr = `http://192.168.0.42:8888/intOrville?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, ORVshowlist = data);
			$$invalidate(1, ORVshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleOR1 = () => {
		let promise = getOrville(`01`).catch(err => console.log(err));
	};

	let handleOR2 = () => {
		let promise = getOrville(`02`).catch(err => console.log(err));
	};

	let fuckOrv = () => {
		if (visibleOrv) {
			$$invalidate(2, visibleOrv = false);
		} else {
			$$invalidate(2, visibleOrv = true);
		}
	};

	let handlePlayShowOr = media => {
		if (LP) {
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + media;
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleOrv = false);
		} else {
			let promise = getPlayMedia$2(media).catch(err => console.log(err));
			$$invalidate(2, visibleOrv = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Orville> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Orville", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		getOrville,
		handleOR1,
		handleOR2,
		fuckOrv,
		getPlayMedia: getPlayMedia$2,
		handlePlayShowOr
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("ORVshowlist" in $$props) $$invalidate(0, ORVshowlist = $$props.ORVshowlist);
		if ("ORVshowlistcount" in $$props) $$invalidate(1, ORVshowlistcount = $$props.ORVshowlistcount);
		if ("visibleOrv" in $$props) $$invalidate(2, visibleOrv = $$props.visibleOrv);
		if ("handleOR1" in $$props) $$invalidate(3, handleOR1 = $$props.handleOR1);
		if ("handleOR2" in $$props) $$invalidate(4, handleOR2 = $$props.handleOR2);
		if ("fuckOrv" in $$props) $$invalidate(5, fuckOrv = $$props.fuckOrv);
		if ("handlePlayShowOr" in $$props) $$invalidate(6, handlePlayShowOr = $$props.handlePlayShowOr);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		handleOR1,
		handleOR2,
		fuckOrv,
		handlePlayShowOr,
		LP
	];
}

class Orville extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Orville",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$2.warn("<Orville> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Orville>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Orville>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/STTV.svelte generated by Svelte v3.24.0 */

const { console: console_1$3 } = globals;
const file$3 = "src/components/TVComps/STTV.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (67:0) {#if visibleDis}
function create_if_block$3(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$3(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$3, 68, 8, 1835);
			add_location(button1, file$3, 69, 8, 1891);
			add_location(button2, file$3, 70, 8, 1947);
			add_location(nav, file$3, 67, 4, 1821);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$3, 73, 4, 2011);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleSTTVClick1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleSTTVClick2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleSTTVClick3*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(67:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (75:8) {#if showlistcount > 0}
function create_if_block_1$3(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShowSTTV*/ 129) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(75:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (76:12) {#each showlist as sshow }
function create_each_block$3(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[10].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[10].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$3, 77, 20, 2128);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$3, 78, 20, 2230);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$3, 76, 16, 2103);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].tvfspath))) /*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[10].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[10].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(76:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("STTV");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "STTV");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$3, 64, 0, 1757);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$3(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$3($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	async function getSTTV(x) {
		let addr = `http://192.168.0.42:8888/intSTTV?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleSTTVClick1 = () => {
		let promise = getSTTV(`01`).catch(err => console.log(err));
	};

	let handleSTTVClick2 = () => {
		let promise = getSTTV(`02`).catch(err => console.log(err));
	};

	let handleSTTVClick3 = () => {
		let promise = getSTTV(`03`).catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShowSTTV = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$3(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<STTV> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("STTV", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getSTTV,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		getPlayMedia: getPlayMedia$3,
		handlePlayShowSTTV
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleSTTVClick1" in $$props) $$invalidate(3, handleSTTVClick1 = $$props.handleSTTVClick1);
		if ("handleSTTVClick2" in $$props) $$invalidate(4, handleSTTVClick2 = $$props.handleSTTVClick2);
		if ("handleSTTVClick3" in $$props) $$invalidate(5, handleSTTVClick3 = $$props.handleSTTVClick3);
		if ("fuckDis" in $$props) $$invalidate(6, fuckDis = $$props.fuckDis);
		if ("handlePlayShowSTTV" in $$props) $$invalidate(7, handlePlayShowSTTV = $$props.handlePlayShowSTTV);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		handlePlayShowSTTV,
		LP
	];
}

class STTV extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { LP: 8 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "STTV",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[8] === undefined && !("LP" in props)) {
			console_1$3.warn("<STTV> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<STTV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<STTV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/TNG.svelte generated by Svelte v3.24.0 */

const { console: console_1$4 } = globals;
const file$4 = "src/components/TVComps/TNG.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (81:0) {#if visibleTNG}
function create_if_block$4(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*TNGshowlistcount*/ ctx[1] > 0 && create_if_block_1$4(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$4, 82, 8, 2235);
			add_location(button1, file$4, 83, 8, 2285);
			add_location(button2, file$4, 84, 8, 2335);
			add_location(button3, file$4, 85, 8, 2385);
			add_location(button4, file$4, 86, 8, 2435);
			add_location(button5, file$4, 87, 8, 2485);
			add_location(button6, file$4, 88, 8, 2535);
			add_location(nav, file$4, 81, 4, 2221);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$4, 91, 4, 2593);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleTNG1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleTNG2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleTNG3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleTNG4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleTNG5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleTNG6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleTNG7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*TNGshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(81:0) {#if visibleTNG}",
		ctx
	});

	return block;
}

// (93:8) {#if TNGshowlistcount > 0}
function create_if_block_1$4(ctx) {
	let each_1_anchor;
	let each_value = /*TNGshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TNGshowlist, handlePlayTNG*/ 2049) {
				each_value = /*TNGshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(93:8) {#if TNGshowlistcount > 0}",
		ctx
	});

	return block;
}

// (94:12) {#each TNGshowlist as sshow }
function create_each_block$4(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$4, 95, 20, 2716);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$4, 96, 20, 2813);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$4, 94, 16, 2691);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].tvfspath))) /*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*TNGshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*TNGshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(94:12) {#each TNGshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleTNG*/ ctx[2] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Next Generation");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Next Generation");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 78, 0, 2143);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckTNG*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleTNG*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$4(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$4($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let TNGshowlist;
	let TNGshowlistcount;
	let visibleTNG = false;

	async function getTNG(x) {
		let addr = `http://192.168.0.42:8888/intTNG?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, TNGshowlist = data);
			$$invalidate(1, TNGshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleTNG1 = () => {
		let promise = getTNG(`01`).catch(err => console.log(err));
	};

	let handleTNG2 = () => {
		let promise = getTNG(`02`).catch(err => console.log(err));
	};

	let handleTNG3 = () => {
		let promise = getTNG(`03`).catch(err => console.log(err));
	};

	let handleTNG4 = () => {
		let promise = getTNG(`04`).catch(err => console.log(err));
	};

	let handleTNG5 = () => {
		let promise = getTNG(`05`).catch(err => console.log(err));
	};

	let handleTNG6 = () => {
		let promise = getTNG(`06`).catch(err => console.log(err));
	};

	let handleTNG7 = () => {
		let promise = getTNG(`07`).catch(err => console.log(err));
	};

	let fuckTNG = () => {
		if (visibleTNG) {
			$$invalidate(2, visibleTNG = false);
		} else {
			$$invalidate(2, visibleTNG = true);
		}
	};

	let handlePlayTNG = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleTNG = false);
		} else {
			let promise = getPlayMedia$4(media).catch(err => console.log(err));
			$$invalidate(2, visibleTNG = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<TNG> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TNG", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		getTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		getPlayMedia: getPlayMedia$4,
		handlePlayTNG
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("TNGshowlist" in $$props) $$invalidate(0, TNGshowlist = $$props.TNGshowlist);
		if ("TNGshowlistcount" in $$props) $$invalidate(1, TNGshowlistcount = $$props.TNGshowlistcount);
		if ("visibleTNG" in $$props) $$invalidate(2, visibleTNG = $$props.visibleTNG);
		if ("handleTNG1" in $$props) $$invalidate(3, handleTNG1 = $$props.handleTNG1);
		if ("handleTNG2" in $$props) $$invalidate(4, handleTNG2 = $$props.handleTNG2);
		if ("handleTNG3" in $$props) $$invalidate(5, handleTNG3 = $$props.handleTNG3);
		if ("handleTNG4" in $$props) $$invalidate(6, handleTNG4 = $$props.handleTNG4);
		if ("handleTNG5" in $$props) $$invalidate(7, handleTNG5 = $$props.handleTNG5);
		if ("handleTNG6" in $$props) $$invalidate(8, handleTNG6 = $$props.handleTNG6);
		if ("handleTNG7" in $$props) $$invalidate(9, handleTNG7 = $$props.handleTNG7);
		if ("fuckTNG" in $$props) $$invalidate(10, fuckTNG = $$props.fuckTNG);
		if ("handlePlayTNG" in $$props) $$invalidate(11, handlePlayTNG = $$props.handlePlayTNG);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		handlePlayTNG,
		LP
	];
}

class TNG extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TNG",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$4.warn("<TNG> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<TNG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<TNG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Voyager.svelte generated by Svelte v3.24.0 */

const { console: console_1$5 } = globals;
const file$5 = "src/components/TVComps/Voyager.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (81:0) {#if visibleVoy}
function create_if_block$5(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*VOYshowlistcount*/ ctx[1] > 0 && create_if_block_1$5(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$5, 82, 8, 2227);
			add_location(button1, file$5, 83, 8, 2277);
			add_location(button2, file$5, 84, 8, 2327);
			add_location(button3, file$5, 85, 8, 2377);
			add_location(button4, file$5, 86, 8, 2427);
			add_location(button5, file$5, 87, 8, 2477);
			add_location(button6, file$5, 88, 8, 2527);
			add_location(nav, file$5, 81, 4, 2213);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$5, 91, 4, 2585);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleVOY1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleVOY2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleVOY3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleVOY4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleVOY5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleVOY6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleVOY7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*VOYshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(81:0) {#if visibleVoy}",
		ctx
	});

	return block;
}

// (93:8) {#if VOYshowlistcount > 0}
function create_if_block_1$5(ctx) {
	let each_1_anchor;
	let each_value = /*VOYshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*VOYshowlist, handlePlayVOY*/ 2049) {
				each_value = /*VOYshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(93:8) {#if VOYshowlistcount > 0}",
		ctx
	});

	return block;
}

// (94:12) {#each VOYshowlist as sshow }
function create_each_block$5(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$5, 95, 20, 2708);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$5, 96, 20, 2805);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$5, 94, 16, 2683);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].tvfspath))) /*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*VOYshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*VOYshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(94:12) {#each VOYshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleVoy*/ ctx[2] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Voyager");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Voyager");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$5, 78, 0, 2147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckVOY*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleVoy*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$5(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$5($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let VOYshowlist;
	let VOYshowlistcount;
	let visibleVoy = false;

	async function getVOY(x) {
		let addr = `http://192.168.0.42:8888/intVoyager?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, VOYshowlist = data);
			$$invalidate(1, VOYshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleVOY1 = () => {
		let promise = getVOY(`01`).catch(err => console.log(err));
	};

	let handleVOY2 = () => {
		let promise = getVOY(`02`).catch(err => console.log(err));
	};

	let handleVOY3 = () => {
		let promise = getVOY(`03`).catch(err => console.log(err));
	};

	let handleVOY4 = () => {
		let promise = getVOY(`04`).catch(err => console.log(err));
	};

	let handleVOY5 = () => {
		let promise = getVOY(`05`).catch(err => console.log(err));
	};

	let handleVOY6 = () => {
		let promise = getVOY(`06`).catch(err => console.log(err));
	};

	let handleVOY7 = () => {
		let promise = getVOY(`07`).catch(err => console.log(err));
	};

	let fuckVOY = () => {
		if (visibleVoy) {
			$$invalidate(2, visibleVoy = false);
		} else {
			$$invalidate(2, visibleVoy = true);
		}
	};

	let handlePlayVOY = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			visibleVOY = false;
		} else {
			let promise = getPlayMedia$5(media).catch(err => console.log(err));
			visibleVOY = false;
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Voyager> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Voyager", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		getVOY,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		getPlayMedia: getPlayMedia$5,
		handlePlayVOY
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("VOYshowlist" in $$props) $$invalidate(0, VOYshowlist = $$props.VOYshowlist);
		if ("VOYshowlistcount" in $$props) $$invalidate(1, VOYshowlistcount = $$props.VOYshowlistcount);
		if ("visibleVoy" in $$props) $$invalidate(2, visibleVoy = $$props.visibleVoy);
		if ("handleVOY1" in $$props) $$invalidate(3, handleVOY1 = $$props.handleVOY1);
		if ("handleVOY2" in $$props) $$invalidate(4, handleVOY2 = $$props.handleVOY2);
		if ("handleVOY3" in $$props) $$invalidate(5, handleVOY3 = $$props.handleVOY3);
		if ("handleVOY4" in $$props) $$invalidate(6, handleVOY4 = $$props.handleVOY4);
		if ("handleVOY5" in $$props) $$invalidate(7, handleVOY5 = $$props.handleVOY5);
		if ("handleVOY6" in $$props) $$invalidate(8, handleVOY6 = $$props.handleVOY6);
		if ("handleVOY7" in $$props) $$invalidate(9, handleVOY7 = $$props.handleVOY7);
		if ("fuckVOY" in $$props) $$invalidate(10, fuckVOY = $$props.fuckVOY);
		if ("handlePlayVOY" in $$props) $$invalidate(11, handlePlayVOY = $$props.handlePlayVOY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		handlePlayVOY,
		LP
	];
}

class Voyager extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Voyager",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$5.warn("<Voyager> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Voyager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Voyager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LastShip.svelte generated by Svelte v3.24.0 */

const { console: console_1$6 } = globals;
const file$6 = "src/components/TVComps/LastShip.svelte";

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (70:0) {#if visibleLS}
function create_if_block$6(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LSshowlistcount*/ ctx[1] > 0 && create_if_block_1$6(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$6, 71, 8, 1905);
			add_location(button1, file$6, 72, 8, 1954);
			add_location(button2, file$6, 73, 8, 2003);
			add_location(button3, file$6, 74, 8, 2052);
			add_location(nav, file$6, 70, 4, 1891);
			attr_dev(ul, "class", "svelte-1omye9l");
			add_location(ul, file$6, 77, 4, 2109);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLS2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleLS3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleLS4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LSshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(70:0) {#if visibleLS}",
		ctx
	});

	return block;
}

// (79:8) {#if LSshowlistcount > 0}
function create_if_block_1$6(ctx) {
	let each_1_anchor;
	let each_value = /*LSshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LSshowlist, handlePlayLS*/ 257) {
				each_value = /*LSshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(79:8) {#if LSshowlistcount > 0}",
		ctx
	});

	return block;
}

// (80:12) {#each LSshowlist as sshow }
function create_each_block$6(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-1omye9l");
			add_location(a, file$6, 81, 20, 2230);
			attr_dev(span, "class", "svelte-1omye9l");
			add_location(span, file$6, 82, 20, 2326);
			attr_dev(li, "class", "svelte-1omye9l");
			add_location(li, file$6, 80, 16, 2205);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].tvfspath))) /*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LSshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LSshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(80:12) {#each LSshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLS*/ ctx[2] && create_if_block$6(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Last Ship");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Last Ship");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$6, 67, 0, 1820);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLS*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$6(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$6($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LSshowlist;
	let LSshowlistcount;

	async function getLS(x) {
		let addr = `http://192.168.0.42:8888/intLastShip?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, LSshowlist = data);
			$$invalidate(1, LSshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLS1 = () => {
		let promise = getLS(`01`).catch(err => console.log(err));
	};

	let handleLS2 = () => {
		let promise = getLS(`02`).catch(err => console.log(err));
	};

	let handleLS3 = () => {
		let promise = getLS(`03`).catch(err => console.log(err));
	};

	let handleLS4 = () => {
		let promise = getLS(`04`).catch(err => console.log(err));
	};

	let visibleLS = false;

	let fuckLS = () => {
		if (visibleLS) {
			$$invalidate(2, visibleLS = false);
		} else {
			$$invalidate(2, visibleLS = true);
		}
	};

	let handlePlayLS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleLS = false);
		} else {
			let promise = getPlayMedia$6(media).catch(err => console.log(err));
			$$invalidate(2, visibleLS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<LastShip> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LastShip", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		LSshowlist,
		LSshowlistcount,
		getLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		visibleLS,
		fuckLS,
		getPlayMedia: getPlayMedia$6,
		handlePlayLS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("LSshowlist" in $$props) $$invalidate(0, LSshowlist = $$props.LSshowlist);
		if ("LSshowlistcount" in $$props) $$invalidate(1, LSshowlistcount = $$props.LSshowlistcount);
		if ("handleLS1" in $$props) $$invalidate(3, handleLS1 = $$props.handleLS1);
		if ("handleLS2" in $$props) $$invalidate(4, handleLS2 = $$props.handleLS2);
		if ("handleLS3" in $$props) $$invalidate(5, handleLS3 = $$props.handleLS3);
		if ("handleLS4" in $$props) $$invalidate(6, handleLS4 = $$props.handleLS4);
		if ("visibleLS" in $$props) $$invalidate(2, visibleLS = $$props.visibleLS);
		if ("fuckLS" in $$props) $$invalidate(7, fuckLS = $$props.fuckLS);
		if ("handlePlayLS" in $$props) $$invalidate(8, handlePlayLS = $$props.handlePlayLS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LSshowlist,
		LSshowlistcount,
		visibleLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		fuckLS,
		handlePlayLS,
		LP
	];
}

class LastShip extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LastShip",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$6.warn("<LastShip> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LastShip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LastShip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LostInSpace.svelte generated by Svelte v3.24.0 */

const { console: console_1$7 } = globals;
const file$7 = "src/components/TVComps/LostInSpace.svelte";

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (64:0) {#if visibleLIS}
function create_if_block$7(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LISshowlistcount*/ ctx[1] > 0 && create_if_block_1$7(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$7, 65, 8, 1844);
			add_location(button1, file$7, 66, 8, 1894);
			add_location(nav, file$7, 64, 4, 1830);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$7, 69, 4, 1952);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLIS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLIS2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LISshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$7(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(64:0) {#if visibleLIS}",
		ctx
	});

	return block;
}

// (71:8) {#if LISshowlistcount > 0}
function create_if_block_1$7(ctx) {
	let each_1_anchor;
	let each_value = /*LISshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LISshowlist, handlePlayShowLIS*/ 65) {
				each_value = /*LISshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(71:8) {#if LISshowlistcount > 0}",
		ctx
	});

	return block;
}

// (72:12) {#each LISshowlist as sshow }
function create_each_block$7(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$7, 73, 20, 2075);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$7, 74, 20, 2176);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$7, 72, 16, 2050);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LISshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LISshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(72:12) {#each LISshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLIS*/ ctx[2] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Lost In Space");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Lost In Space");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$7, 61, 0, 1758);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLIS*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLIS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$7(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$7($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LISshowlist;
	let LISshowlistcount;
	let visibleLIS = false;

	async function getLostInSpace(x) {
		let addr = `http://192.168.0.42:8888/intLostInSpace?season=${x}`;
		console.log(addr);

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			$$invalidate(0, LISshowlist = data);
			$$invalidate(1, LISshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLIS1 = () => {
		let promise = getLostInSpace(`01`).catch(err => console.log(err));
	};

	let handleLIS2 = () => {
		let promise = getLostInSpace(`02`).catch(err => console.log(err));
	};

	let fuckLIS = () => {
		if (visibleLIS) {
			$$invalidate(2, visibleLIS = false);
		} else {
			$$invalidate(2, visibleLIS = true);
		}
	};

	let handlePlayShowLIS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleLIS = false);
		} else {
			let promise = getPlayMedia$7(media).catch(err => console.log(err));
			$$invalidate(2, visibleLIS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<LostInSpace> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LostInSpace", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		getLostInSpace,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		getPlayMedia: getPlayMedia$7,
		handlePlayShowLIS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("LISshowlist" in $$props) $$invalidate(0, LISshowlist = $$props.LISshowlist);
		if ("LISshowlistcount" in $$props) $$invalidate(1, LISshowlistcount = $$props.LISshowlistcount);
		if ("visibleLIS" in $$props) $$invalidate(2, visibleLIS = $$props.visibleLIS);
		if ("handleLIS1" in $$props) $$invalidate(3, handleLIS1 = $$props.handleLIS1);
		if ("handleLIS2" in $$props) $$invalidate(4, handleLIS2 = $$props.handleLIS2);
		if ("fuckLIS" in $$props) $$invalidate(5, fuckLIS = $$props.fuckLIS);
		if ("handlePlayShowLIS" in $$props) $$invalidate(6, handlePlayShowLIS = $$props.handlePlayShowLIS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		handlePlayShowLIS,
		LP
	];
}

class LostInSpace extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LostInSpace",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$7.warn("<LostInSpace> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LostInSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LostInSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Picard.svelte generated by Svelte v3.24.0 */

const { console: console_1$8 } = globals;
const file$8 = "src/components/TVComps/Picard.svelte";

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleDis}
function create_if_block$8(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$8(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$8, 73, 8, 1992);
			add_location(button1, file$8, 74, 8, 2045);
			add_location(nav, file$8, 72, 4, 1978);
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file$8, 76, 4, 2105);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handlePicard1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handlePicard2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$8(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(72:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (78:8) {#if showlistcount > 0}
function create_if_block_1$8(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShow*/ 65) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(78:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each showlist as sshow }
function create_each_block$8(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file$8, 80, 20, 2222);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file$8, 81, 20, 2320);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file$8, 79, 16, 2197);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$8.name,
		type: "each",
		source: "(79:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$8(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Picard");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Picard");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$8, 69, 0, 1913);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$8(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	console.log("this is y");
	console.log(y);
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$8($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	// onMount(
	async function getPicard(x) {
		let addr = `http://192.168.0.42:8888/intPicard?season=01`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	//)
	let handlePicard1 = () => {
		let promise = getPicard().catch(err => console.log(err));
	};

	let handlePicard2 = () => {
		let promise = getPicard().catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + "/" + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$8(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<Picard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Picard", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getPicard,
		handlePicard1,
		handlePicard2,
		fuckDis,
		getPlayMedia: getPlayMedia$8,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handlePicard1" in $$props) $$invalidate(3, handlePicard1 = $$props.handlePicard1);
		if ("handlePicard2" in $$props) $$invalidate(4, handlePicard2 = $$props.handlePicard2);
		if ("fuckDis" in $$props) $$invalidate(5, fuckDis = $$props.fuckDis);
		if ("handlePlayShow" in $$props) $$invalidate(6, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handlePicard1,
		handlePicard2,
		fuckDis,
		handlePlayShow,
		LP
	];
}

class Picard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Picard",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$8.warn("<Picard> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Picard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Picard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Mandalorian.svelte generated by Svelte v3.24.0 */

const { console: console_1$9 } = globals;
const file$9 = "src/components/TVComps/Mandalorian.svelte";

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleDis}
function create_if_block$9(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$9(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$9, 73, 8, 2027);
			add_location(button1, file$9, 74, 8, 2085);
			add_location(nav, file$9, 72, 4, 2013);
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file$9, 76, 4, 2150);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleMandalorian1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleMandalorian2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$9(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(72:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (78:8) {#if showlistcount > 0}
function create_if_block_1$9(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShow*/ 65) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(78:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each showlist as sshow }
function create_each_block$9(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file$9, 80, 20, 2267);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file$9, 81, 20, 2365);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file$9, 79, 16, 2242);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$9.name,
		type: "each",
		source: "(79:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$9(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Mandalorian");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Mandalorian");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$9, 69, 0, 1943);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$9(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	console.log("this is y");
	console.log(y);
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$9($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	// onMount(
	async function getMandalorian(x) {
		let addr = `http://192.168.0.42:8888/intMandalorian?season=01`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	//)
	let handleMandalorian1 = () => {
		let promise = getMandalorian().catch(err => console.log(err));
	};

	let handleMandalorian2 = () => {
		let promise = getMandalorian().catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + "/" + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$9(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<Mandalorian> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Mandalorian", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getMandalorian,
		handleMandalorian1,
		handleMandalorian2,
		fuckDis,
		getPlayMedia: getPlayMedia$9,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleMandalorian1" in $$props) $$invalidate(3, handleMandalorian1 = $$props.handleMandalorian1);
		if ("handleMandalorian2" in $$props) $$invalidate(4, handleMandalorian2 = $$props.handleMandalorian2);
		if ("fuckDis" in $$props) $$invalidate(5, fuckDis = $$props.fuckDis);
		if ("handlePlayShow" in $$props) $$invalidate(6, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleMandalorian1,
		handleMandalorian2,
		fuckDis,
		handlePlayShow,
		LP
	];
}

class Mandalorian extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Mandalorian",
			options,
			id: create_fragment$9.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$9.warn("<Mandalorian> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Mandalorian>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Mandalorian>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/AlteredCarbon.svelte generated by Svelte v3.24.0 */

const { console: console_1$a } = globals;
const file$a = "src/components/TVComps/AlteredCarbon.svelte";

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleDis}
function create_if_block$a(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$a(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$a, 73, 8, 2043);
			add_location(button1, file$a, 74, 8, 2103);
			add_location(nav, file$a, 72, 4, 2029);
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file$a, 76, 4, 2170);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleAlteredCarbon1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleAlteredCarbon2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$a(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(72:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (78:8) {#if showlistcount > 0}
function create_if_block_1$a(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShow*/ 65) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$a(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$a(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$a.name,
		type: "if",
		source: "(78:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each showlist as sshow }
function create_each_block$a(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file$a, 80, 20, 2287);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file$a, 81, 20, 2385);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file$a, 79, 16, 2262);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$a.name,
		type: "each",
		source: "(79:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$a(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("AlteredCarbon");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "AlteredCarbon");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$a, 69, 0, 1957);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$a(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	console.log("this is y");
	console.log(y);
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$a($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	// onMount(
	async function getAlteredCarbon(x) {
		let addr = `http://192.168.0.42:8888/intAlteredCarbon?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	//)
	let handleAlteredCarbon1 = () => {
		let promise = getAlteredCarbon(`01`).catch(err => console.log(err));
	};

	let handleAlteredCarbon2 = () => {
		let promise = getAlteredCarbon(`02`).catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8063` + "/" + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$a(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<AlteredCarbon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AlteredCarbon", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getAlteredCarbon,
		handleAlteredCarbon1,
		handleAlteredCarbon2,
		fuckDis,
		getPlayMedia: getPlayMedia$a,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleAlteredCarbon1" in $$props) $$invalidate(3, handleAlteredCarbon1 = $$props.handleAlteredCarbon1);
		if ("handleAlteredCarbon2" in $$props) $$invalidate(4, handleAlteredCarbon2 = $$props.handleAlteredCarbon2);
		if ("fuckDis" in $$props) $$invalidate(5, fuckDis = $$props.fuckDis);
		if ("handlePlayShow" in $$props) $$invalidate(6, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleAlteredCarbon1,
		handleAlteredCarbon2,
		fuckDis,
		handlePlayShow,
		LP
	];
}

class AlteredCarbon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlteredCarbon",
			options,
			id: create_fragment$a.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$a.warn("<AlteredCarbon> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<AlteredCarbon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<AlteredCarbon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVShowsListComp.svelte generated by Svelte v3.24.0 */
const file$b = "src/components/TVShowsListComp.svelte";

function create_fragment$b(ctx) {
	let nav;
	let discovery;
	let t0;
	let enterprise;
	let t1;
	let orville;
	let t2;
	let sttv;
	let t3;
	let tng;
	let t4;
	let voy;
	let t5;
	let ls;
	let t6;
	let lis;
	let t7;
	let picard;
	let t8;
	let mand;
	let t9;
	let acarb;
	let current;

	discovery = new Discovery({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	enterprise = new Enterprise({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	orville = new Orville({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	sttv = new STTV({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	tng = new TNG({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	voy = new Voyager({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	ls = new LastShip({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	lis = new LostInSpace({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	picard = new Picard({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	mand = new Mandalorian({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	acarb = new AlteredCarbon({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			create_component(discovery.$$.fragment);
			t0 = space();
			create_component(enterprise.$$.fragment);
			t1 = space();
			create_component(orville.$$.fragment);
			t2 = space();
			create_component(sttv.$$.fragment);
			t3 = space();
			create_component(tng.$$.fragment);
			t4 = space();
			create_component(voy.$$.fragment);
			t5 = space();
			create_component(ls.$$.fragment);
			t6 = space();
			create_component(lis.$$.fragment);
			t7 = space();
			create_component(picard.$$.fragment);
			t8 = space();
			create_component(mand.$$.fragment);
			t9 = space();
			create_component(acarb.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(discovery.$$.fragment, nav_nodes);
			t0 = claim_space(nav_nodes);
			claim_component(enterprise.$$.fragment, nav_nodes);
			t1 = claim_space(nav_nodes);
			claim_component(orville.$$.fragment, nav_nodes);
			t2 = claim_space(nav_nodes);
			claim_component(sttv.$$.fragment, nav_nodes);
			t3 = claim_space(nav_nodes);
			claim_component(tng.$$.fragment, nav_nodes);
			t4 = claim_space(nav_nodes);
			claim_component(voy.$$.fragment, nav_nodes);
			t5 = claim_space(nav_nodes);
			claim_component(ls.$$.fragment, nav_nodes);
			t6 = claim_space(nav_nodes);
			claim_component(lis.$$.fragment, nav_nodes);
			t7 = claim_space(nav_nodes);
			claim_component(picard.$$.fragment, nav_nodes);
			t8 = claim_space(nav_nodes);
			claim_component(mand.$$.fragment, nav_nodes);
			t9 = claim_space(nav_nodes);
			claim_component(acarb.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(nav, "class", "svelte-14m8txd");
			add_location(nav, file$b, 16, 0, 785);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			mount_component(discovery, nav, null);
			append_dev(nav, t0);
			mount_component(enterprise, nav, null);
			append_dev(nav, t1);
			mount_component(orville, nav, null);
			append_dev(nav, t2);
			mount_component(sttv, nav, null);
			append_dev(nav, t3);
			mount_component(tng, nav, null);
			append_dev(nav, t4);
			mount_component(voy, nav, null);
			append_dev(nav, t5);
			mount_component(ls, nav, null);
			append_dev(nav, t6);
			mount_component(lis, nav, null);
			append_dev(nav, t7);
			mount_component(picard, nav, null);
			append_dev(nav, t8);
			mount_component(mand, nav, null);
			append_dev(nav, t9);
			mount_component(acarb, nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const discovery_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) discovery_changes.LP = /*LOCALPLAY*/ ctx[0];
			discovery.$set(discovery_changes);
			const enterprise_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) enterprise_changes.LP = /*LOCALPLAY*/ ctx[0];
			enterprise.$set(enterprise_changes);
			const orville_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) orville_changes.LP = /*LOCALPLAY*/ ctx[0];
			orville.$set(orville_changes);
			const sttv_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) sttv_changes.LP = /*LOCALPLAY*/ ctx[0];
			sttv.$set(sttv_changes);
			const tng_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) tng_changes.LP = /*LOCALPLAY*/ ctx[0];
			tng.$set(tng_changes);
			const voy_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) voy_changes.LP = /*LOCALPLAY*/ ctx[0];
			voy.$set(voy_changes);
			const ls_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) ls_changes.LP = /*LOCALPLAY*/ ctx[0];
			ls.$set(ls_changes);
			const lis_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) lis_changes.LP = /*LOCALPLAY*/ ctx[0];
			lis.$set(lis_changes);
			const picard_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) picard_changes.LP = /*LOCALPLAY*/ ctx[0];
			picard.$set(picard_changes);
			const mand_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) mand_changes.LP = /*LOCALPLAY*/ ctx[0];
			mand.$set(mand_changes);
			const acarb_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) acarb_changes.LP = /*LOCALPLAY*/ ctx[0];
			acarb.$set(acarb_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(discovery.$$.fragment, local);
			transition_in(enterprise.$$.fragment, local);
			transition_in(orville.$$.fragment, local);
			transition_in(sttv.$$.fragment, local);
			transition_in(tng.$$.fragment, local);
			transition_in(voy.$$.fragment, local);
			transition_in(ls.$$.fragment, local);
			transition_in(lis.$$.fragment, local);
			transition_in(picard.$$.fragment, local);
			transition_in(mand.$$.fragment, local);
			transition_in(acarb.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(discovery.$$.fragment, local);
			transition_out(enterprise.$$.fragment, local);
			transition_out(orville.$$.fragment, local);
			transition_out(sttv.$$.fragment, local);
			transition_out(tng.$$.fragment, local);
			transition_out(voy.$$.fragment, local);
			transition_out(ls.$$.fragment, local);
			transition_out(lis.$$.fragment, local);
			transition_out(picard.$$.fragment, local);
			transition_out(mand.$$.fragment, local);
			transition_out(acarb.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(discovery);
			destroy_component(enterprise);
			destroy_component(orville);
			destroy_component(sttv);
			destroy_component(tng);
			destroy_component(voy);
			destroy_component(ls);
			destroy_component(lis);
			destroy_component(picard);
			destroy_component(mand);
			destroy_component(acarb);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { LOCALPLAY } = $$props;
	const writable_props = ["LOCALPLAY"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TVShowsListComp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TVShowsListComp", $$slots, []);

	$$self.$set = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	$$self.$capture_state = () => ({
		set_store_value,
		Discovery,
		Enterprise,
		Orville,
		STTV,
		TNG,
		VOY: Voyager,
		LS: LastShip,
		LIS: LostInSpace,
		PICARD: Picard,
		MAND: Mandalorian,
		ACARB: AlteredCarbon,
		LOCALPLAY
	});

	$$self.$inject_state = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [LOCALPLAY];
}

class TVShowsListComp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { LOCALPLAY: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TVShowsListComp",
			options,
			id: create_fragment$b.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LOCALPLAY*/ ctx[0] === undefined && !("LOCALPLAY" in props)) {
			console.warn("<TVShowsListComp> was created without expected prop 'LOCALPLAY'");
		}
	}

	get LOCALPLAY() {
		throw new Error("<TVShowsListComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LOCALPLAY(value) {
		throw new Error("<TVShowsListComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/tvshows.svelte generated by Svelte v3.24.0 */
const file$c = "src/routes/tvshows.svelte";

// (34:0) {#if visible3}
function create_if_block_1$b(ctx) {
	let div;
	let video;
	let video_src_value;

	const block = {
		c: function create() {
			div = element("div");
			video = element("video");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);

			video = claim_element(div_nodes, "VIDEO", {
				src: true,
				controls: true,
				autoplay: true,
				class: true
			});

			children(video).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) attr_dev(video, "src", video_src_value);
			video.controls = true;
			video.autoplay = true;
			attr_dev(video, "class", "svelte-calnre");
			add_location(video, file$c, 36, 8, 825);
			attr_dev(div, "id", "vid2");
			attr_dev(div, "class", "svelte-calnre");
			add_location(div, file$c, 34, 4, 729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, video);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TVlocalplayURL_value*/ 2 && video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) {
				attr_dev(video, "src", video_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$b.name,
		type: "if",
		source: "(34:0) {#if visible3}",
		ctx
	});

	return block;
}

// (44:0) {#if !visible3}
function create_if_block$b(ctx) {
	let controls;
	let current;
	controls = new Controls({ $$inline: true });

	const block = {
		c: function create() {
			create_component(controls.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(controls.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(controls, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(controls.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(controls.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(controls, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(44:0) {#if !visible3}",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let t0;
	let t1;
	let input;
	let t2;
	let lable;
	let t3;
	let t4;
	let t5;
	let tvshows;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*visible3*/ ctx[0] && create_if_block_1$b(ctx);
	let if_block1 = !/*visible3*/ ctx[0] && create_if_block$b(ctx);

	tvshows = new TVShowsListComp({
			props: { LOCALPLAY: /*visible3*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			lable = element("lable");
			t3 = text("localplay");
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			create_component(tvshows.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-xfr3l7\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			input = claim_element(nodes, "INPUT", { type: true, value: true });
			t2 = claim_space(nodes);
			lable = claim_element(nodes, "LABLE", {});
			var lable_nodes = children(lable);
			t3 = claim_text(lable_nodes, "localplay");
			lable_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t5 = claim_space(nodes);
			claim_component(tvshows.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "TV Shows";
			attr_dev(input, "type", "checkbox");
			input.__value = "fuck";
			input.value = input.__value;
			add_location(input, file$c, 40, 0, 904);
			add_location(lable, file$c, 41, 0, 965);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, input, anchor);
			input.checked = /*visible3*/ ctx[0];
			insert_dev(target, t2, anchor);
			insert_dev(target, lable, anchor);
			append_dev(lable, t3);
			insert_dev(target, t4, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(tvshows, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible3*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$b(ctx);
					if_block0.c();
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*visible3*/ 1) {
				input.checked = /*visible3*/ ctx[0];
			}

			if (!/*visible3*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*visible3*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$b(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t5.parentNode, t5);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const tvshows_changes = {};
			if (dirty & /*visible3*/ 1) tvshows_changes.LOCALPLAY = /*visible3*/ ctx[0];
			tvshows.$set(tvshows_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(tvshows.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(tvshows.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(lable);
			if (detaching) detach_dev(t4);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t5);
			destroy_component(tvshows, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let visible = false;
	let visible3 = false;

	let fuck = () => {
		if (visible) {
			visible = false;
		} else {
			visible = true;
		}
	};

	let fuck3 = () => {
		if (visible3) {
			$$invalidate(0, visible3 = false);
		} else {
			$$invalidate(0, visible3 = true);
		}
	};

	let TVlocalplayURL_value;

	const unsubplid = TVlocalplayURL.subscribe(value => {
		$$invalidate(1, TVlocalplayURL_value = value);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tvshows> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Tvshows", $$slots, []);

	function input_change_handler() {
		visible3 = this.checked;
		$$invalidate(0, visible3);
	}

	$$self.$capture_state = () => ({
		TVShows: TVShowsListComp,
		Controls,
		TVlocalplayURL,
		visible,
		visible3,
		fuck,
		fuck3,
		TVlocalplayURL_value,
		unsubplid
	});

	$$self.$inject_state = $$props => {
		if ("visible" in $$props) visible = $$props.visible;
		if ("visible3" in $$props) $$invalidate(0, visible3 = $$props.visible3);
		if ("fuck" in $$props) fuck = $$props.fuck;
		if ("fuck3" in $$props) fuck3 = $$props.fuck3;
		if ("TVlocalplayURL_value" in $$props) $$invalidate(1, TVlocalplayURL_value = $$props.TVlocalplayURL_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [visible3, TVlocalplayURL_value, input_change_handler];
}

class Tvshows extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tvshows",
			options,
			id: create_fragment$c.name
		});
	}
}

export default Tvshows;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHZzaG93cy5jM2U3ZjM2Zi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9EaXNjb3Zlcnkuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9FbnRlcnByaXNlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvT3J2aWxsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL1NUVFYuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9UTkcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Wb3lhZ2VyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvTGFzdFNoaXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Mb3N0SW5TcGFjZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL1BpY2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL01hbmRhbG9yaWFuLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvQWx0ZXJlZENhcmJvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVlNob3dzTGlzdENvbXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy90dnNob3dzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIC8vIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuXG4gICAgbGV0IHNob3dsaXN0O1xuICAgIGxldCBzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRGlzID0gZmFsc2VcblxuICAgIC8vIG9uTW91bnQoXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldERpc2NvdmVyeSh4KSB7XG4gICAgICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50RGlzY292ZXJ5P3NlYXNvbj0ke3h9YFxuICAgICAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YVswXS5lcGlzb2RlKVxuICAgICAgICAgICAgICAgIHNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgICAgIHNob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICB9XG4gICAgLy8pXG5cbiAgICBsZXQgaGFuZGxlRGlzY292ZXJ5MSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXREaXNjb3ZlcnkoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVEaXNjb3ZlcnkyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldERpc2NvdmVyeShgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGZ1Y2tEaXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlRGlzKSB7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgeSA9IFwiL21lZGlhL3BpL1BpVEIvbWVkaWEvVFZTaG93c1wiICsgeFxuICAgICAgICBjb25zb2xlLmxvZyhcInRoaXMgaXMgeVwiKVxuICAgICAgICBjb25zb2xlLmxvZyh5KVxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/bW92aWU9JHt5fWBcbiAgICAgICAgY29uc29sZS5sb2coYWRkcilcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICAgbGV0IGhhbmRsZVBsYXlTaG93ID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA2M2AgKyBcIi9cIiArIG1lZGlhXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja0Rpc30+RGlzY292ZXJ5PC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZURpc31cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVEaXNjb3ZlcnkxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVEaXNjb3ZlcnkyfT5zMjwvYnV0dG9uPlxuICAgIDwvbmF2PlxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5U2hvdyhzc2hvdy50dmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICBcbiAgICB9XG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IEVudHNob3dsaXN0O1xuICAgIGxldCBFbnRzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRW50ID0gZmFsc2VcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldEVudGVycHJpc2UoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50RW50ZXJwcmlzZT9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIEVudHNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgRW50c2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlRW50ZXJwcmlzZTEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0RW50ZXJwcmlzZShgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZUVudGVycHJpc2UyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldEVudGVycHJpc2UoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlRW50ZXJwcmlzZTMgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0RW50ZXJwcmlzZShgMDNgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVFbnRlcnByaXNlNCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRFbnRlcnByaXNlKGAwNGApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0VudCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVFbnQpIHtcbiAgICAgICAgICAgIHZpc2libGVFbnQgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZUVudCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCB5ID0gXCIvbWVkaWEvcGkvUGlUQi9tZWRpYS9UVlNob3dzXCIgKyB4XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD9tb3ZpZT0ke3l9YFxuICAgICAgICBjb25zb2xlLmxvZyhhZGRyKVxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVQbGF5U2hvdyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyBtZWRpYVwiKVxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIC8vIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA2M2AgKyBcIi9cIiArIG1lZGlhXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRoaXMgaXMgbmV3cGF0aFwiKVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRW50fSA+RW50ZXJwcmlzZTwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVFbnR9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlRW50ZXJwcmlzZTF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUVudGVycHJpc2UyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVFbnRlcnByaXNlM30+czM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlRW50ZXJwcmlzZTR9PnM0PC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgRW50c2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggRW50c2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3coc3Nob3cudHZmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cblxuICAgIGEge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG5cblxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuICAgIGxldCBPUlZzaG93bGlzdDtcbiAgICBsZXQgT1JWc2hvd2xpc3Rjb3VudDtcbiAgICBsZXQgdmlzaWJsZU9ydiA9IGZhbHNlXG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRPcnZpbGxlKHgpIHtcblxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50T3J2aWxsZT9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIE9SVnNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgT1JWc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZU9SMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRPcnZpbGxlKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZU9SMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRPcnZpbGxlKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cblxuICAgIGxldCBmdWNrT3J2ID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZU9ydikge1xuICAgICAgICAgICAgdmlzaWJsZU9ydiA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlT3J2ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IHkgPSBcIi9tZWRpYS9waS9QaVRCL21lZGlhL1RWU2hvd3NcIiArIHhcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P21vdmllPSR7eX1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlTaG93T3IgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwNjNgICsgbWVkaWFcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZU9ydiA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZU9ydiA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja09ydn0+T3J2aWxsZTwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVPcnZ9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlT1IxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVPUjJ9PnMyPC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgT1JWc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggT1JWc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3dPcihzc2hvdy50dmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbiAgICBcbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IHNob3dsaXN0O1xuICAgIGxldCBzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRGlzID0gZmFsc2VcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFNUVFYoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50U1RUVj9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIHNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlU1RUVkNsaWNrMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRTVFRWKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlU1RUVkNsaWNrMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRTVFRWKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZVNUVFZDbGljazMgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0U1RUVihgMDNgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGZ1Y2tEaXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlRGlzKSB7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgeSA9IFwiL21lZGlhL3BpL1BpVEIvbWVkaWEvVFZTaG93c1wiICsgeFxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/bW92aWU9JHt5fWBcbiAgICAgICAgXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlTaG93U1RUViA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwNjNgICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja0Rpc30gPlNUVFY8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlRGlzfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVNUVFZDbGljazF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVNUVFZDbGljazJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVNUVFZDbGljazN9PnMzPC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3dTVFRWKHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG4gICAgXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IFROR3Nob3dsaXN0O1xuICAgIGxldCBUTkdzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlVE5HID0gZmFsc2VcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFRORyh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRUTkc/c2Vhc29uPSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBUTkdzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIFROR3Nob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVRORzEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVE5HMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVE5HMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDAzYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVE5HNCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVUTkc1ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDVgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVRORzYgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwNmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVE5HNyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDA3YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrVE5HID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZVRORykge1xuICAgICAgICAgICAgdmlzaWJsZVRORyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlVE5HID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IHkgPSBcIi9tZWRpYS9waS9QaVRCL21lZGlhL1RWU2hvd3NcIiArIHhcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P21vdmllPSR7eX1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlUTkcgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDYzYCArIG1lZGlhXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlVE5HID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlVE5HID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tUTkd9PlRoZSBOZXh0IEdlbmVyYXRpb248L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlVE5HfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzN9PnMzPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzR9PnM0PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzV9PnM1PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzZ9PnM2PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzd9PnM3PC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgVE5Hc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggVE5Hc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVRORyhzc2hvdy50dmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbiAgICBcbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IFZPWXNob3dsaXN0O1xuICAgIGxldCBWT1lzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlVm95ID0gZmFsc2VcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFZPWSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRWb3lhZ2VyP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgVk9Zc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBWT1lzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVWT1kxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVZPWTIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZVZPWTMgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZVZPWTQgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwNGApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVk9ZNSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDA1YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVWT1k2ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDZgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVZPWTcgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwN2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja1ZPWSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVWb3kpIHtcbiAgICAgICAgICAgIHZpc2libGVWb3kgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZVZveSA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCB5ID0gXCIvbWVkaWEvcGkvUGlUQi9tZWRpYS9UVlNob3dzXCIgKyB4XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD9tb3ZpZT0ke3l9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVQbGF5Vk9ZID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA2M2AgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZVZPWSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZVZPWSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrVk9ZfT5Wb3lhZ2VyPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZVZveX1cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kzfT5zMzwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k0fT5zNDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k1fT5zNTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k2fT5zNjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k3fT5zNzwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIFZPWXNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIFZPWXNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlWT1koc3Nob3cudHZmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cbiAgICBcbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgTFNzaG93bGlzdDtcbiAgICBsZXQgTFNzaG93bGlzdGNvdW50O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0TFMoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50TGFzdFNoaXA/c2Vhc29uPSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBMU3Nob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgTFNzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVMUzEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TFMoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVMUzIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TFMoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlTFMzID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExTKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUxTNCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRMUyhgMDRgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG5cbiAgICBsZXQgdmlzaWJsZUxTID0gZmFsc2VcbiAgICBsZXQgZnVja0xTID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZUxTKSB7XG4gICAgICAgICAgICB2aXNpYmxlTFMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZUxTID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IHkgPSBcIi9tZWRpYS9waS9QaVRCL21lZGlhL1RWU2hvd3NcIiArIHhcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P21vdmllPSR7eX1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlMUyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwNjNgICsgZm9vWzFdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlTFMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVMUyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrTFN9ID5UaGUgTGFzdCBTaGlwPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZUxTfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUxTMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTFMyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMUzN9PnMzPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUxTNH0+czQ8L2J1dHRvbj5cbiAgICA8L25hdj5cblxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBMU3Nob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIExTc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheUxTKHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHsgXG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbiAgICBcbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgTElTc2hvd2xpc3Q7XG4gICAgbGV0IExJU3Nob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVMSVMgPSBmYWxzZVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRMb3N0SW5TcGFjZSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRMb3N0SW5TcGFjZT9zZWFzb249JHt4fWBcbiAgICAgICAgY29uc29sZS5sb2coYWRkcilcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICBMSVNzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIExJU3Nob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVMSVMxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExvc3RJblNwYWNlKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUxJUzIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TG9zdEluU3BhY2UoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuXG4gICAgbGV0IGZ1Y2tMSVMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlTElTKSB7XG4gICAgICAgICAgICB2aXNpYmxlTElTID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVMSVMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgeSA9IFwiL21lZGlhL3BpL1BpVEIvbWVkaWEvVFZTaG93c1wiICsgeFxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/bW92aWU9JHt5fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVNob3dMSVMgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA2M2AgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZUxJUyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZUxJUyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja0xJU30+TG9zdCBJbiBTcGFjZTwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVMSVN9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTElTMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTElTMn0+czI8L2J1dHRvbj5cbiAgICA8L25hdj5cblxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBMSVNzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBMSVNzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5U2hvd0xJUyhzc2hvdy50dmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbiAgICBcbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICAvLyBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcblxuICAgIGxldCBzaG93bGlzdDtcbiAgICBsZXQgc2hvd2xpc3Rjb3VudDtcbiAgICBsZXQgdmlzaWJsZURpcyA9IGZhbHNlXG5cbiAgICAvLyBvbk1vdW50KFxuICAgICAgICBhc3luYyBmdW5jdGlvbiBnZXRQaWNhcmQoeCkge1xuICAgICAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L2ludFBpY2FyZD9zZWFzb249MDFgXG4gICAgICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhWzBdLmVwaXNvZGUpXG4gICAgICAgICAgICAgICAgc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICAgICAgc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgIH1cbiAgICAvLylcblxuICAgIGxldCBoYW5kbGVQaWNhcmQxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBpY2FyZChgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBpY2FyZDIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGljYXJkKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0RpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVEaXMpIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCB5ID0gXCIvbWVkaWEvcGkvUGlUQi9tZWRpYS9UVlNob3dzXCIgKyB4XG4gICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyB5XCIpXG4gICAgICAgIGNvbnNvbGUubG9nKHkpXG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD9tb3ZpZT0ke3l9YFxuICAgICAgICBjb25zb2xlLmxvZyhhZGRyKVxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgICBsZXQgaGFuZGxlUGxheVNob3cgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDYzYCArIFwiL1wiICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRGlzfT5QaWNhcmQ8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlRGlzfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVBpY2FyZDF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVBpY2FyZDJ9PnMyPC9idXR0b24+XG4gICAgPC9uYXY+XG4gICAgPHVsPlxuICAgICAgICB7I2lmIHNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIHNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlTaG93KHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIFxuICAgIH1cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIC8vIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuXG4gICAgbGV0IHNob3dsaXN0O1xuICAgIGxldCBzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRGlzID0gZmFsc2VcblxuICAgIC8vIG9uTW91bnQoXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldE1hbmRhbG9yaWFuKHgpIHtcbiAgICAgICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRNYW5kYWxvcmlhbj9zZWFzb249MDFgXG4gICAgICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhWzBdLmVwaXNvZGUpXG4gICAgICAgICAgICAgICAgc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICAgICAgc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgIH1cbiAgICAvLylcblxuICAgIGxldCBoYW5kbGVNYW5kYWxvcmlhbjEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TWFuZGFsb3JpYW4oYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVNYW5kYWxvcmlhbjIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TWFuZGFsb3JpYW4oYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrRGlzID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZURpcykge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IHkgPSBcIi9tZWRpYS9waS9QaVRCL21lZGlhL1RWU2hvd3NcIiArIHhcbiAgICAgICAgY29uc29sZS5sb2coXCJ0aGlzIGlzIHlcIilcbiAgICAgICAgY29uc29sZS5sb2coeSlcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P21vdmllPSR7eX1gXG4gICAgICAgIGNvbnNvbGUubG9nKGFkZHIpXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgIGxldCBoYW5kbGVQbGF5U2hvdyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwNjNgICsgXCIvXCIgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tEaXN9Pk1hbmRhbG9yaWFuPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZURpc31cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVNYW5kYWxvcmlhbjF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZU1hbmRhbG9yaWFuMn0+czI8L2J1dHRvbj5cbiAgICA8L25hdj5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3coc3Nob3cudHZmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICAgICAgXG4gICAgfVxuICAgIGEge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgLy8gaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG5cbiAgICBsZXQgc2hvd2xpc3Q7XG4gICAgbGV0IHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVEaXMgPSBmYWxzZVxuXG4gICAgLy8gb25Nb3VudChcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0QWx0ZXJlZENhcmJvbih4KSB7XG4gICAgICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50QWx0ZXJlZENhcmJvbj9zZWFzb249JHt4fWBcbiAgICAgICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFbMF0uZXBpc29kZSlcbiAgICAgICAgICAgICAgICBzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgICAgICBzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgfVxuICAgIC8vKVxuXG4gICAgbGV0IGhhbmRsZUFsdGVyZWRDYXJib24xID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldEFsdGVyZWRDYXJib24oYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVBbHRlcmVkQ2FyYm9uMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRBbHRlcmVkQ2FyYm9uKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0RpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVEaXMpIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCB5ID0gXCIvbWVkaWEvcGkvUGlUQi9tZWRpYS9UVlNob3dzXCIgKyB4XG4gICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyB5XCIpXG4gICAgICAgIGNvbnNvbGUubG9nKHkpXG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD9tb3ZpZT0ke3l9YFxuICAgICAgICBjb25zb2xlLmxvZyhhZGRyKVxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgICBsZXQgaGFuZGxlUGxheVNob3cgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDYzYCArIFwiL1wiICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRGlzfT5BbHRlcmVkQ2FyYm9uPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZURpc31cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVBbHRlcmVkQ2FyYm9uMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlQWx0ZXJlZENhcmJvbjJ9PnMyPC9idXR0b24+XG4gICAgPC9uYXY+XG4gICAgPHVsPlxuICAgICAgICB7I2lmIHNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIHNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlTaG93KHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIFxuICAgIH1cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHNldF9zdG9yZV92YWx1ZSB9IGZyb20gXCJzdmVsdGUvaW50ZXJuYWxcIjtcbiAgICBpbXBvcnQgRGlzY292ZXJ5IGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9EaXNjb3Zlcnkuc3ZlbHRlJ1xuICAgIGltcG9ydCBFbnRlcnByaXNlIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9FbnRlcnByaXNlLnN2ZWx0ZSdcbiAgICBpbXBvcnQgT3J2aWxsZSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvT3J2aWxsZS5zdmVsdGUnXG4gICAgaW1wb3J0IFNUVFYgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL1NUVFYuc3ZlbHRlJ1xuICAgIGltcG9ydCBUTkcgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL1RORy5zdmVsdGUnXG4gICAgaW1wb3J0IFZPWSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvVm95YWdlci5zdmVsdGUnXG4gICAgaW1wb3J0IExTIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9MYXN0U2hpcC5zdmVsdGUnXG4gICAgaW1wb3J0IExJUyBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvTG9zdEluU3BhY2Uuc3ZlbHRlJ1xuICAgIGltcG9ydCBQSUNBUkQgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL1BpY2FyZC5zdmVsdGUnXG4gICAgaW1wb3J0IE1BTkQgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL01hbmRhbG9yaWFuLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQUNBUkIgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL0FsdGVyZWRDYXJib24uc3ZlbHRlJ1xuICAgIGV4cG9ydCBsZXQgTE9DQUxQTEFZO1xuPC9zY3JpcHQ+XG5cbjxuYXY+XG4gICAgPERpc2NvdmVyeSBMUD17TE9DQUxQTEFZfS8+XG4gICAgPEVudGVycHJpc2UgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxPcnZpbGxlIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8U1RUViBMUD17TE9DQUxQTEFZfS8+XG4gICAgPFRORyBMUD17TE9DQUxQTEFZfS8+XG4gICAgPFZPWSBMUD17TE9DQUxQTEFZfS8+XG4gICAgPExTIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8TElTIExQPXtMT0NBTFBMQVl9IC8+XG4gICAgPFBJQ0FSRCBMUD17TE9DQUxQTEFZfSAvPlxuICAgIDxNQU5EIExQPXtMT0NBTFBMQVl9IC8+XG4gICAgPEFDQVJCIExQPXtMT0NBTFBMQVl9IC8+XG48L25hdj5cblxuPHN0eWxlPlxuICAgIG5hdiB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVFZTaG93cyBmcm9tICcuLi9jb21wb25lbnRzL1RWU2hvd3NMaXN0Q29tcC5zdmVsdGUnXG4gICAgaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbXBvbmVudHMvQ29udHJvbHMuc3ZlbHRlJ1xuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vY29tcG9uZW50cy9QbGF5ZXJTdG9yZSdcbiAgICBcbiAgICBsZXQgdmlzaWJsZSA9IGZhbHNlXG4gICAgbGV0IHZpc2libGUzID0gZmFsc2VcblxuXHRsZXQgZnVjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIHZpc2libGUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBmdWNrMyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGUzKSB7XG4gICAgICAgICAgICB2aXNpYmxlMyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlMyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBUVmxvY2FscGxheVVSTF92YWx1ZVxuXHRjb25zdCB1bnN1YnBsaWQgPSBUVmxvY2FscGxheVVSTC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICBUVmxvY2FscGxheVVSTF92YWx1ZSA9IHZhbHVlXG4gICAgfSlcblxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD48dGl0bGU+VFYgU2hvd3M8L3RpdGxlPjwvc3ZlbHRlOmhlYWQ+XG5cbnsjaWYgdmlzaWJsZTN9XG4gICAgPGRpdiBpZD1cInZpZDJcIj5cbiAgICAgICAgPCEtLSBcImh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MS9BY3Rpb24vMTIgU3Ryb25nICgyMDE4KS5tcDRcIiAtLT5cbiAgICAgICAgPHZpZGVvIHNyYz17VFZsb2NhbHBsYXlVUkxfdmFsdWV9IGNvbnRyb2xzIGF1dG9wbGF5PjwvdmlkZW8+XG4gICAgPC9kaXY+XG57L2lmfVxuXG48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXt2aXNpYmxlM30gdmFsdWU9XCJmdWNrXCI+XG48bGFibGU+bG9jYWxwbGF5PC9sYWJsZT5cblxueyNpZiAhdmlzaWJsZTN9XG4gICAgPENvbnRyb2xzIC8+XG4gICAgPCEtLSA8YnV0dG9uIGNsYXNzPVwiY29udHJvbGxlclwiIG9uOmNsaWNrPXtmdWNrfSA+Y29udHJvbHM8L2J1dHRvbj4gLS0+XG57L2lmfVxuXG48VFZTaG93cyBMT0NBTFBMQVk9e3Zpc2libGUzfSAvPlxuXG48c3R5bGU+XG5cbiAgICAjdmlkMiB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB9XG5cbiAgICB2aWRlbyB7XG4gICAgICAgIHdpZHRoOiA4NSU7XG4gICAgfVxuXG48L3N0eWxlPiJdLCJuYW1lcyI6WyJnZXRQbGF5TWVkaWEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQTZFYSxHQUFhLE1BQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1REFKSixHQUFnQjt1REFDaEIsR0FBZ0I7Ozs7Ozs7eUJBRzdCLEdBQWEsTUFBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUNYLEdBQVE7Ozs7Z0NBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFBQyxHQUFROzs7OytCQUFiLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUUrRCxHQUFLLElBQUMsS0FBSzs7OzswQkFDakUsR0FBSyxJQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lDQURRLEdBQWMsY0FBQyxHQUFLLElBQUMsUUFBUSx1QkFBN0IsR0FBYyxjQUFDLEdBQUssSUFBQyxRQUFROzs7Ozs7Ozs7Ozs7b0VBQUksR0FBSyxJQUFDLEtBQUs7b0VBQ2pFLEdBQUssSUFBQyxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
