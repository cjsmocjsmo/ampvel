import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, o as onMount, v as validate_slots, T as TVlocalplayURL, e as element, c as claim_element, a as children, f as detach_dev, h as attr_dev, j as add_location, k as insert_dev, y as validate_each_argument, x as empty, z as destroy_each, t as text, p as space, b as claim_text, r as claim_space, l as append_dev, m as listen_dev, L as is_function, u as set_data_dev, n as noop, Q as run_all, R as set_store_value, A as create_component, B as claim_component, C as mount_component, D as transition_in, E as transition_out, F as destroy_component, q as query_selector_all, M as check_outros, N as group_outros } from './client.f575f4df.js';
import { C as Controls } from './Controls.087886d4.js';

/* src/components/TVComps/Discovery.svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;
const file = "src/components/TVComps/Discovery.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (60:0) {#if visibleDis}
function create_if_block(ctx) {
	let ul;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file, 60, 4, 1623);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(60:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (62:8) {#if showlistcount > 0}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handleDiscovery*/ 17) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(62:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (63:12) {#each showlist as sshow }
function create_each_block(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[6].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[6].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file, 64, 20, 1740);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file, 65, 20, 1840);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file, 63, 16, 1715);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handleDiscovery*/ ctx[4](/*sshow*/ ctx[6].movfspath))) /*handleDiscovery*/ ctx[4](/*sshow*/ ctx[6].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[6].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[6].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(63:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Discovery");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Discovery");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file, 57, 0, 1555);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	onMount(async function getDiscovery() {
		let addr = `http://192.168.0.42:9999/intDiscovery?season=01`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	});

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handleDiscovery = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Discovery> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Discovery", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(5, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		fuckDis,
		getPlayMedia,
		handleDiscovery
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(5, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("fuckDis" in $$props) $$invalidate(3, fuckDis = $$props.fuckDis);
		if ("handleDiscovery" in $$props) $$invalidate(4, handleDiscovery = $$props.handleDiscovery);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [showlist, showlistcount, visibleDis, fuckDis, handleDiscovery, LP];
}

class Discovery extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { LP: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Discovery",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[5] === undefined && !("LP" in props)) {
			console_1.warn("<Discovery> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Discovery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Discovery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Enterprise.svelte generated by Svelte v3.24.0 */

const { console: console_1$1 } = globals;
const file$1 = "src/components/TVComps/Enterprise.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (68:0) {#if visibleEnt}
function create_if_block$1(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*Entshowlistcount*/ ctx[1] > 0 && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$1, 69, 8, 1940);
			add_location(button1, file$1, 70, 8, 1997);
			add_location(button2, file$1, 71, 8, 2054);
			add_location(button3, file$1, 72, 8, 2111);
			add_location(nav, file$1, 68, 4, 1926);
			attr_dev(ul, "class", "svelte-13j0val");
			add_location(ul, file$1, 75, 4, 2176);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleEnterprise1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleEnterprise2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleEnterprise3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleEnterprise4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*Entshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(68:0) {#if visibleEnt}",
		ctx
	});

	return block;
}

// (77:8) {#if Entshowlistcount > 0}
function create_if_block_1$1(ctx) {
	let each_1_anchor;
	let each_value = /*Entshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Entshowlist, handlePlayShow*/ 257) {
				each_value = /*Entshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(77:8) {#if Entshowlistcount > 0}",
		ctx
	});

	return block;
}

// (78:12) {#each Entshowlist as sshow }
function create_each_block$1(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-13j0val");
			add_location(a, file$1, 79, 20, 2299);
			attr_dev(span, "class", "svelte-13j0val");
			add_location(span, file$1, 80, 20, 2398);
			attr_dev(li, "class", "svelte-13j0val");
			add_location(li, file$1, 78, 16, 2274);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].movfspath))) /*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*Entshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*Entshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(78:12) {#each Entshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleEnt*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Enterprise");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Enterprise");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$1, 65, 0, 1856);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckEnt*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleEnt*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$1(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$1($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let Entshowlist;
	let Entshowlistcount;
	let visibleEnt = false;

	async function getEnterprise(x) {
		let addr = `http://192.168.0.42:9999/intEnterprise?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, Entshowlist = data);
			$$invalidate(1, Entshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleEnterprise1 = () => {
		let promise = getEnterprise(`01`).catch(err => console.log(err));
	};

	let handleEnterprise2 = () => {
		let promise = getEnterprise(`02`).catch(err => console.log(err));
	};

	let handleEnterprise3 = () => {
		let promise = getEnterprise(`03`).catch(err => console.log(err));
	};

	let handleEnterprise4 = () => {
		let promise = getEnterprise(`04`).catch(err => console.log(err));
	};

	let fuckEnt = () => {
		if (visibleEnt) {
			$$invalidate(2, visibleEnt = false);
		} else {
			$$invalidate(2, visibleEnt = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleEnt = false);
		} else {
			let promise = getPlayMedia$1(media).catch(err => console.log(err));
			$$invalidate(2, visibleEnt = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Enterprise> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Enterprise", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		getEnterprise,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		getPlayMedia: getPlayMedia$1,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("Entshowlist" in $$props) $$invalidate(0, Entshowlist = $$props.Entshowlist);
		if ("Entshowlistcount" in $$props) $$invalidate(1, Entshowlistcount = $$props.Entshowlistcount);
		if ("visibleEnt" in $$props) $$invalidate(2, visibleEnt = $$props.visibleEnt);
		if ("handleEnterprise1" in $$props) $$invalidate(3, handleEnterprise1 = $$props.handleEnterprise1);
		if ("handleEnterprise2" in $$props) $$invalidate(4, handleEnterprise2 = $$props.handleEnterprise2);
		if ("handleEnterprise3" in $$props) $$invalidate(5, handleEnterprise3 = $$props.handleEnterprise3);
		if ("handleEnterprise4" in $$props) $$invalidate(6, handleEnterprise4 = $$props.handleEnterprise4);
		if ("fuckEnt" in $$props) $$invalidate(7, fuckEnt = $$props.fuckEnt);
		if ("handlePlayShow" in $$props) $$invalidate(8, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		handlePlayShow,
		LP
	];
}

class Enterprise extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Enterprise",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$1.warn("<Enterprise> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Enterprise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Enterprise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Orville.svelte generated by Svelte v3.24.0 */

const { console: console_1$2 } = globals;
const file$2 = "src/components/TVComps/Orville.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (60:0) {#if visibleOrv}
function create_if_block$2(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*ORVshowlistcount*/ ctx[1] > 0 && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$2, 61, 8, 1683);
			add_location(button1, file$2, 62, 8, 1732);
			add_location(nav, file$2, 60, 4, 1669);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$2, 65, 4, 1789);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleOR1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleOR2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*ORVshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(60:0) {#if visibleOrv}",
		ctx
	});

	return block;
}

// (67:8) {#if ORVshowlistcount > 0}
function create_if_block_1$2(ctx) {
	let each_1_anchor;
	let each_value = /*ORVshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ORVshowlist, handlePlayShowOr*/ 65) {
				each_value = /*ORVshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(67:8) {#if ORVshowlistcount > 0}",
		ctx
	});

	return block;
}

// (68:12) {#each ORVshowlist as sshow }
function create_each_block$2(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$2, 69, 20, 1912);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$2, 70, 20, 2013);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$2, 68, 16, 1887);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].movfspath))) /*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*ORVshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*ORVshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(68:12) {#each ORVshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleOrv*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Orville");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Orville");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$2, 57, 0, 1603);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckOrv*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleOrv*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$2(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$2($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let ORVshowlist;
	let ORVshowlistcount;
	let visibleOrv = false;

	async function getOrville(x) {
		let addr = `http://192.168.0.42:9999/intOrville?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, ORVshowlist = data);
			$$invalidate(1, ORVshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleOR1 = () => {
		let promise = getOrville(`01`).catch(err => console.log(err));
	};

	let handleOR2 = () => {
		let promise = getOrville(`02`).catch(err => console.log(err));
	};

	let fuckOrv = () => {
		if (visibleOrv) {
			$$invalidate(2, visibleOrv = false);
		} else {
			$$invalidate(2, visibleOrv = true);
		}
	};

	let handlePlayShowOr = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
		} else {
			let promise = getPlayMedia$2(media).catch(err => console.log(err));
			$$invalidate(2, visibleOrv = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Orville> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Orville", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		getOrville,
		handleOR1,
		handleOR2,
		fuckOrv,
		getPlayMedia: getPlayMedia$2,
		handlePlayShowOr
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("ORVshowlist" in $$props) $$invalidate(0, ORVshowlist = $$props.ORVshowlist);
		if ("ORVshowlistcount" in $$props) $$invalidate(1, ORVshowlistcount = $$props.ORVshowlistcount);
		if ("visibleOrv" in $$props) $$invalidate(2, visibleOrv = $$props.visibleOrv);
		if ("handleOR1" in $$props) $$invalidate(3, handleOR1 = $$props.handleOR1);
		if ("handleOR2" in $$props) $$invalidate(4, handleOR2 = $$props.handleOR2);
		if ("fuckOrv" in $$props) $$invalidate(5, fuckOrv = $$props.fuckOrv);
		if ("handlePlayShowOr" in $$props) $$invalidate(6, handlePlayShowOr = $$props.handlePlayShowOr);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		handleOR1,
		handleOR2,
		fuckOrv,
		handlePlayShowOr,
		LP
	];
}

class Orville extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Orville",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$2.warn("<Orville> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Orville>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Orville>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/STTV.svelte generated by Svelte v3.24.0 */

const { console: console_1$3 } = globals;
const file$3 = "src/components/TVComps/STTV.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (65:0) {#if visibleDis}
function create_if_block$3(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$3(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$3, 66, 8, 1777);
			add_location(button1, file$3, 67, 8, 1833);
			add_location(button2, file$3, 68, 8, 1889);
			add_location(nav, file$3, 65, 4, 1763);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$3, 71, 4, 1953);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleSTTVClick1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleSTTVClick2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleSTTVClick3*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(65:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (73:8) {#if showlistcount > 0}
function create_if_block_1$3(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShowSTTV*/ 129) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(73:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (74:12) {#each showlist as sshow }
function create_each_block$3(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[10].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[10].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$3, 75, 20, 2070);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$3, 76, 20, 2173);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$3, 74, 16, 2045);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].movfspath))) /*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[10].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[10].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(74:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("STTV");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "STTV");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$3, 62, 0, 1699);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$3(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$3($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	async function getSTTV(x) {
		let addr = `http://192.168.0.42:9999/intSTTV?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleSTTVClick1 = () => {
		let promise = getSTTV(`01`).catch(err => console.log(err));
	};

	let handleSTTVClick2 = () => {
		let promise = getSTTV(`02`).catch(err => console.log(err));
	};

	let handleSTTVClick3 = () => {
		let promise = getSTTV(`03`).catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShowSTTV = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$3(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<STTV> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("STTV", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getSTTV,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		getPlayMedia: getPlayMedia$3,
		handlePlayShowSTTV
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleSTTVClick1" in $$props) $$invalidate(3, handleSTTVClick1 = $$props.handleSTTVClick1);
		if ("handleSTTVClick2" in $$props) $$invalidate(4, handleSTTVClick2 = $$props.handleSTTVClick2);
		if ("handleSTTVClick3" in $$props) $$invalidate(5, handleSTTVClick3 = $$props.handleSTTVClick3);
		if ("fuckDis" in $$props) $$invalidate(6, fuckDis = $$props.fuckDis);
		if ("handlePlayShowSTTV" in $$props) $$invalidate(7, handlePlayShowSTTV = $$props.handlePlayShowSTTV);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		handlePlayShowSTTV,
		LP
	];
}

class STTV extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { LP: 8 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "STTV",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[8] === undefined && !("LP" in props)) {
			console_1$3.warn("<STTV> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<STTV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<STTV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/TNG.svelte generated by Svelte v3.24.0 */

const { console: console_1$4 } = globals;
const file$4 = "src/components/TVComps/TNG.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (80:0) {#if visibleTNG}
function create_if_block$4(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*TNGshowlistcount*/ ctx[1] > 0 && create_if_block_1$4(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$4, 81, 8, 2156);
			add_location(button1, file$4, 82, 8, 2206);
			add_location(button2, file$4, 83, 8, 2256);
			add_location(button3, file$4, 84, 8, 2306);
			add_location(button4, file$4, 85, 8, 2356);
			add_location(button5, file$4, 86, 8, 2406);
			add_location(button6, file$4, 87, 8, 2456);
			add_location(nav, file$4, 80, 4, 2142);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$4, 90, 4, 2514);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleTNG1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleTNG2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleTNG3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleTNG4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleTNG5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleTNG6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleTNG7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*TNGshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(80:0) {#if visibleTNG}",
		ctx
	});

	return block;
}

// (92:8) {#if TNGshowlistcount > 0}
function create_if_block_1$4(ctx) {
	let each_1_anchor;
	let each_value = /*TNGshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TNGshowlist, handlePlayTNG*/ 2049) {
				each_value = /*TNGshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(92:8) {#if TNGshowlistcount > 0}",
		ctx
	});

	return block;
}

// (93:12) {#each TNGshowlist as sshow }
function create_each_block$4(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$4, 94, 20, 2637);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$4, 95, 20, 2735);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$4, 93, 16, 2612);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].movfspath))) /*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*TNGshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*TNGshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(93:12) {#each TNGshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleTNG*/ ctx[2] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Next Generation");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Next Generation");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 77, 0, 2064);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckTNG*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleTNG*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$4(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$4($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let TNGshowlist;
	let TNGshowlistcount;
	let visibleTNG = false;

	async function getTNG(x) {
		let addr = `http://192.168.0.42:9999/intTNG?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, TNGshowlist = data);
			$$invalidate(1, TNGshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleTNG1 = () => {
		let promise = getTNG(`01`).catch(err => console.log(err));
	};

	let handleTNG2 = () => {
		let promise = getTNG(`02`).catch(err => console.log(err));
	};

	let handleTNG3 = () => {
		let promise = getTNG(`03`).catch(err => console.log(err));
	};

	let handleTNG4 = () => {
		let promise = getTNG(`04`).catch(err => console.log(err));
	};

	let handleTNG5 = () => {
		let promise = getTNG(`05`).catch(err => console.log(err));
	};

	let handleTNG6 = () => {
		let promise = getTNG(`06`).catch(err => console.log(err));
	};

	let handleTNG7 = () => {
		let promise = getTNG(`07`).catch(err => console.log(err));
	};

	let fuckTNG = () => {
		if (visibleTNG) {
			$$invalidate(2, visibleTNG = false);
		} else {
			$$invalidate(2, visibleTNG = true);
		}
	};

	let handlePlayTNG = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
		} else {
			let promise = getPlayMedia$4(media).catch(err => console.log(err));
			$$invalidate(2, visibleTNG = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<TNG> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TNG", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		getTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		getPlayMedia: getPlayMedia$4,
		handlePlayTNG
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("TNGshowlist" in $$props) $$invalidate(0, TNGshowlist = $$props.TNGshowlist);
		if ("TNGshowlistcount" in $$props) $$invalidate(1, TNGshowlistcount = $$props.TNGshowlistcount);
		if ("visibleTNG" in $$props) $$invalidate(2, visibleTNG = $$props.visibleTNG);
		if ("handleTNG1" in $$props) $$invalidate(3, handleTNG1 = $$props.handleTNG1);
		if ("handleTNG2" in $$props) $$invalidate(4, handleTNG2 = $$props.handleTNG2);
		if ("handleTNG3" in $$props) $$invalidate(5, handleTNG3 = $$props.handleTNG3);
		if ("handleTNG4" in $$props) $$invalidate(6, handleTNG4 = $$props.handleTNG4);
		if ("handleTNG5" in $$props) $$invalidate(7, handleTNG5 = $$props.handleTNG5);
		if ("handleTNG6" in $$props) $$invalidate(8, handleTNG6 = $$props.handleTNG6);
		if ("handleTNG7" in $$props) $$invalidate(9, handleTNG7 = $$props.handleTNG7);
		if ("fuckTNG" in $$props) $$invalidate(10, fuckTNG = $$props.fuckTNG);
		if ("handlePlayTNG" in $$props) $$invalidate(11, handlePlayTNG = $$props.handlePlayTNG);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		handlePlayTNG,
		LP
	];
}

class TNG extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TNG",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$4.warn("<TNG> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<TNG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<TNG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Voyager.svelte generated by Svelte v3.24.0 */

const { console: console_1$5 } = globals;
const file$5 = "src/components/TVComps/Voyager.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (80:0) {#if visibleVoy}
function create_if_block$5(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*VOYshowlistcount*/ ctx[1] > 0 && create_if_block_1$5(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$5, 81, 8, 2148);
			add_location(button1, file$5, 82, 8, 2198);
			add_location(button2, file$5, 83, 8, 2248);
			add_location(button3, file$5, 84, 8, 2298);
			add_location(button4, file$5, 85, 8, 2348);
			add_location(button5, file$5, 86, 8, 2398);
			add_location(button6, file$5, 87, 8, 2448);
			add_location(nav, file$5, 80, 4, 2134);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$5, 90, 4, 2506);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleVOY1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleVOY2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleVOY3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleVOY4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleVOY5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleVOY6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleVOY7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*VOYshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(80:0) {#if visibleVoy}",
		ctx
	});

	return block;
}

// (92:8) {#if VOYshowlistcount > 0}
function create_if_block_1$5(ctx) {
	let each_1_anchor;
	let each_value = /*VOYshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*VOYshowlist, handlePlayVOY*/ 2049) {
				each_value = /*VOYshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(92:8) {#if VOYshowlistcount > 0}",
		ctx
	});

	return block;
}

// (93:12) {#each VOYshowlist as sshow }
function create_each_block$5(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$5, 94, 20, 2629);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$5, 95, 20, 2727);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$5, 93, 16, 2604);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].movfspath))) /*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*VOYshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*VOYshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(93:12) {#each VOYshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleVoy*/ ctx[2] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Voyager");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Voyager");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$5, 77, 0, 2068);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckVOY*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleVoy*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$5(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$5($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let VOYshowlist;
	let VOYshowlistcount;
	let visibleVoy = false;

	async function getVOY(x) {
		let addr = `http://192.168.0.42:9999/intVoyager?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, VOYshowlist = data);
			$$invalidate(1, VOYshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleVOY1 = () => {
		let promise = getVOY(`01`).catch(err => console.log(err));
	};

	let handleVOY2 = () => {
		let promise = getVOY(`02`).catch(err => console.log(err));
	};

	let handleVOY3 = () => {
		let promise = getVOY(`03`).catch(err => console.log(err));
	};

	let handleVOY4 = () => {
		let promise = getVOY(`04`).catch(err => console.log(err));
	};

	let handleVOY5 = () => {
		let promise = getVOY(`05`).catch(err => console.log(err));
	};

	let handleVOY6 = () => {
		let promise = getVOY(`06`).catch(err => console.log(err));
	};

	let handleVOY7 = () => {
		let promise = getVOY(`07`).catch(err => console.log(err));
	};

	let fuckVOY = () => {
		if (visibleVoy) {
			$$invalidate(2, visibleVoy = false);
		} else {
			$$invalidate(2, visibleVoy = true);
		}
	};

	let handlePlayVOY = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
		} else {
			let promise = getPlayMedia$5(media).catch(err => console.log(err));
			visibleVOY = false;
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Voyager> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Voyager", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		getVOY,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		getPlayMedia: getPlayMedia$5,
		handlePlayVOY
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("VOYshowlist" in $$props) $$invalidate(0, VOYshowlist = $$props.VOYshowlist);
		if ("VOYshowlistcount" in $$props) $$invalidate(1, VOYshowlistcount = $$props.VOYshowlistcount);
		if ("visibleVoy" in $$props) $$invalidate(2, visibleVoy = $$props.visibleVoy);
		if ("handleVOY1" in $$props) $$invalidate(3, handleVOY1 = $$props.handleVOY1);
		if ("handleVOY2" in $$props) $$invalidate(4, handleVOY2 = $$props.handleVOY2);
		if ("handleVOY3" in $$props) $$invalidate(5, handleVOY3 = $$props.handleVOY3);
		if ("handleVOY4" in $$props) $$invalidate(6, handleVOY4 = $$props.handleVOY4);
		if ("handleVOY5" in $$props) $$invalidate(7, handleVOY5 = $$props.handleVOY5);
		if ("handleVOY6" in $$props) $$invalidate(8, handleVOY6 = $$props.handleVOY6);
		if ("handleVOY7" in $$props) $$invalidate(9, handleVOY7 = $$props.handleVOY7);
		if ("fuckVOY" in $$props) $$invalidate(10, fuckVOY = $$props.fuckVOY);
		if ("handlePlayVOY" in $$props) $$invalidate(11, handlePlayVOY = $$props.handlePlayVOY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		handlePlayVOY,
		LP
	];
}

class Voyager extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Voyager",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$5.warn("<Voyager> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Voyager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Voyager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LastShip.svelte generated by Svelte v3.24.0 */

const { console: console_1$6 } = globals;
const file$6 = "src/components/TVComps/LastShip.svelte";

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (69:0) {#if visibleLS}
function create_if_block$6(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LSshowlistcount*/ ctx[1] > 0 && create_if_block_1$6(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$6, 70, 8, 1855);
			add_location(button1, file$6, 71, 8, 1904);
			add_location(button2, file$6, 72, 8, 1953);
			add_location(button3, file$6, 73, 8, 2002);
			add_location(nav, file$6, 69, 4, 1841);
			attr_dev(ul, "class", "svelte-1omye9l");
			add_location(ul, file$6, 76, 4, 2059);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLS2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleLS3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleLS4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LSshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(69:0) {#if visibleLS}",
		ctx
	});

	return block;
}

// (78:8) {#if LSshowlistcount > 0}
function create_if_block_1$6(ctx) {
	let each_1_anchor;
	let each_value = /*LSshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LSshowlist, handlePlayLS*/ 257) {
				each_value = /*LSshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(78:8) {#if LSshowlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each LSshowlist as sshow }
function create_each_block$6(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-1omye9l");
			add_location(a, file$6, 80, 20, 2180);
			attr_dev(span, "class", "svelte-1omye9l");
			add_location(span, file$6, 81, 20, 2277);
			attr_dev(li, "class", "svelte-1omye9l");
			add_location(li, file$6, 79, 16, 2155);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].movfspath))) /*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LSshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LSshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(79:12) {#each LSshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLS*/ ctx[2] && create_if_block$6(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Last Ship");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Last Ship");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$6, 66, 0, 1770);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLS*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$6(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$6($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LSshowlist;
	let LSshowlistcount;

	async function getLS(x) {
		let addr = `http://192.168.0.42:9999/intLastShip?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, LSshowlist = data);
			$$invalidate(1, LSshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLS1 = () => {
		let promise = getLS(`01`).catch(err => console.log(err));
	};

	let handleLS2 = () => {
		let promise = getLS(`02`).catch(err => console.log(err));
	};

	let handleLS3 = () => {
		let promise = getLS(`03`).catch(err => console.log(err));
	};

	let handleLS4 = () => {
		let promise = getLS(`04`).catch(err => console.log(err));
	};

	let visibleLS = false;

	let fuckLS = () => {
		if (visibleLS) {
			$$invalidate(2, visibleLS = false);
		} else {
			$$invalidate(2, visibleLS = true);
		}
	};

	let handlePlayLS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleLS = false);
		} else {
			let promise = getPlayMedia$6(media).catch(err => console.log(err));
			$$invalidate(2, visibleLS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<LastShip> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LastShip", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		LSshowlist,
		LSshowlistcount,
		getLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		visibleLS,
		fuckLS,
		getPlayMedia: getPlayMedia$6,
		handlePlayLS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("LSshowlist" in $$props) $$invalidate(0, LSshowlist = $$props.LSshowlist);
		if ("LSshowlistcount" in $$props) $$invalidate(1, LSshowlistcount = $$props.LSshowlistcount);
		if ("handleLS1" in $$props) $$invalidate(3, handleLS1 = $$props.handleLS1);
		if ("handleLS2" in $$props) $$invalidate(4, handleLS2 = $$props.handleLS2);
		if ("handleLS3" in $$props) $$invalidate(5, handleLS3 = $$props.handleLS3);
		if ("handleLS4" in $$props) $$invalidate(6, handleLS4 = $$props.handleLS4);
		if ("visibleLS" in $$props) $$invalidate(2, visibleLS = $$props.visibleLS);
		if ("fuckLS" in $$props) $$invalidate(7, fuckLS = $$props.fuckLS);
		if ("handlePlayLS" in $$props) $$invalidate(8, handlePlayLS = $$props.handlePlayLS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LSshowlist,
		LSshowlistcount,
		visibleLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		fuckLS,
		handlePlayLS,
		LP
	];
}

class LastShip extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LastShip",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$6.warn("<LastShip> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LastShip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LastShip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LostInSpace.svelte generated by Svelte v3.24.0 */

const { console: console_1$7 } = globals;
const file$7 = "src/components/TVComps/LostInSpace.svelte";

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (63:0) {#if visibleLIS}
function create_if_block$7(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LISshowlistcount*/ ctx[1] > 0 && create_if_block_1$7(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$7, 64, 8, 1777);
			add_location(button1, file$7, 65, 8, 1827);
			add_location(nav, file$7, 63, 4, 1763);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$7, 68, 4, 1885);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLIS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLIS2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LISshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$7(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(63:0) {#if visibleLIS}",
		ctx
	});

	return block;
}

// (70:8) {#if LISshowlistcount > 0}
function create_if_block_1$7(ctx) {
	let each_1_anchor;
	let each_value = /*LISshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LISshowlist, handlePlayShowLIS*/ 65) {
				each_value = /*LISshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(70:8) {#if LISshowlistcount > 0}",
		ctx
	});

	return block;
}

// (71:12) {#each LISshowlist as sshow }
function create_each_block$7(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$7, 72, 20, 2008);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$7, 73, 20, 2110);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$7, 71, 16, 1983);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].movfspath))) /*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LISshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LISshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(71:12) {#each LISshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLIS*/ ctx[2] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Lost In Space");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Lost In Space");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$7, 60, 0, 1691);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLIS*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLIS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$7(x) {
	let addr = `http://192.168.0.42:9999/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$7($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LISshowlist;
	let LISshowlistcount;
	let visibleLIS = false;

	async function getLostInSpace(x) {
		let addr = `http://192.168.0.42:9999/intLostInSpace?season=${x}`;
		console.log(addr);

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			$$invalidate(0, LISshowlist = data);
			$$invalidate(1, LISshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLIS1 = () => {
		let promise = getLostInSpace(`01`).catch(err => console.log(err));
	};

	let handleLIS2 = () => {
		let promise = getLostInSpace(`02`).catch(err => console.log(err));
	};

	let fuckLIS = () => {
		if (visibleLIS) {
			$$invalidate(2, visibleLIS = false);
		} else {
			$$invalidate(2, visibleLIS = true);
		}
	};

	let handlePlayShowLIS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
		} else {
			let promise = getPlayMedia$7(media).catch(err => console.log(err));
			$$invalidate(2, visibleLIS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<LostInSpace> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LostInSpace", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		getLostInSpace,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		getPlayMedia: getPlayMedia$7,
		handlePlayShowLIS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("LISshowlist" in $$props) $$invalidate(0, LISshowlist = $$props.LISshowlist);
		if ("LISshowlistcount" in $$props) $$invalidate(1, LISshowlistcount = $$props.LISshowlistcount);
		if ("visibleLIS" in $$props) $$invalidate(2, visibleLIS = $$props.visibleLIS);
		if ("handleLIS1" in $$props) $$invalidate(3, handleLIS1 = $$props.handleLIS1);
		if ("handleLIS2" in $$props) $$invalidate(4, handleLIS2 = $$props.handleLIS2);
		if ("fuckLIS" in $$props) $$invalidate(5, fuckLIS = $$props.fuckLIS);
		if ("handlePlayShowLIS" in $$props) $$invalidate(6, handlePlayShowLIS = $$props.handlePlayShowLIS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		handlePlayShowLIS,
		LP
	];
}

class LostInSpace extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LostInSpace",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$7.warn("<LostInSpace> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LostInSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LostInSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVShowsListComp.svelte generated by Svelte v3.24.0 */
const file$8 = "src/components/TVShowsListComp.svelte";

function create_fragment$8(ctx) {
	let nav;
	let discovery;
	let t0;
	let enterprise;
	let t1;
	let orville;
	let t2;
	let sttv;
	let t3;
	let tng;
	let t4;
	let voy;
	let t5;
	let ls;
	let t6;
	let lis;
	let current;

	discovery = new Discovery({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	enterprise = new Enterprise({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	orville = new Orville({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	sttv = new STTV({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	tng = new TNG({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	voy = new Voyager({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	ls = new LastShip({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	lis = new LostInSpace({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			create_component(discovery.$$.fragment);
			t0 = space();
			create_component(enterprise.$$.fragment);
			t1 = space();
			create_component(orville.$$.fragment);
			t2 = space();
			create_component(sttv.$$.fragment);
			t3 = space();
			create_component(tng.$$.fragment);
			t4 = space();
			create_component(voy.$$.fragment);
			t5 = space();
			create_component(ls.$$.fragment);
			t6 = space();
			create_component(lis.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(discovery.$$.fragment, nav_nodes);
			t0 = claim_space(nav_nodes);
			claim_component(enterprise.$$.fragment, nav_nodes);
			t1 = claim_space(nav_nodes);
			claim_component(orville.$$.fragment, nav_nodes);
			t2 = claim_space(nav_nodes);
			claim_component(sttv.$$.fragment, nav_nodes);
			t3 = claim_space(nav_nodes);
			claim_component(tng.$$.fragment, nav_nodes);
			t4 = claim_space(nav_nodes);
			claim_component(voy.$$.fragment, nav_nodes);
			t5 = claim_space(nav_nodes);
			claim_component(ls.$$.fragment, nav_nodes);
			t6 = claim_space(nav_nodes);
			claim_component(lis.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(nav, "class", "svelte-14m8txd");
			add_location(nav, file$8, 13, 0, 593);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			mount_component(discovery, nav, null);
			append_dev(nav, t0);
			mount_component(enterprise, nav, null);
			append_dev(nav, t1);
			mount_component(orville, nav, null);
			append_dev(nav, t2);
			mount_component(sttv, nav, null);
			append_dev(nav, t3);
			mount_component(tng, nav, null);
			append_dev(nav, t4);
			mount_component(voy, nav, null);
			append_dev(nav, t5);
			mount_component(ls, nav, null);
			append_dev(nav, t6);
			mount_component(lis, nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const discovery_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) discovery_changes.LP = /*LOCALPLAY*/ ctx[0];
			discovery.$set(discovery_changes);
			const enterprise_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) enterprise_changes.LP = /*LOCALPLAY*/ ctx[0];
			enterprise.$set(enterprise_changes);
			const orville_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) orville_changes.LP = /*LOCALPLAY*/ ctx[0];
			orville.$set(orville_changes);
			const sttv_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) sttv_changes.LP = /*LOCALPLAY*/ ctx[0];
			sttv.$set(sttv_changes);
			const tng_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) tng_changes.LP = /*LOCALPLAY*/ ctx[0];
			tng.$set(tng_changes);
			const voy_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) voy_changes.LP = /*LOCALPLAY*/ ctx[0];
			voy.$set(voy_changes);
			const ls_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) ls_changes.LP = /*LOCALPLAY*/ ctx[0];
			ls.$set(ls_changes);
			const lis_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) lis_changes.LP = /*LOCALPLAY*/ ctx[0];
			lis.$set(lis_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(discovery.$$.fragment, local);
			transition_in(enterprise.$$.fragment, local);
			transition_in(orville.$$.fragment, local);
			transition_in(sttv.$$.fragment, local);
			transition_in(tng.$$.fragment, local);
			transition_in(voy.$$.fragment, local);
			transition_in(ls.$$.fragment, local);
			transition_in(lis.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(discovery.$$.fragment, local);
			transition_out(enterprise.$$.fragment, local);
			transition_out(orville.$$.fragment, local);
			transition_out(sttv.$$.fragment, local);
			transition_out(tng.$$.fragment, local);
			transition_out(voy.$$.fragment, local);
			transition_out(ls.$$.fragment, local);
			transition_out(lis.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(discovery);
			destroy_component(enterprise);
			destroy_component(orville);
			destroy_component(sttv);
			destroy_component(tng);
			destroy_component(voy);
			destroy_component(ls);
			destroy_component(lis);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { LOCALPLAY } = $$props;
	const writable_props = ["LOCALPLAY"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TVShowsListComp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TVShowsListComp", $$slots, []);

	$$self.$set = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	$$self.$capture_state = () => ({
		set_store_value,
		Discovery,
		Enterprise,
		Orville,
		STTV,
		TNG,
		VOY: Voyager,
		LS: LastShip,
		LIS: LostInSpace,
		LOCALPLAY
	});

	$$self.$inject_state = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [LOCALPLAY];
}

class TVShowsListComp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { LOCALPLAY: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TVShowsListComp",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LOCALPLAY*/ ctx[0] === undefined && !("LOCALPLAY" in props)) {
			console.warn("<TVShowsListComp> was created without expected prop 'LOCALPLAY'");
		}
	}

	get LOCALPLAY() {
		throw new Error("<TVShowsListComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LOCALPLAY(value) {
		throw new Error("<TVShowsListComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/tvshows.svelte generated by Svelte v3.24.0 */
const file$9 = "src/routes/tvshows.svelte";

// (34:0) {#if visible3}
function create_if_block_1$8(ctx) {
	let div;
	let video;
	let video_src_value;

	const block = {
		c: function create() {
			div = element("div");
			video = element("video");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);

			video = claim_element(div_nodes, "VIDEO", {
				src: true,
				controls: true,
				autoplay: true,
				class: true
			});

			children(video).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) attr_dev(video, "src", video_src_value);
			video.controls = true;
			video.autoplay = true;
			attr_dev(video, "class", "svelte-calnre");
			add_location(video, file$9, 36, 8, 825);
			attr_dev(div, "id", "vid2");
			attr_dev(div, "class", "svelte-calnre");
			add_location(div, file$9, 34, 4, 729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, video);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TVlocalplayURL_value*/ 2 && video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) {
				attr_dev(video, "src", video_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(34:0) {#if visible3}",
		ctx
	});

	return block;
}

// (44:0) {#if !visible3}
function create_if_block$8(ctx) {
	let controls;
	let current;
	controls = new Controls({ $$inline: true });

	const block = {
		c: function create() {
			create_component(controls.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(controls.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(controls, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(controls.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(controls.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(controls, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(44:0) {#if !visible3}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let t0;
	let t1;
	let input;
	let t2;
	let lable;
	let t3;
	let t4;
	let t5;
	let tvshows;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*visible3*/ ctx[0] && create_if_block_1$8(ctx);
	let if_block1 = !/*visible3*/ ctx[0] && create_if_block$8(ctx);

	tvshows = new TVShowsListComp({
			props: { LOCALPLAY: /*visible3*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			lable = element("lable");
			t3 = text("localplay");
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			create_component(tvshows.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-xfr3l7\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			input = claim_element(nodes, "INPUT", { type: true, value: true });
			t2 = claim_space(nodes);
			lable = claim_element(nodes, "LABLE", {});
			var lable_nodes = children(lable);
			t3 = claim_text(lable_nodes, "localplay");
			lable_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t5 = claim_space(nodes);
			claim_component(tvshows.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "TV Shows";
			attr_dev(input, "type", "checkbox");
			input.__value = "fuck";
			input.value = input.__value;
			add_location(input, file$9, 40, 0, 904);
			add_location(lable, file$9, 41, 0, 965);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, input, anchor);
			input.checked = /*visible3*/ ctx[0];
			insert_dev(target, t2, anchor);
			insert_dev(target, lable, anchor);
			append_dev(lable, t3);
			insert_dev(target, t4, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(tvshows, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible3*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$8(ctx);
					if_block0.c();
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*visible3*/ 1) {
				input.checked = /*visible3*/ ctx[0];
			}

			if (!/*visible3*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*visible3*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$8(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t5.parentNode, t5);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const tvshows_changes = {};
			if (dirty & /*visible3*/ 1) tvshows_changes.LOCALPLAY = /*visible3*/ ctx[0];
			tvshows.$set(tvshows_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(tvshows.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(tvshows.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(lable);
			if (detaching) detach_dev(t4);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t5);
			destroy_component(tvshows, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let visible = false;
	let visible3 = false;

	let fuck = () => {
		if (visible) {
			visible = false;
		} else {
			visible = true;
		}
	};

	let fuck3 = () => {
		if (visible3) {
			$$invalidate(0, visible3 = false);
		} else {
			$$invalidate(0, visible3 = true);
		}
	};

	let TVlocalplayURL_value;

	const unsubplid = TVlocalplayURL.subscribe(value => {
		$$invalidate(1, TVlocalplayURL_value = value);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tvshows> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Tvshows", $$slots, []);

	function input_change_handler() {
		visible3 = this.checked;
		$$invalidate(0, visible3);
	}

	$$self.$capture_state = () => ({
		TVShows: TVShowsListComp,
		Controls,
		TVlocalplayURL,
		visible,
		visible3,
		fuck,
		fuck3,
		TVlocalplayURL_value,
		unsubplid
	});

	$$self.$inject_state = $$props => {
		if ("visible" in $$props) visible = $$props.visible;
		if ("visible3" in $$props) $$invalidate(0, visible3 = $$props.visible3);
		if ("fuck" in $$props) fuck = $$props.fuck;
		if ("fuck3" in $$props) fuck3 = $$props.fuck3;
		if ("TVlocalplayURL_value" in $$props) $$invalidate(1, TVlocalplayURL_value = $$props.TVlocalplayURL_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [visible3, TVlocalplayURL_value, input_change_handler];
}

class Tvshows extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tvshows",
			options,
			id: create_fragment$9.name
		});
	}
}

export default Tvshows;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHZzaG93cy41ZTMwODQyYS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9EaXNjb3Zlcnkuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9FbnRlcnByaXNlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvT3J2aWxsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL1NUVFYuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9UTkcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Wb3lhZ2VyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvTGFzdFNoaXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Mb3N0SW5TcGFjZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVlNob3dzTGlzdENvbXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy90dnNob3dzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuXG4gICAgbGV0IHNob3dsaXN0O1xuICAgIGxldCBzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRGlzID0gZmFsc2VcblxuICAgIG9uTW91bnQoXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldERpc2NvdmVyeSgpIHtcbiAgICAgICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9pbnREaXNjb3Zlcnk/c2Vhc29uPTAxYFxuICAgICAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YVswXS5lcGlzb2RlKVxuICAgICAgICAgICAgICAgIHNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgICAgIHNob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICB9XG4gICAgKVxuXG4gICAgbGV0IGZ1Y2tEaXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlRGlzKSB7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjk5OTkvcGxheU1lZGlhUmVhY3Q/dHZzaG93PSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZURpc2NvdmVyeSA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgZm9vWzFdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja0Rpc30+RGlzY292ZXJ5PC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZURpc31cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlRGlzY292ZXJ5KHNzaG93Lm1vdmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICBcbiAgICB9XG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IEVudHNob3dsaXN0O1xuICAgIGxldCBFbnRzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRW50ID0gZmFsc2VcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldEVudGVycHJpc2UoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjk5OTkvaW50RW50ZXJwcmlzZT9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIEVudHNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgRW50c2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlRW50ZXJwcmlzZTEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0RW50ZXJwcmlzZShgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZUVudGVycHJpc2UyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldEVudGVycHJpc2UoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlRW50ZXJwcmlzZTMgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0RW50ZXJwcmlzZShgMDNgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVFbnRlcnByaXNlNCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRFbnRlcnByaXNlKGAwNGApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0VudCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVFbnQpIHtcbiAgICAgICAgICAgIHZpc2libGVFbnQgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZUVudCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9wbGF5TWVkaWFSZWFjdD90dnNob3c9JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVNob3cgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgyYCArIGZvb1sxXVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRW50fSA+RW50ZXJwcmlzZTwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVFbnR9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlRW50ZXJwcmlzZTF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUVudGVycHJpc2UyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVFbnRlcnByaXNlM30+czM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlRW50ZXJwcmlzZTR9PnM0PC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgRW50c2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggRW50c2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3coc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuXG5cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgT1JWc2hvd2xpc3Q7XG4gICAgbGV0IE9SVnNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVPcnYgPSBmYWxzZVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRPcnZpbGxlKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo5OTk5L2ludE9ydmlsbGU/c2Vhc29uPSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBPUlZzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIE9SVnNob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVPUjEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0T3J2aWxsZShgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVPUjIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0T3J2aWxsZShgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG5cbiAgICBsZXQgZnVja09ydiA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVPcnYpIHtcbiAgICAgICAgICAgIHZpc2libGVPcnYgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZU9ydiA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9wbGF5TWVkaWFSZWFjdD90dnNob3c9JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVNob3dPciA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgyYCArIGZvb1sxXVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVPcnYgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tPcnZ9Pk9ydmlsbGU8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlT3J2fVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZU9SMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlT1IyfT5zMjwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIE9SVnNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIE9SVnNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlTaG93T3Ioc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgc2hvd2xpc3Q7XG4gICAgbGV0IHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVEaXMgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0U1RUVih4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9pbnRTVFRWP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVTVFRWQ2xpY2sxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFNUVFYoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVTVFRWQ2xpY2syID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFNUVFYoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlU1RUVkNsaWNrMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRTVFRWKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0RpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVEaXMpIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9wbGF5TWVkaWFSZWFjdD90dnNob3c9JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVNob3dTVFRWID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBmb29bMV1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja0Rpc30gPlNUVFY8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlRGlzfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVNUVFZDbGljazF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVNUVFZDbGljazJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVNUVFZDbGljazN9PnMzPC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3dTVFRWKHNzaG93Lm1vdmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuICAgIFxuICAgIGEge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuICAgIGxldCBUTkdzaG93bGlzdDtcbiAgICBsZXQgVE5Hc2hvd2xpc3Rjb3VudDtcbiAgICBsZXQgdmlzaWJsZVRORyA9IGZhbHNlXG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRUTkcoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjk5OTkvaW50VE5HP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgVE5Hc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBUTkdzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVUTkcxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVRORzIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZVRORzMgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZVRORzQgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwNGApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVE5HNSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDA1YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVUTkc2ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDZgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVRORzcgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwN2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja1RORyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVUTkcpIHtcbiAgICAgICAgICAgIHZpc2libGVUTkcgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZVRORyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9wbGF5TWVkaWFSZWFjdD90dnNob3c9JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVRORyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgZm9vWzFdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlVE5HID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tUTkd9PlRoZSBOZXh0IEdlbmVyYXRpb248L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlVE5HfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzN9PnMzPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzR9PnM0PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzV9PnM1PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzZ9PnM2PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVRORzd9PnM3PC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgVE5Hc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggVE5Hc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVRORyhzc2hvdy5tb3Zmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cblxuICAgIGEge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG4gICAgXG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuICAgIGxldCBWT1lzaG93bGlzdDtcbiAgICBsZXQgVk9Zc2hvd2xpc3Rjb3VudDtcbiAgICBsZXQgdmlzaWJsZVZveSA9IGZhbHNlXG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRWT1koeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjk5OTkvaW50Vm95YWdlcj9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIFZPWXNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgVk9Zc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVk9ZMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVWT1kyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVWT1kzID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDNgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVWT1k0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDRgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVZPWTUgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwNWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVk9ZNiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDA2YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVWT1k3ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDdgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGZ1Y2tWT1kgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlVm95KSB7XG4gICAgICAgICAgICB2aXNpYmxlVm95ID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVWb3kgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjk5OTkvcGxheU1lZGlhUmVhY3Q/dHZzaG93PSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlWT1kgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgyYCArIGZvb1sxXVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZVZPWSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrVk9ZfT5Wb3lhZ2VyPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZVZveX1cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kzfT5zMzwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k0fT5zNDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k1fT5zNTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k2fT5zNjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k3fT5zNzwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIFZPWXNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIFZPWXNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlWT1koc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG4gICAgXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IExTc2hvd2xpc3Q7XG4gICAgbGV0IExTc2hvd2xpc3Rjb3VudDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldExTKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo5OTk5L2ludExhc3RTaGlwP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgTFNzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIExTc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlTFMxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExTKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlTFMyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExTKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUxTMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRMUyhgMDNgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVMUzQgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TFMoYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuXG4gICAgbGV0IHZpc2libGVMUyA9IGZhbHNlXG4gICAgbGV0IGZ1Y2tMUyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVMUykge1xuICAgICAgICAgICAgdmlzaWJsZUxTID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVMUyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9wbGF5TWVkaWFSZWFjdD90dnNob3c9JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheUxTID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBmb29bMV1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVMUyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZUxTID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tMU30gPlRoZSBMYXN0IFNoaXA8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlTFN9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTFMxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMUzJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUxTM30+czM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTFM0fT5zNDwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIExTc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggTFNzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5TFMoc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHsgXG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbiAgICBcbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgTElTc2hvd2xpc3Q7XG4gICAgbGV0IExJU3Nob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVMSVMgPSBmYWxzZVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRMb3N0SW5TcGFjZSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6OTk5OS9pbnRMb3N0SW5TcGFjZT9zZWFzb249JHt4fWBcbiAgICAgICAgY29uc29sZS5sb2coYWRkcilcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICBMSVNzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIExJU3Nob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVMSVMxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExvc3RJblNwYWNlKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUxJUzIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TG9zdEluU3BhY2UoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuXG4gICAgbGV0IGZ1Y2tMSVMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlTElTKSB7XG4gICAgICAgICAgICB2aXNpYmxlTElTID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVMSVMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjk5OTkvcGxheU1lZGlhUmVhY3Q/dHZzaG93PSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlTaG93TElTID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgZm9vWzFdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlTElTID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrTElTfT5Mb3N0IEluIFNwYWNlPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZUxJU31cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMSVMxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMSVMyfT5zMjwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIExJU3Nob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIExJU3Nob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlTaG93TElTKHNzaG93Lm1vdmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbiAgICBcbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBzZXRfc3RvcmVfdmFsdWUgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gICAgaW1wb3J0IERpc2NvdmVyeSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvRGlzY292ZXJ5LnN2ZWx0ZSdcbiAgICBpbXBvcnQgRW50ZXJwcmlzZSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvRW50ZXJwcmlzZS5zdmVsdGUnXG4gICAgaW1wb3J0IE9ydmlsbGUgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL09ydmlsbGUuc3ZlbHRlJ1xuICAgIGltcG9ydCBTVFRWIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9TVFRWLnN2ZWx0ZSdcbiAgICBpbXBvcnQgVE5HIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9UTkcuc3ZlbHRlJ1xuICAgIGltcG9ydCBWT1kgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL1ZveWFnZXIuc3ZlbHRlJ1xuICAgIGltcG9ydCBMUyBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvTGFzdFNoaXAuc3ZlbHRlJ1xuICAgIGltcG9ydCBMSVMgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL0xvc3RJblNwYWNlLnN2ZWx0ZSdcbiAgICBleHBvcnQgbGV0IExPQ0FMUExBWTtcbjwvc2NyaXB0PlxuXG48bmF2PlxuICAgIDxEaXNjb3ZlcnkgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxFbnRlcnByaXNlIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8T3J2aWxsZSBMUD17TE9DQUxQTEFZfS8+XG4gICAgPFNUVFYgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxUTkcgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxWT1kgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxMUyBMUD17TE9DQUxQTEFZfS8+XG4gICAgPExJUyBMUD17TE9DQUxQTEFZfSAvPlxuPC9uYXY+XG5cbjxzdHlsZT5cbiAgICBuYXYge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFRWU2hvd3MgZnJvbSAnLi4vY29tcG9uZW50cy9UVlNob3dzTGlzdENvbXAuc3ZlbHRlJ1xuICAgIGltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRyb2xzLnN2ZWx0ZSdcbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL2NvbXBvbmVudHMvUGxheWVyU3RvcmUnXG4gICAgXG4gICAgbGV0IHZpc2libGUgPSBmYWxzZVxuICAgIGxldCB2aXNpYmxlMyA9IGZhbHNlXG5cblx0bGV0IGZ1Y2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB2aXNpYmxlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZnVjazMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlMykge1xuICAgICAgICAgICAgdmlzaWJsZTMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZTMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgVFZsb2NhbHBsYXlVUkxfdmFsdWVcblx0Y29uc3QgdW5zdWJwbGlkID0gVFZsb2NhbHBsYXlVUkwuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgVFZsb2NhbHBsYXlVUkxfdmFsdWUgPSB2YWx1ZVxuICAgIH0pXG5cbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmhlYWQ+PHRpdGxlPlRWIFNob3dzPC90aXRsZT48L3N2ZWx0ZTpoZWFkPlxuXG57I2lmIHZpc2libGUzfVxuICAgIDxkaXYgaWQ9XCJ2aWQyXCI+XG4gICAgICAgIDwhLS0gXCJodHRwOi8vMTkyLjE2OC4wLjQyOjgwODEvQWN0aW9uLzEyIFN0cm9uZyAoMjAxOCkubXA0XCIgLS0+XG4gICAgICAgIDx2aWRlbyBzcmM9e1RWbG9jYWxwbGF5VVJMX3ZhbHVlfSBjb250cm9scyBhdXRvcGxheT48L3ZpZGVvPlxuICAgIDwvZGl2Plxuey9pZn1cblxuPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD17dmlzaWJsZTN9IHZhbHVlPVwiZnVja1wiPlxuPGxhYmxlPmxvY2FscGxheTwvbGFibGU+XG5cbnsjaWYgIXZpc2libGUzfVxuICAgIDxDb250cm9scyAvPlxuICAgIDwhLS0gPGJ1dHRvbiBjbGFzcz1cImNvbnRyb2xsZXJcIiBvbjpjbGljaz17ZnVja30gPmNvbnRyb2xzPC9idXR0b24+IC0tPlxuey9pZn1cblxuPFRWU2hvd3MgTE9DQUxQTEFZPXt2aXNpYmxlM30gLz5cblxuPHN0eWxlPlxuXG4gICAgI3ZpZDIge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgdmlkZW8ge1xuICAgICAgICB3aWR0aDogODUlO1xuICAgIH1cblxuPC9zdHlsZT4iXSwibmFtZXMiOlsiZ2V0UGxheU1lZGlhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztrQ0E2RGEsR0FBYSxNQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFBakIsR0FBYSxNQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFDWCxHQUFROzs7O2dDQUFiLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBQUMsR0FBUTs7OzsrQkFBYixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O29DQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFFaUUsR0FBSyxJQUFDLEtBQUs7Ozs7MEJBQ25FLEdBQUssSUFBQyxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FEUSxHQUFlLGNBQUMsR0FBSyxJQUFDLFNBQVMsd0JBQS9CLEdBQWUsY0FBQyxHQUFLLElBQUMsU0FBUzs7Ozs7Ozs7Ozs7O29FQUFJLEdBQUssSUFBQyxLQUFLO29FQUNuRSxHQUFLLElBQUMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQU5uQyxHQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzREFGRyxHQUFPOzs7OztzQkFFcEIsR0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
