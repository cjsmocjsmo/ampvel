import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, w as playliststore, x as ampvel, g as globals, e as element, p as space, t as text, c as claim_element, a as children, r as claim_space, b as claim_text, f as detach_dev, h as attr_dev, j as add_location, k as insert_dev, l as append_dev, m as listen_dev, y as prevent_default, n as noop, z as empty, A as validate_each_argument, u as set_data_dev, B as destroy_each, o as onMount, C as playlistidstore, D as create_component, E as claim_component, F as mount_component, G as transition_in, H as transition_out, I as destroy_component, J as prop_dev, q as query_selector_all } from './client.8c21cdc3.js';

/* src/components/PlaylistComps/AddRandomPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;
const file = "src/components/PlaylistComps/AddRandomPlaylist.svelte";

// (37:0) {#if radvisible}
function create_if_block(ctx) {
	let form;
	let input0;
	let t0;
	let label0;
	let t1;
	let br0;
	let t2;
	let input1;
	let t3;
	let label1;
	let t4;
	let br1;
	let t5;
	let input2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			input0 = element("input");
			t0 = space();
			label0 = element("label");
			t1 = text("Playlist Name");
			br0 = element("br");
			t2 = space();
			input1 = element("input");
			t3 = space();
			label1 = element("label");
			t4 = text("Number Of Songs");
			br1 = element("br");
			t5 = space();
			input2 = element("input");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { class: true });
			var form_nodes = children(form);
			input0 = claim_element(form_nodes, "INPUT", { id: true, name: true, type: true });
			t0 = claim_space(form_nodes);
			label0 = claim_element(form_nodes, "LABEL", {});
			var label0_nodes = children(label0);
			t1 = claim_text(label0_nodes, "Playlist Name");
			label0_nodes.forEach(detach_dev);
			br0 = claim_element(form_nodes, "BR", {});
			t2 = claim_space(form_nodes);
			input1 = claim_element(form_nodes, "INPUT", { id: true, name: true, type: true });
			t3 = claim_space(form_nodes);
			label1 = claim_element(form_nodes, "LABEL", {});
			var label1_nodes = children(label1);
			t4 = claim_text(label1_nodes, "Number Of Songs");
			label1_nodes.forEach(detach_dev);
			br1 = claim_element(form_nodes, "BR", {});
			t5 = claim_space(form_nodes);
			input2 = claim_element(form_nodes, "INPUT", { type: true, value: true });
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input0, "id", "plname");
			attr_dev(input0, "name", "plname");
			attr_dev(input0, "type", "text");
			add_location(input0, file, 38, 8, 1022);
			add_location(label0, file, 39, 8, 1078);
			add_location(br0, file, 39, 36, 1106);
			attr_dev(input1, "id", "plcount");
			attr_dev(input1, "name", "plcount");
			attr_dev(input1, "type", "text");
			add_location(input1, file, 40, 8, 1121);
			add_location(label1, file, 41, 8, 1179);
			add_location(br1, file, 41, 38, 1209);
			attr_dev(input2, "type", "submit");
			input2.value = "Add";
			add_location(input2, file, 42, 8, 1224);
			attr_dev(form, "class", "svelte-1wja0j");
			add_location(form, file, 37, 4, 965);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, input0);
			append_dev(form, t0);
			append_dev(form, label0);
			append_dev(label0, t1);
			append_dev(form, br0);
			append_dev(form, t2);
			append_dev(form, input1);
			append_dev(form, t3);
			append_dev(form, label1);
			append_dev(label1, t4);
			append_dev(form, br1);
			append_dev(form, t5);
			append_dev(form, input2);

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[2]), false, true, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(37:0) {#if radvisible}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*radvisible*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Add Random Playlist");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Add Random Playlist");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file, 34, 0, 886);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*randvis*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*radvisible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let radvisible = false;

	let randvis = () => {
		if (radvisible) {
			$$invalidate(0, radvisible = false);
		} else {
			$$invalidate(0, radvisible = true);
		}
	};

	let plname;
	let plcount;
	let playlists;

	async function handleSubmit(event) {
		$$invalidate(0, radvisible = false);
		plname = event.target.plname.value;
		plcount = event.target.plcount.value;
		let promise = getAddRandomPlaylist().catch(err => console.log(err));
	}

	async function getAddRandomPlaylist() {
		await fetch(`${ampvel}/AddRandomPlaylist?playlistname=${plname}&playlistcount=${plcount}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			playlists = data.plists;
			playliststore.set(playlists);
		}).catch(err => console.log(err));
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<AddRandomPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AddRandomPlaylist", $$slots, []);

	$$self.$capture_state = () => ({
		playliststore,
		ampvel,
		radvisible,
		randvis,
		plname,
		plcount,
		playlists,
		handleSubmit,
		getAddRandomPlaylist
	});

	$$self.$inject_state = $$props => {
		if ("radvisible" in $$props) $$invalidate(0, radvisible = $$props.radvisible);
		if ("randvis" in $$props) $$invalidate(1, randvis = $$props.randvis);
		if ("plname" in $$props) plname = $$props.plname;
		if ("plcount" in $$props) plcount = $$props.plcount;
		if ("playlists" in $$props) playlists = $$props.playlists;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [radvisible, randvis, handleSubmit];
}

class AddRandomPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AddRandomPlaylist",
			options,
			id: create_fragment.name
		});
	}
}

/* src/components/PlaylistComps/AddEmptyPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$1 } = globals;
const file$1 = "src/components/PlaylistComps/AddEmptyPlaylist.svelte";

// (34:0) {#if visible}
function create_if_block$1(ctx) {
	let form;
	let input0;
	let t0;
	let label;
	let t1;
	let br;
	let t2;
	let input1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			input0 = element("input");
			t0 = space();
			label = element("label");
			t1 = text("Playlist Name");
			br = element("br");
			t2 = space();
			input1 = element("input");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", {});
			var form_nodes = children(form);

			input0 = claim_element(form_nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			t0 = claim_space(form_nodes);
			label = claim_element(form_nodes, "LABEL", {});
			var label_nodes = children(label);
			t1 = claim_text(label_nodes, "Playlist Name");
			label_nodes.forEach(detach_dev);
			br = claim_element(form_nodes, "BR", {});
			t2 = claim_space(form_nodes);
			input1 = claim_element(form_nodes, "INPUT", { type: true, value: true });
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input0, "id", "plname");
			attr_dev(input0, "name", "plname");
			attr_dev(input0, "type", "text");
			input0.value = "";
			add_location(input0, file$1, 35, 8, 975);
			add_location(label, file$1, 36, 8, 1039);
			add_location(br, file$1, 36, 36, 1067);
			attr_dev(input1, "type", "submit");
			input1.value = "Add";
			add_location(input1, file$1, 37, 8, 1082);
			add_location(form, file$1, 34, 4, 899);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, input0);
			append_dev(form, t0);
			append_dev(form, label);
			append_dev(label, t1);
			append_dev(form, br);
			append_dev(form, t2);
			append_dev(form, input1);

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*handleAddPlayListNameToDBSubmit*/ ctx[2]), false, true, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(34:0) {#if visible}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visible*/ ctx[0] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Add Empty Playlist");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Add Empty Playlist");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$1, 31, 0, 828);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuck*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let visible = false;

	let fuck = () => {
		if (visible) {
			$$invalidate(0, visible = false);
		} else {
			$$invalidate(0, visible = true);
		}
	};

	let newplname;

	async function handleAddPlayListNameToDBSubmit(event) {
		$$invalidate(0, visible = false);
		newplname = event.target.plname.value;
		let promise = getAddPlayListNameToDB().catch(err => console.log(err));
	}

	async function getAddPlayListNameToDB() {
		fetch(`${ampvel}/AddPlayListNameToDB?playlistname=${newplname}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			let pname = data.pnames;
			playliststore.set(pname);
		}).catch(err => console.log(err));
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<AddEmptyPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AddEmptyPlaylist", $$slots, []);

	$$self.$capture_state = () => ({
		text,
		playliststore,
		ampvel,
		visible,
		fuck,
		newplname,
		handleAddPlayListNameToDBSubmit,
		getAddPlayListNameToDB
	});

	$$self.$inject_state = $$props => {
		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
		if ("fuck" in $$props) $$invalidate(1, fuck = $$props.fuck);
		if ("newplname" in $$props) newplname = $$props.newplname;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [visible, fuck, handleAddPlayListNameToDBSubmit];
}

class AddEmptyPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AddEmptyPlaylist",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/components/PlaylistComps/DeletePlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$2 } = globals;
const file$2 = "src/components/PlaylistComps/DeletePlaylist.svelte";

function create_fragment$2(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Delete");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { id: true, class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Delete");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", "delete");
			attr_dev(button, "class", "svelte-1le1i94");
			add_location(button, file$2, 18, 0, 508);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*deleteClick*/ ctx[0], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { PLID } = $$props;
	let NPL;

	async function getDeletePlaylistFromDB() {
		fetch(`${ampvel}/DeletePlaylistFromDB?playlistid=${PLID}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			NPL = data.npl;
			playliststore.set(NPL);
		});
	}

	let deleteClick = () => {
		let promise = getDeletePlaylistFromDB().catch(err => console.log(err));
	};

	const writable_props = ["PLID"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<DeletePlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("DeletePlaylist", $$slots, []);

	$$self.$set = $$props => {
		if ("PLID" in $$props) $$invalidate(1, PLID = $$props.PLID);
	};

	$$self.$capture_state = () => ({
		playliststore,
		ampvel,
		PLID,
		NPL,
		getDeletePlaylistFromDB,
		deleteClick
	});

	$$self.$inject_state = $$props => {
		if ("PLID" in $$props) $$invalidate(1, PLID = $$props.PLID);
		if ("NPL" in $$props) NPL = $$props.NPL;
		if ("deleteClick" in $$props) $$invalidate(0, deleteClick = $$props.deleteClick);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [deleteClick, PLID];
}

class DeletePlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { PLID: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DeletePlaylist",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*PLID*/ ctx[1] === undefined && !("PLID" in props)) {
			console_1$2.warn("<DeletePlaylist> was created without expected prop 'PLID'");
		}
	}

	get PLID() {
		throw new Error("<DeletePlaylist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set PLID(value) {
		throw new Error("<DeletePlaylist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PlaylistComps/LoadPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$3 } = globals;
const file$3 = "src/components/PlaylistComps/LoadPlaylist.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (39:0) {:else}
function create_else_block(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops no Playlist selected");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops no Playlist selected");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$3, 39, 4, 1112);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(39:0) {:else}",
		ctx
	});

	return block;
}

// (30:0) {#if PLID !== ""}
function create_if_block$2(ctx) {
	let each_1_anchor;
	let each_value = /*SONGS*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*SONGS*/ 2) {
				each_value = /*SONGS*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(30:0) {#if PLID !== \\\"\\\"}",
		ctx
	});

	return block;
}

// (31:4) {#each SONGS as s}
function create_each_block(ctx) {
	let div;
	let img;
	let img_src_value;
	let t0;
	let p0;
	let t1_value = /*s*/ ctx[4].artist + "";
	let t1;
	let t2;
	let p1;
	let t3_value = /*s*/ ctx[4].album + "";
	let t3;
	let t4;
	let p2;
	let t5_value = /*s*/ ctx[4].name + "";
	let t5;
	let t6;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			t0 = space();
			p0 = element("p");
			t1 = text(t1_value);
			t2 = space();
			p1 = element("p");
			t3 = text(t3_value);
			t4 = space();
			p2 = element("p");
			t5 = text(t5_value);
			t6 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
			t0 = claim_space(div_nodes);
			p0 = claim_element(div_nodes, "P", {});
			var p0_nodes = children(p0);
			t1 = claim_text(p0_nodes, t1_value);
			p0_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", {});
			var p1_nodes = children(p1);
			t3 = claim_text(p1_nodes, t3_value);
			p1_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			p2 = claim_element(div_nodes, "P", {});
			var p2_nodes = children(p2);
			t5 = claim_text(p2_nodes, t5_value);
			p2_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = /*s*/ ctx[4].thumbnail)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "fuck");
			attr_dev(img, "class", "svelte-rmqprw");
			add_location(img, file$3, 32, 12, 950);
			add_location(p0, file$3, 33, 12, 998);
			add_location(p1, file$3, 34, 12, 1028);
			add_location(p2, file$3, 35, 12, 1057);
			add_location(div, file$3, 31, 8, 932);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t0);
			append_dev(div, p0);
			append_dev(p0, t1);
			append_dev(div, t2);
			append_dev(div, p1);
			append_dev(p1, t3);
			append_dev(div, t4);
			append_dev(div, p2);
			append_dev(p2, t5);
			append_dev(div, t6);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*SONGS*/ 2 && img.src !== (img_src_value = /*s*/ ctx[4].thumbnail)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*SONGS*/ 2 && t1_value !== (t1_value = /*s*/ ctx[4].artist + "")) set_data_dev(t1, t1_value);
			if (dirty & /*SONGS*/ 2 && t3_value !== (t3_value = /*s*/ ctx[4].album + "")) set_data_dev(t3, t3_value);
			if (dirty & /*SONGS*/ 2 && t5_value !== (t5_value = /*s*/ ctx[4].name + "")) set_data_dev(t5, t5_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(31:4) {#each SONGS as s}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*PLID*/ ctx[0] !== "") return create_if_block$2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Load");
			t1 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { id: true });
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Load");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", "playlistLoadBtn");
			add_location(button, file$3, 27, 0, 810);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*handleLoadSubmit*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { PLID } = $$props;
	let SONGS = [];

	async function getCreatePlayerPlaylist() {
		let addr = `${ampvel}/CreatePlayerPlaylist?playlistid=${PLID}`;
		console.log(addr);

		await fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(1, SONGS = data.makePL);
			console.log(SONGS[0]);
		}).catch(err => console.log(err));
	}

	// async function handleLoadSubmit(event) {
	async function handleLoadSubmit() {
		// console.log(event.target.SONGS)
		// plname = event.target.plname.value;
		let promise = getCreatePlayerPlaylist().catch(err => console.log(err));

		console.log("this is songs from loadplaylist page");
		console.log(SONGS);
	}

	const writable_props = ["PLID"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<LoadPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LoadPlaylist", $$slots, []);

	$$self.$set = $$props => {
		if ("PLID" in $$props) $$invalidate(0, PLID = $$props.PLID);
	};

	$$self.$capture_state = () => ({
		PLID,
		ampvel,
		SONGS,
		getCreatePlayerPlaylist,
		handleLoadSubmit
	});

	$$self.$inject_state = $$props => {
		if ("PLID" in $$props) $$invalidate(0, PLID = $$props.PLID);
		if ("SONGS" in $$props) $$invalidate(1, SONGS = $$props.SONGS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [PLID, SONGS, handleLoadSubmit];
}

class LoadPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { PLID: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadPlaylist",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*PLID*/ ctx[0] === undefined && !("PLID" in props)) {
			console_1$3.warn("<LoadPlaylist> was created without expected prop 'PLID'");
		}
	}

	get PLID() {
		throw new Error("<LoadPlaylist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set PLID(value) {
		throw new Error("<LoadPlaylist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PlaylistComps/EditPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$4 } = globals;
const file$4 = "src/components/PlaylistComps/EditPlaylist.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (39:0) {#if editvisible}
function create_if_block$3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*songlist_count*/ ctx[1] > 1) return create_if_block_1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(39:0) {#if editvisible}",
		ctx
	});

	return block;
}

// (49:4) {:else}
function create_else_block$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops zero songs");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops zero songs");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$4, 49, 8, 1299);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(49:4) {:else}",
		ctx
	});

	return block;
}

// (40:4) {#if songlist_count > 1}
function create_if_block_1(ctx) {
	let t0;
	let button;
	let t1;
	let mounted;
	let dispose;
	let each_value = /*songlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			button = element("button");
			t1 = text("Complete");
			this.h();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			t0 = claim_space(nodes);
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t1 = claim_text(button_nodes, "Complete");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 47, 8, 1237);
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			insert_dev(target, button, anchor);
			append_dev(button, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*edvi*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*songlist*/ 1) {
				each_value = /*songlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(t0.parentNode, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(40:4) {#if songlist_count > 1}",
		ctx
	});

	return block;
}

// (41:8) {#each songlist as song}
function create_each_block$1(ctx) {
	let ul;
	let li;
	let p;
	let t0_value = /*song*/ ctx[7][0] + "";
	let t0;
	let button;
	let t1;
	let p_id_value;

	const block = {
		c: function create() {
			ul = element("ul");
			li = element("li");
			p = element("p");
			t0 = text(t0_value);
			button = element("button");
			t1 = text("Remove");
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li = claim_element(ul_nodes, "LI", {});
			var li_nodes = children(li);
			p = claim_element(li_nodes, "P", { id: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, t0_value);
			button = claim_element(p_nodes, "BUTTON", { id: true, class: true });
			var button_nodes = children(button);
			t1 = claim_text(button_nodes, "Remove");
			button_nodes.forEach(detach_dev);
			p_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", "removeBtn");
			attr_dev(button, "class", "svelte-1bwgj62");
			add_location(button, file$4, 43, 45, 1130);
			attr_dev(p, "id", p_id_value = /*song*/ ctx[7][1]);
			add_location(p, file$4, 43, 20, 1105);
			add_location(li, file$4, 42, 16, 1080);
			attr_dev(ul, "class", "svelte-1bwgj62");
			add_location(ul, file$4, 41, 12, 1059);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			append_dev(ul, li);
			append_dev(li, p);
			append_dev(p, t0);
			append_dev(p, button);
			append_dev(button, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*songlist*/ 1 && t0_value !== (t0_value = /*song*/ ctx[7][0] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*songlist*/ 1 && p_id_value !== (p_id_value = /*song*/ ctx[7][1])) {
				attr_dev(p, "id", p_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(41:8) {#each songlist as song}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*editvisible*/ ctx[2] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Edit");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Edit");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 37, 0, 899);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*handleAllPlaylistSongsFromDBSubmit*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*editvisible*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { PLID } = $$props;

	let handleAllPlaylistSongsFromDBSubmit = () => {
		$$invalidate(2, editvisible = true);
		let promise = getAllPlaylistSongsFromDB().catch(err => console.log(err));
	};

	let songlist;
	let songlist_count;

	async function getAllPlaylistSongsFromDB() {
		fetch(`${ampvel}/AllPlaylistSongsFromDB?playlistid=${PLID}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, songlist = data.taz);
			$$invalidate(1, songlist_count = songlist.length);
		}).catch(err => console.log(err));
	}

	let editvisible = true;

	let edvi = () => {
		if (editvisible) {
			$$invalidate(2, editvisible = false);
		} else {
			$$invalidate(2, editvisible = true);
		}
	};

	const writable_props = ["PLID"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<EditPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("EditPlaylist", $$slots, []);

	$$self.$set = $$props => {
		if ("PLID" in $$props) $$invalidate(5, PLID = $$props.PLID);
	};

	$$self.$capture_state = () => ({
		PLID,
		ampvel,
		handleAllPlaylistSongsFromDBSubmit,
		songlist,
		songlist_count,
		getAllPlaylistSongsFromDB,
		editvisible,
		edvi
	});

	$$self.$inject_state = $$props => {
		if ("PLID" in $$props) $$invalidate(5, PLID = $$props.PLID);
		if ("handleAllPlaylistSongsFromDBSubmit" in $$props) $$invalidate(3, handleAllPlaylistSongsFromDBSubmit = $$props.handleAllPlaylistSongsFromDBSubmit);
		if ("songlist" in $$props) $$invalidate(0, songlist = $$props.songlist);
		if ("songlist_count" in $$props) $$invalidate(1, songlist_count = $$props.songlist_count);
		if ("editvisible" in $$props) $$invalidate(2, editvisible = $$props.editvisible);
		if ("edvi" in $$props) $$invalidate(4, edvi = $$props.edvi);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		songlist,
		songlist_count,
		editvisible,
		handleAllPlaylistSongsFromDBSubmit,
		edvi,
		PLID
	];
}

class EditPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { PLID: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditPlaylist",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*PLID*/ ctx[5] === undefined && !("PLID" in props)) {
			console_1$4.warn("<EditPlaylist> was created without expected prop 'PLID'");
		}
	}

	get PLID() {
		throw new Error("<EditPlaylist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set PLID(value) {
		throw new Error("<EditPlaylist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PlaylistList.svelte generated by Svelte v3.24.0 */
const file$5 = "src/components/PlaylistList.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (62:12) {:else}
function create_else_block_1(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(62:12) {:else}",
		ctx
	});

	return block;
}

// (60:34) 
function create_if_block_3(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops no playlists found");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops no playlists found");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 60, 16, 1861);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(60:34) ",
		ctx
	});

	return block;
}

// (53:12) {#if PLCOUNT > 1}
function create_if_block_2(ctx) {
	let each_1_anchor;
	let each_value_1 = /*PLNAMES*/ ctx[1];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PLNAMES, plid*/ 3) {
				each_value_1 = /*PLNAMES*/ ctx[1];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(53:12) {#if PLCOUNT > 1}",
		ctx
	});

	return block;
}

// (54:16) {#each PLNAMES as pln}
function create_each_block_1(ctx) {
	let li;
	let label;
	let t0_value = /*pln*/ ctx[12][0] + "";
	let t0;
	let label_for_value;
	let t1;
	let input;
	let input_id_value;
	let input_name_value;
	let input_value_value;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			label = element("label");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			label = claim_element(li_nodes, "LABEL", { for: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, t0_value);
			label_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);

			input = claim_element(li_nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", label_for_value = /*pln*/ ctx[12][1]);
			add_location(label, file$5, 55, 24, 1619);
			attr_dev(input, "id", input_id_value = /*pln*/ ctx[12][1]);
			attr_dev(input, "name", input_name_value = /*pln*/ ctx[12][1]);
			attr_dev(input, "type", "radio");
			input.__value = input_value_value = /*pln*/ ctx[12][1];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[6][0].push(input);
			add_location(input, file$5, 56, 24, 1680);
			add_location(li, file$5, 54, 20, 1590);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, label);
			append_dev(label, t0);
			append_dev(li, t1);
			append_dev(li, input);
			input.checked = input.__value === /*plid*/ ctx[0];
			append_dev(li, t2);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PLNAMES*/ 2 && t0_value !== (t0_value = /*pln*/ ctx[12][0] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*PLNAMES*/ 2 && label_for_value !== (label_for_value = /*pln*/ ctx[12][1])) {
				attr_dev(label, "for", label_for_value);
			}

			if (dirty & /*PLNAMES*/ 2 && input_id_value !== (input_id_value = /*pln*/ ctx[12][1])) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty & /*PLNAMES*/ 2 && input_name_value !== (input_name_value = /*pln*/ ctx[12][1])) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty & /*PLNAMES*/ 2 && input_value_value !== (input_value_value = /*pln*/ ctx[12][1])) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*plid*/ 1) {
				input.checked = input.__value === /*plid*/ ctx[0];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			/*$$binding_groups*/ ctx[6][0].splice(/*$$binding_groups*/ ctx[6][0].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(54:16) {#each PLNAMES as pln}",
		ctx
	});

	return block;
}

// (76:12) {:else}
function create_else_block$2(ctx) {
	let p;
	let t0;
	let t1_value = /*PPLNAMES*/ ctx[3][0]["playlistid"] + "";
	let t1;
	let t2;
	let label;
	let t3_value = /*PPLNAMES*/ ctx[3][0]["playlistname"] + "";
	let t3;
	let label_for_value;
	let t4;
	let input;
	let input_id_value;
	let input_name_value;
	let input_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("this is pplnames: ");
			t1 = text(t1_value);
			t2 = space();
			label = element("label");
			t3 = text(t3_value);
			t4 = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "this is pplnames: ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			label = claim_element(nodes, "LABEL", { for: true });
			var label_nodes = children(label);
			t3 = claim_text(label_nodes, t3_value);
			label_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);

			input = claim_element(nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 76, 12, 2651);
			attr_dev(label, "for", label_for_value = /*PPLNAMES*/ ctx[3][0]["playlistid"]);
			add_location(label, file$5, 77, 16, 2720);
			attr_dev(input, "id", input_id_value = /*PPLNAMES*/ ctx[3][0]["playlistid"]);
			attr_dev(input, "name", input_name_value = /*PPLNAMES*/ ctx[3][0]["playlistname"]);
			attr_dev(input, "type", "radio");
			input.__value = input_value_value = /*PPLNAMES*/ ctx[3][0]["playlistname"];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[6][0].push(input);
			add_location(input, file$5, 78, 16, 2813);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, label, anchor);
			append_dev(label, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, input, anchor);
			input.checked = input.__value === /*plid*/ ctx[0];

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler_2*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PPLNAMES*/ 8 && t1_value !== (t1_value = /*PPLNAMES*/ ctx[3][0]["playlistid"] + "")) set_data_dev(t1, t1_value);
			if (dirty & /*PPLNAMES*/ 8 && t3_value !== (t3_value = /*PPLNAMES*/ ctx[3][0]["playlistname"] + "")) set_data_dev(t3, t3_value);

			if (dirty & /*PPLNAMES*/ 8 && label_for_value !== (label_for_value = /*PPLNAMES*/ ctx[3][0]["playlistid"])) {
				attr_dev(label, "for", label_for_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_id_value !== (input_id_value = /*PPLNAMES*/ ctx[3][0]["playlistid"])) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_name_value !== (input_name_value = /*PPLNAMES*/ ctx[3][0]["playlistname"])) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_value_value !== (input_value_value = /*PPLNAMES*/ ctx[3][0]["playlistname"])) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*plid*/ 1) {
				input.checked = input.__value === /*plid*/ ctx[0];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(label);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(input);
			/*$$binding_groups*/ ctx[6][0].splice(/*$$binding_groups*/ ctx[6][0].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(76:12) {:else}",
		ctx
	});

	return block;
}

// (74:35) 
function create_if_block_1$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops no playlists found");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops no playlists found");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 74, 16, 2586);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(74:35) ",
		ctx
	});

	return block;
}

// (67:12) {#if PPLCOUNT > 1}
function create_if_block$4(ctx) {
	let each_1_anchor;
	let each_value = /*PPLNAMES*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PPLNAMES, plid*/ 9) {
				each_value = /*PPLNAMES*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(67:12) {#if PPLCOUNT > 1}",
		ctx
	});

	return block;
}

// (68:16) {#each PPLNAMES as pln}
function create_each_block$2(ctx) {
	let li;
	let label;
	let t0_value = /*pln*/ ctx[12]["playlistname"] + "";
	let t0;
	let label_for_value;
	let t1;
	let input;
	let input_id_value;
	let input_name_value;
	let input_value_value;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			label = element("label");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			label = claim_element(li_nodes, "LABEL", { for: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, t0_value);
			label_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);

			input = claim_element(li_nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", label_for_value = /*pln*/ ctx[12]["playlistid"]);
			add_location(label, file$5, 69, 24, 2285);
			attr_dev(input, "id", input_id_value = /*pln*/ ctx[12]["playlistid"]);
			attr_dev(input, "name", input_name_value = /*pln*/ ctx[12]["playlistid"]);
			attr_dev(input, "type", "radio");
			input.__value = input_value_value = /*pln*/ ctx[12]["playlistid"];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[6][0].push(input);
			add_location(input, file$5, 70, 24, 2370);
			add_location(li, file$5, 68, 20, 2256);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, label);
			append_dev(label, t0);
			append_dev(li, t1);
			append_dev(li, input);
			input.checked = input.__value === /*plid*/ ctx[0];
			append_dev(li, t2);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler_1*/ ctx[7]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PPLNAMES*/ 8 && t0_value !== (t0_value = /*pln*/ ctx[12]["playlistname"] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*PPLNAMES*/ 8 && label_for_value !== (label_for_value = /*pln*/ ctx[12]["playlistid"])) {
				attr_dev(label, "for", label_for_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_id_value !== (input_id_value = /*pln*/ ctx[12]["playlistid"])) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_name_value !== (input_name_value = /*pln*/ ctx[12]["playlistid"])) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_value_value !== (input_value_value = /*pln*/ ctx[12]["playlistid"])) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*plid*/ 1) {
				input.checked = input.__value === /*plid*/ ctx[0];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			/*$$binding_groups*/ ctx[6][0].splice(/*$$binding_groups*/ ctx[6][0].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(68:16) {#each PPLNAMES as pln}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let p;
	let t0;
	let t1;
	let t2;
	let form;
	let ul;
	let t3;
	let t4;
	let nav;
	let loadplaylist;
	let t5;
	let deleteplaylist;
	let t6;
	let editplaylist;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*PLCOUNT*/ ctx[2] > 1) return create_if_block_2;
		if (/*PLCOUNT*/ ctx[2] < 1) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*PPLCOUNT*/ ctx[4] > 1) return create_if_block$4;
		if (/*PPLCOUNT*/ ctx[4] < 1) return create_if_block_1$1;
		return create_else_block$2;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1(ctx);

	loadplaylist = new LoadPlaylist({
			props: { PLID: /*plid*/ ctx[0] },
			$$inline: true
		});

	deleteplaylist = new DeletePlaylist({
			props: { PLID: /*plid*/ ctx[0] },
			$$inline: true
		});

	editplaylist = new EditPlaylist({
			props: { PLID: /*plid*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			p = element("p");
			t0 = text("Currently selected playlist: ");
			t1 = text(/*plid*/ ctx[0]);
			t2 = space();
			form = element("form");
			ul = element("ul");
			if_block0.c();
			t3 = space();
			if_block1.c();
			t4 = space();
			nav = element("nav");
			create_component(loadplaylist.$$.fragment);
			t5 = space();
			create_component(deleteplaylist.$$.fragment);
			t6 = space();
			create_component(editplaylist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			p = claim_element(div_nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "Currently selected playlist: ");
			t1 = claim_text(p_nodes, /*plid*/ ctx[0]);
			p_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			form = claim_element(div_nodes, "FORM", {});
			var form_nodes = children(form);
			ul = claim_element(form_nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if_block0.l(ul_nodes);
			t3 = claim_space(ul_nodes);
			if_block1.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(loadplaylist.$$.fragment, nav_nodes);
			t5 = claim_space(nav_nodes);
			claim_component(deleteplaylist.$$.fragment, nav_nodes);
			t6 = claim_space(nav_nodes);
			claim_component(editplaylist.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 49, 4, 1434);
			attr_dev(ul, "class", "svelte-hk3op");
			add_location(ul, file$5, 51, 8, 1496);
			add_location(form, file$5, 50, 4, 1481);
			add_location(div, file$5, 48, 0, 1424);
			attr_dev(nav, "class", "svelte-hk3op");
			add_location(nav, file$5, 84, 0, 3006);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, p);
			append_dev(p, t0);
			append_dev(p, t1);
			append_dev(div, t2);
			append_dev(div, form);
			append_dev(form, ul);
			if_block0.m(ul, null);
			append_dev(ul, t3);
			if_block1.m(ul, null);
			insert_dev(target, t4, anchor);
			insert_dev(target, nav, anchor);
			mount_component(loadplaylist, nav, null);
			append_dev(nav, t5);
			mount_component(deleteplaylist, nav, null);
			append_dev(nav, t6);
			mount_component(editplaylist, nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*plid*/ 1) set_data_dev(t1, /*plid*/ ctx[0]);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(ul, t3);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(ul, null);
				}
			}

			const loadplaylist_changes = {};
			if (dirty & /*plid*/ 1) loadplaylist_changes.PLID = /*plid*/ ctx[0];
			loadplaylist.$set(loadplaylist_changes);
			const deleteplaylist_changes = {};
			if (dirty & /*plid*/ 1) deleteplaylist_changes.PLID = /*plid*/ ctx[0];
			deleteplaylist.$set(deleteplaylist_changes);
			const editplaylist_changes = {};
			if (dirty & /*plid*/ 1) editplaylist_changes.PLID = /*plid*/ ctx[0];
			editplaylist.$set(editplaylist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadplaylist.$$.fragment, local);
			transition_in(deleteplaylist.$$.fragment, local);
			transition_in(editplaylist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadplaylist.$$.fragment, local);
			transition_out(deleteplaylist.$$.fragment, local);
			transition_out(editplaylist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block0.d();
			if_block1.d();
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(nav);
			destroy_component(loadplaylist);
			destroy_component(deleteplaylist);
			destroy_component(editplaylist);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let plid = "";
	let PLNAMES;
	let PLCOUNT = 0;

	onMount(async function getAllPlaylists() {
		fetch(`${ampaddr}/AllPlaylists`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			let cunt = [];
			let voo;

			let moo = data.plnames.map(da => {
				voo = { playlistname: da[0], playlistid: da[1] };
				cunt.push(voo);
			});

			$$invalidate(1, PLNAMES = cunt);
			playliststore.set(PLNAMES);
			playlistidstore.set(plid);

			if (PLNAMES != undefined) {
				$$invalidate(2, PLCOUNT = PLNAMES.length);
			}
		});
	});

	let PPLNAMES;
	let PPLCOUNT;

	const unsubscribe = playliststore.subscribe(value => {
		$$invalidate(1, PLNAMES = undefined);
		$$invalidate(2, PLCOUNT = undefined);
		$$invalidate(3, PPLNAMES = value);
		$$invalidate(4, PPLCOUNT = PPLNAMES.length);
	});

	let playlistidstore_value;

	const unsubplid = playlistidstore.subscribe(value => {
		playlistidstore_value = value;
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PlaylistList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("PlaylistList", $$slots, []);
	const $$binding_groups = [[]];

	function input_change_handler() {
		plid = this.__value;
		$$invalidate(0, plid);
	}

	function input_change_handler_1() {
		plid = this.__value;
		$$invalidate(0, plid);
	}

	function input_change_handler_2() {
		plid = this.__value;
		$$invalidate(0, plid);
	}

	$$self.$capture_state = () => ({
		DeletePlaylist,
		LoadPlaylist,
		EditPlaylist,
		playliststore,
		playlistidstore,
		ampvel,
		onMount,
		plid,
		PLNAMES,
		PLCOUNT,
		PPLNAMES,
		PPLCOUNT,
		unsubscribe,
		playlistidstore_value,
		unsubplid
	});

	$$self.$inject_state = $$props => {
		if ("plid" in $$props) $$invalidate(0, plid = $$props.plid);
		if ("PLNAMES" in $$props) $$invalidate(1, PLNAMES = $$props.PLNAMES);
		if ("PLCOUNT" in $$props) $$invalidate(2, PLCOUNT = $$props.PLCOUNT);
		if ("PPLNAMES" in $$props) $$invalidate(3, PPLNAMES = $$props.PPLNAMES);
		if ("PPLCOUNT" in $$props) $$invalidate(4, PPLCOUNT = $$props.PPLCOUNT);
		if ("playlistidstore_value" in $$props) playlistidstore_value = $$props.playlistidstore_value;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		plid,
		PLNAMES,
		PLCOUNT,
		PPLNAMES,
		PPLCOUNT,
		input_change_handler,
		$$binding_groups,
		input_change_handler_1,
		input_change_handler_2
	];
}

class PlaylistList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PlaylistList",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/components/PlaylistComps/AudioPlayer.svelte generated by Svelte v3.24.0 */

const file$6 = "src/components/PlaylistComps/AudioPlayer.svelte";

function create_fragment$6(ctx) {
	let div0;
	let audio;
	let audio_src_value;
	let t0;
	let div2;
	let div1;
	let ol;
	let li0;
	let a0;
	let t1;
	let t2;
	let li1;
	let a1;
	let t3;

	const block = {
		c: function create() {
			div0 = element("div");
			audio = element("audio");
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			ol = element("ol");
			li0 = element("li");
			a0 = element("a");
			t1 = text("Boo1");
			t2 = space();
			li1 = element("li");
			a1 = element("a");
			t3 = text("Boo2");
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", {
				class: true,
				"data-url": true,
				"data-title": true
			});

			var div0_nodes = children(div0);
			audio = claim_element(div0_nodes, "AUDIO", { src: true, controls: true, class: true });
			children(audio).forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			ol = claim_element(div1_nodes, "OL", { class: true });
			var ol_nodes = children(ol);
			li0 = claim_element(ol_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			a0 = claim_element(li0_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);
			t1 = claim_text(a0_nodes, "Boo1");
			a0_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t2 = claim_space(ol_nodes);
			li1 = claim_element(ol_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			a1 = claim_element(li1_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			t3 = claim_text(a1_nodes, "Boo2");
			a1_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			ol_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (audio.src !== (audio_src_value = "")) attr_dev(audio, "src", audio_src_value);
			audio.controls = true;
			attr_dev(audio, "class", "svelte-1fl1oc6");
			add_location(audio, file$6, 274, 4, 14037);
			attr_dev(div0, "class", "player-wrap svelte-1fl1oc6");
			attr_dev(div0, "data-url", "boo1.mp3");
			attr_dev(div0, "data-title", "Boo1");
			add_location(div0, file$6, 273, 0, 13968);
			attr_dev(a0, "href", "boo1.mp3");
			attr_dev(a0, "class", "svelte-1fl1oc6");
			add_location(a0, file$6, 281, 7, 14128);
			attr_dev(li0, "class", "svelte-1fl1oc6");
			add_location(li0, file$6, 281, 3, 14124);
			attr_dev(a1, "href", "boo2.mp3");
			attr_dev(a1, "class", "svelte-1fl1oc6");
			add_location(a1, file$6, 282, 7, 14168);
			attr_dev(li1, "class", "svelte-1fl1oc6");
			add_location(li1, file$6, 282, 3, 14164);
			attr_dev(ol, "class", "svelte-1fl1oc6");
			add_location(ol, file$6, 280, 2, 14116);
			attr_dev(div1, "class", "playlist-wrap svelte-1fl1oc6");
			add_location(div1, file$6, 279, 1, 14086);
			attr_dev(div2, "class", "svelte-1fl1oc6");
			add_location(div2, file$6, 278, 0, 14079);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, audio);
			insert_dev(target, t0, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, ol);
			append_dev(ol, li0);
			append_dev(li0, a0);
			append_dev(a0, t1);
			append_dev(ol, t2);
			append_dev(ol, li1);
			append_dev(li1, a1);
			append_dev(a1, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let jsPlayer = document.querySelector(".player-wrap");

	if (jsPlayer) {
		jsPlayer = {
			wrap: jsPlayer,
			player: jsPlayer.querySelector("audio"),
			//         player: (jsPlayer.querySelector('audio') || { play: function(){}, pause: function(){} }),
			//         play: (jsPlayer.querySelector('.play') || {}),
			//         pause: (jsPlayer.querySelector('.pause') || {}),
			//         seek: (jsPlayer.querySelector('.seek') || {}),
			//         prev: (jsPlayer.querySelector('.prev') || {}),
			next: jsPlayer.querySelector(".next") || {},
			//         button: (jsPlayer.querySelector('.button') || { style: {} }),
			//         wrapList: (document.querySelector('.playlist-wrap') || {}),
			//         action: (jsPlayer.querySelector('.action') || {}),
			//         title: (jsPlayer.querySelector('.title') || {}),
			//         current: (jsPlayer.querySelector('.current') || {}),
			//         duration: (jsPlayer.querySelector('.duration') || {}),
			trackCount: 0,
			//     seeking: null,
			playing: false,
			tracks: [],
			track: [],
			idx: 0
		};

		//     jsPlayer.playClicked = function jsPlayerPlayClicked(){
		//         jsPlayer.button.style.visibility = 'hidden';
		//         jsPlayer.pause.style.display = 'block';
		//         jsPlayer.play.style.display = 'none';
		//         jsPlayer.playing = true;
		//         jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//         jsPlayer.player.play();
		//         jsPlayer.updateSeek();
		//     };
		//     jsPlayer.pauseClicked = function jsPlayerPauseClicked(){
		//         jsPlayer.play.style.display = 'block';
		//         jsPlayer.pause.style.display = 'none';
		//         clearTimeout(jsPlayer.seeking);
		//         jsPlayer.playing = false;
		//         jsPlayer.action.innerHTML = 'Paused&hellip;';
		//         jsPlayer.player.pause();
		//     };
		//     jsPlayer.loadPlaylist = function jaPlayerLoadPlaylist(){
		//         jsPlayer.playlist = jsPlayer.wrapList? jsPlayer.wrapList.querySelectorAll('ol > li') : [];
		//         var len = jsPlayer.playlist.length,
		//             tmp, i;
		//         for (i = 0; i < len; i++) {
		//             if (!jsPlayer.playlist[i].dataset) {
		//                 jsPlayer.playlist[i].dataset = {};
		//             }
		//             tmp = jsPlayer.playlist[i].querySelector('a');
		//             if (tmp && !jsPlayer.playlist[i].dataset.idx) {
		//                 jsPlayer.playlist[i].dataset.idx = i + 1;
		//                 jsPlayer.trackCount++;
		//                 jsPlayer.tracks.push({
		//                     "file": tmp.href,
		//                     "name": (tmp.textContent || tmp.innerText).replace(/^\s+|\s+$/g, ''),
		//                     "track": i + 1
		//                 });
		//             }
		//         }
		//     };
		//     jsPlayer.loadTrack = function jsPlayerLoadTrack(idx){
		//         var len = jsPlayer.playlist.length,
		//             i;
		//         for (i=0; i < len; i++) {
		//             if (jsPlayer.playlist[i].classList) {
		//                 if (i === idx) {
		//                     jsPlayer.playlist[i].classList.add('sel');
		//                 } else {
		//                     jsPlayer.playlist[i].classList.remove('sel');
		//                 }
		//             }
		//         }
		//         jsPlayer.title.innerHTML = jsPlayer.tracks[idx].name;
		//         jsPlayer.player.src = jsPlayer.tracks[idx].file + '.mp3';
		//     };
		//     jsPlayer.playTrack = function jsPlayerPlayTrack(idx){
		//         jsPlayer.loadTrack(idx);
		//         jsPlayer.playing = true;
		//         jsPlayer.playClicked();
		//     };
		jsPlayer.init = function jsPlayerInit() {
			var track = jsPlayer.wrap && jsPlayer.wrap.dataset && jsPlayer.wrap.dataset.url
				? jsPlayer.wrap
				: null;
		}; //         if (!!document.createElement('audio').canPlayType('audio/mpeg')) {
		//             if (jsPlayer.wrapList && jsPlayer.wrapList.querySelectorAll('ol > li').length > 0) {
		//                 jsPlayer.loadPlaylist();
		//             } else if (track) {

		//                 jsPlayer.tracks = [{
		//                     "file": track.dataset.url,
		//                     "name": (track.dataset.title || ''),
		//                     "track": 1
		//                 }];
		//             }
		//             if (jsPlayer.tracks.length > 0) {
		//                 if (jsPlayer.player) {
		//                     jsPlayer.player.addEventListener('ended', function playerEnded(){
		//                         if (jsPlayer.idx + 1 < jsPlayer.trackCount) {
		//                             jsPlayer.idx++;
		//                             jsPlayer.playTrack(jsPlayer.idx);
		//                         } else {
		//                             jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                             jsPlayer.player.pause();
		//                             jsPlayer.idx = 0;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                         }
		//                     }, true);
		//                     jsPlayer.player.addEventListener('loadeddata', function playerLoadeddata(){
		//                         jsPlayer.setDuration();
		//                     }, true);
		//                 }
		//                 if (jsPlayer.play) {
		//                     jsPlayer.play.addEventListener('click', jsPlayer.playClicked, true);
		//                 }
		//                 if (jsPlayer.pause) {
		//                     jsPlayer.pause.addEventListener('click', jsPlayer.pauseClicked, true);
		//                 }
		//                 if (jsPlayer.button) {
		//                     jsPlayer.button.addEventListener('click', function buttonClicked(event){
		//                         event.preventDefault();
		//                         jsPlayer.playClicked();
		//                     }, true);
		//                 }
		//                 if (jsPlayer.prev) {
		//                     jsPlayer.prev.addEventListener('click', function prevClicked(event){
		//                         event.preventDefault();
		//                         if (jsPlayer.idx - 1 > -1) {
		//                             jsPlayer.idx--;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                             if (jsPlayer.playing) {
		//                                 jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//                                 jsPlayer.player.play();
		//                             }
		//                         } else {
		//                             jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                             jsPlayer.playing = false;
		//                             jsPlayer.player.pause();
		//                             jsPlayer.idx = 0;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                         }
		//                     }, true);
		//                 }
		//                 if (jsPlayer.next) {
		//                     jsPlayer.next.addEventListener('click', function nextClicked(event){
		//                         event.preventDefault();
		//                         if (jsPlayer.idx + 1 < jsPlayer.trackCount) {
		//                             jsPlayer.idx++;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                             if (jsPlayer.playing) {
		//                                 jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//                                 jsPlayer.player.play();
		//                             }
		//                         } else {
		//                             jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                             jsPlayer.playing = false;
		//                             jsPlayer.player.pause();
		//                             jsPlayer.idx = 0;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                         }
		//                     }, true);
		//                 }
		//                 if (jsPlayer.seek) {
		//                     jsPlayer.seek.addEventListener('mousedown', function seekClicked(){
		//                         clearTimeout(jsPlayer.seeking);
		//                         jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                         jsPlayer.player.pause();
		//                     }, true);
		//                     jsPlayer.seek.addEventListener('mouseup', function seekReleased(){
		//                         jsPlayer.player.currentTime = jsPlayer.seek.value * jsPlayer.player.duration / 100;
		//                         jsPlayer.updateSeek();
		//                         if (jsPlayer.playing) {
		//                             jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//                             jsPlayer.player.play();
		//                         }
		//                     }, true);
		//                 }
		//                 if (jsPlayer.wrapList) {
		//                     jsPlayer.wrapList.addEventListener('click', function listClicked(event){
		//                         var parent = event.target.parentNode;
		//                         if (parent.parentNode.tagName.toLowerCase() === 'ol') {
		//                             event.preventDefault();
		//                             var len = jsPlayer.playlist.length,
		//                             i;
		//                             for (i = 0; i < len; i++) {
		//                                 if (parent.dataset.idx == i + 1) {
		//                                     jsPlayer.idx = i;
		//                                     jsPlayer.playTrack(jsPlayer.idx);
		//                                     i = len;
		//                                 }
		//                             }
		//                         }
		//                     }, true);
		//                 }
		//                 jsPlayer.setDuration = function setDuration() {
		//                     jsPlayer.duration.innerHTML = jsPlayer.formatTime(jsPlayer.player.duration);
		//                     jsPlayer.current.innerHTML = jsPlayer.formatTime(jsPlayer.player.currentTime);
		//                     jsPlayer.seek.value = jsPlayer.player.currentTime / jsPlayer.player.duration;
		//                 };
		//                 jsPlayer.updateSeek = function updateSeek() {
		//                     jsPlayer.seek.value = 100 * jsPlayer.player.currentTime / jsPlayer.player.duration;
		//                     jsPlayer.current.innerHTML = jsPlayer.formatTime(jsPlayer.player.currentTime);
		//                     if (jsPlayer.playing) {
		//                         jsPlayer.seeking = setTimeout(jsPlayer.updateSeek, 500);
		//                     }
		//                 };
		//                 jsPlayer.formatTime = function formatTime(val) {
		//                     var h = 0, m = 0, s;
		//                     val = parseInt(val, 10);
		//                     if (val > 60 * 60) {
		//                         h = parseInt(val / (60 * 60), 10);
		//                         val -= h * 60 * 60;
		//                     }
		//                     if (val > 60) {
		//                         m = parseInt(val / 60, 10);
		//                         val -= m * 60;
		//                     }
		//                     s = val;
		//                     val = (h > 0)? h + ':' : '';
		//                     val += (m > 0)? ((m < 10 && h > 0)? '0' : '') + m + ':' : '0:';
		//                     val += ((s < 10)? '0' : '') + s;
		//                     return val;
		//                 };
		//             }
		//         }
		//         if (jsPlayer.tracks.length > 0) {
		//             jsPlayer.wrap.className += ' enabled';
		//             jsPlayer.loadTrack(jsPlayer.idx);
		//         }
		jsPlayer.init();
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AudioPlayer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AudioPlayer", $$slots, []);
	$$self.$capture_state = () => ({ jsPlayer });

	$$self.$inject_state = $$props => {
		if ("jsPlayer" in $$props) jsPlayer = $$props.jsPlayer;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [];
}

class AudioPlayer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AudioPlayer",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/playlists.svelte generated by Svelte v3.24.0 */

const file$7 = "src/routes/playlists.svelte";

function create_fragment$7(ctx) {
	let t0;
	let h2;
	let t1;
	let t2;
	let addrandomplaylist;
	let t3;
	let addemptyplaylist;
	let t4;
	let playlistlist;
	let t5;
	let audioplayer;
	let current;
	addrandomplaylist = new AddRandomPlaylist({ $$inline: true });
	addemptyplaylist = new AddEmptyPlaylist({ $$inline: true });
	playlistlist = new PlaylistList({ $$inline: true });
	audioplayer = new AudioPlayer({ $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			h2 = element("h2");
			t1 = text("Playlists");
			t2 = space();
			create_component(addrandomplaylist.$$.fragment);
			t3 = space();
			create_component(addemptyplaylist.$$.fragment);
			t4 = space();
			create_component(playlistlist.$$.fragment);
			t5 = space();
			create_component(audioplayer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-kgurgq\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Playlists");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			claim_component(addrandomplaylist.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(addemptyplaylist.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(playlistlist.$$.fragment, nodes);
			t5 = claim_space(nodes);
			claim_component(audioplayer.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Playlists";
			add_location(h2, file$7, 15, 0, 506);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, h2, anchor);
			append_dev(h2, t1);
			insert_dev(target, t2, anchor);
			mount_component(addrandomplaylist, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(addemptyplaylist, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(playlistlist, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(audioplayer, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(addrandomplaylist.$$.fragment, local);
			transition_in(addemptyplaylist.$$.fragment, local);
			transition_in(playlistlist.$$.fragment, local);
			transition_in(audioplayer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(addrandomplaylist.$$.fragment, local);
			transition_out(addemptyplaylist.$$.fragment, local);
			transition_out(playlistlist.$$.fragment, local);
			transition_out(audioplayer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t2);
			destroy_component(addrandomplaylist, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(addemptyplaylist, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(playlistlist, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(audioplayer, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlists> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Playlists", $$slots, []);

	$$self.$capture_state = () => ({
		AddRandomPlaylist,
		AddEmptyPlaylist,
		PlaylistList,
		AudioPlayer
	});

	return [];
}

class Playlists extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Playlists",
			options,
			id: create_fragment$7.name
		});
	}
}

export default Playlists;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxheWxpc3RzLmI0OWVjNjRiLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QbGF5bGlzdENvbXBzL0FkZFJhbmRvbVBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0Q29tcHMvQWRkRW1wdHlQbGF5bGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QbGF5bGlzdENvbXBzL0RlbGV0ZVBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0Q29tcHMvTG9hZFBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0Q29tcHMvRWRpdFBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0TGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QbGF5bGlzdENvbXBzL0F1ZGlvUGxheWVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHBsYXlsaXN0c3RvcmUsIGFtcHZlbCB9IGZyb20gJy4uL1BsYXllclN0b3JlLmpzJ1xuXG4gICAgbGV0IHJhZHZpc2libGUgPSBmYWxzZTtcbiAgICBsZXQgcmFuZHZpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJhZHZpc2libGUpIHtcbiAgICAgICAgICAgIHJhZHZpc2libGUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFkdmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwbG5hbWU7XG4gICAgbGV0IHBsY291bnQ7XG4gICAgbGV0IHBsYXlsaXN0cztcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVN1Ym1pdChldmVudCkge1xuICAgICAgICByYWR2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHBsbmFtZSA9IGV2ZW50LnRhcmdldC5wbG5hbWUudmFsdWU7XG4gICAgICAgIHBsY291bnQgPSBldmVudC50YXJnZXQucGxjb3VudC52YWx1ZTtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRBZGRSYW5kb21QbGF5bGlzdCgpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cdFxuXHRhc3luYyBmdW5jdGlvbiBnZXRBZGRSYW5kb21QbGF5bGlzdCgpIHtcblx0XHRhd2FpdCBmZXRjaChgJHthbXB2ZWx9L0FkZFJhbmRvbVBsYXlsaXN0P3BsYXlsaXN0bmFtZT0ke3BsbmFtZX0mcGxheWxpc3Rjb3VudD0ke3BsY291bnR9YCwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuXHRcdC50aGVuKHIgPT4gci5qc29uKCkpXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBwbGF5bGlzdHMgPSBkYXRhLnBsaXN0cztcbiAgICAgICAgICAgIHBsYXlsaXN0c3RvcmUuc2V0KHBsYXlsaXN0cylcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHR9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtyYW5kdmlzfSA+QWRkIFJhbmRvbSBQbGF5bGlzdDwvYnV0dG9uPlxuXG57I2lmIHJhZHZpc2libGV9XG4gICAgPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PVwie2hhbmRsZVN1Ym1pdH1cIj5cbiAgICAgICAgPGlucHV0IGlkPVwicGxuYW1lXCIgbmFtZT1cInBsbmFtZVwiIHR5cGU9XCJ0ZXh0XCIgLz5cbiAgICAgICAgPGxhYmVsPlBsYXlsaXN0IE5hbWU8L2xhYmVsPjxiciAvPlxuICAgICAgICA8aW5wdXQgaWQ9XCJwbGNvdW50XCIgbmFtZT1cInBsY291bnRcIiB0eXBlPVwidGV4dFwiIC8+XG4gICAgICAgIDxsYWJlbD5OdW1iZXIgT2YgU29uZ3M8L2xhYmVsPjxiciAvPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIHZhbHVlPVwiQWRkXCIgLz5cbiAgICA8L2Zvcm0+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgZm9ybSB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHRleHQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gICAgaW1wb3J0IHsgcGxheWxpc3RzdG9yZSwgYW1wdmVsIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUuanMnXG5cbiAgICBsZXQgdmlzaWJsZSA9IGZhbHNlO1xuICAgIGxldCBmdWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5ld3BsbmFtZTtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBZGRQbGF5TGlzdE5hbWVUb0RCU3VibWl0KGV2ZW50KSB7XG4gICAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgbmV3cGxuYW1lID0gZXZlbnQudGFyZ2V0LnBsbmFtZS52YWx1ZTtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRBZGRQbGF5TGlzdE5hbWVUb0RCKCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblx0XG5cdGFzeW5jIGZ1bmN0aW9uIGdldEFkZFBsYXlMaXN0TmFtZVRvREIoKSB7XG5cdFx0ZmV0Y2goYCR7YW1wdmVsfS9BZGRQbGF5TGlzdE5hbWVUb0RCP3BsYXlsaXN0bmFtZT0ke25ld3BsbmFtZX1gLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG5cdFx0LnRoZW4ociA9PiByLmpzb24oKSlcblx0XHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGxldCBwbmFtZSA9IGRhdGEucG5hbWVzO1xuICAgICAgICAgICAgcGxheWxpc3RzdG9yZS5zZXQocG5hbWUpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0fVxuXG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja30+QWRkIEVtcHR5IFBsYXlsaXN0PC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZX1cbiAgICA8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ9XCJ7aGFuZGxlQWRkUGxheUxpc3ROYW1lVG9EQlN1Ym1pdH1cIj5cbiAgICAgICAgPGlucHV0IGlkPVwicGxuYW1lXCIgbmFtZT1cInBsbmFtZVwiIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCJcIi8+XG4gICAgICAgIDxsYWJlbD5QbGF5bGlzdCBOYW1lPC9sYWJlbD48YnIgLz5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIkFkZFwiLz5cbiAgICA8L2Zvcm0+XG57L2lmfVxuXG5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgcGxheWxpc3RzdG9yZSwgYW1wdmVsIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUuanMnXG4gICAgZXhwb3J0IGxldCBQTElEO1xuICAgIGxldCBOUEw7XG5cdGFzeW5jIGZ1bmN0aW9uIGdldERlbGV0ZVBsYXlsaXN0RnJvbURCKCkge1xuICAgICAgICBmZXRjaChgJHthbXB2ZWx9L0RlbGV0ZVBsYXlsaXN0RnJvbURCP3BsYXlsaXN0aWQ9JHtQTElEfWAsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBOUEwgPSBkYXRhLm5wbDtcbiAgICAgICAgICAgIHBsYXlsaXN0c3RvcmUuc2V0KE5QTClcbiAgICAgICAgfSlcbiAgICB9XG4gICAgbGV0IGRlbGV0ZUNsaWNrID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldERlbGV0ZVBsYXlsaXN0RnJvbURCKCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gaWQ9XCJkZWxldGVcIiBvbjpjbGljaz17ZGVsZXRlQ2xpY2t9ID5EZWxldGU8L2J1dHRvbj5cblxuPHN0eWxlPlxuXG4gICAgYnV0dG9uI2RlbGV0ZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIHBhZGRpbmc6IDdweDtcbiAgICB9XG5cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBleHBvcnQgbGV0IFBMSUQ7XG4gICAgaW1wb3J0IHthbXB2ZWx9IGZyb20gJy4uL1BsYXllclN0b3JlLmpzJ1xuXG5cdGxldCBTT05HUyA9IFtdO1xuXHRhc3luYyBmdW5jdGlvbiBnZXRDcmVhdGVQbGF5ZXJQbGF5bGlzdCgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgJHthbXB2ZWx9L0NyZWF0ZVBsYXllclBsYXlsaXN0P3BsYXlsaXN0aWQ9JHtQTElEfWBcbiAgICAgICAgY29uc29sZS5sb2coYWRkcilcblx0XHRhd2FpdCBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG5cdFx0LnRoZW4ociA9PiByLmpzb24oKSlcblx0XHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIFNPTkdTID0gZGF0YS5tYWtlUEw7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhTT05HU1swXSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBcbiAgICAvLyBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkU3VibWl0KGV2ZW50KSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZFN1Ym1pdCgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQudGFyZ2V0LlNPTkdTKVxuICAgICAgICAvLyBwbG5hbWUgPSBldmVudC50YXJnZXQucGxuYW1lLnZhbHVlO1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldENyZWF0ZVBsYXllclBsYXlsaXN0KCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInRoaXMgaXMgc29uZ3MgZnJvbSBsb2FkcGxheWxpc3QgcGFnZVwiKVxuICAgICAgICBjb25zb2xlLmxvZyhTT05HUylcbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIGlkPVwicGxheWxpc3RMb2FkQnRuXCIgb246Y2xpY2s9e2hhbmRsZUxvYWRTdWJtaXR9ID5Mb2FkPC9idXR0b24+XG5cbnsjaWYgUExJRCAhPT0gXCJcIn1cbiAgICB7I2VhY2ggU09OR1MgYXMgc31cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxpbWcgc3JjPXtzLnRodW1ibmFpbH0gYWx0PVwiZnVja1wiLz5cbiAgICAgICAgICAgIDxwPntzLmFydGlzdH08L3A+XG4gICAgICAgICAgICA8cD57cy5hbGJ1bX08L3A+XG4gICAgICAgICAgICA8cD57cy5uYW1lfTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgey9lYWNofVxuezplbHNlfVxuICAgIDxwPldob29wcyBubyBQbGF5bGlzdCBzZWxlY3RlZDwvcD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBpbWcge1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIG1hcmdpbi1yaWdodDogNTBweDtcbiAgICB9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgZXhwb3J0IGxldCBQTElEXG4gICAgaW1wb3J0IHthbXB2ZWx9IGZyb20gJy4uL1BsYXllclN0b3JlLmpzJ1xuIFxuICAgIGxldCBoYW5kbGVBbGxQbGF5bGlzdFNvbmdzRnJvbURCU3VibWl0ID0gKCkgPT4ge1xuICAgICAgICBlZGl0dmlzaWJsZSA9IHRydWVcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRBbGxQbGF5bGlzdFNvbmdzRnJvbURCKCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblx0bGV0IHNvbmdsaXN0O1xuICAgIGxldCBzb25nbGlzdF9jb3VudDtcblx0YXN5bmMgZnVuY3Rpb24gZ2V0QWxsUGxheWxpc3RTb25nc0Zyb21EQigpIHtcblx0XHRmZXRjaChgJHthbXB2ZWx9L0FsbFBsYXlsaXN0U29uZ3NGcm9tREI/cGxheWxpc3RpZD0ke1BMSUR9YCwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuXHRcdC50aGVuKHIgPT4gci5qc29uKCkpXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBzb25nbGlzdCA9IGRhdGEudGF6O1xuICAgICAgICAgICAgc29uZ2xpc3RfY291bnQgPSBzb25nbGlzdC5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHR9XG5cbiAgICBsZXQgZWRpdHZpc2libGUgPSB0cnVlO1xuICAgIGxldCBlZHZpID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWRpdHZpc2libGUpIHtcbiAgICAgICAgICAgIGVkaXR2aXNpYmxlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXR2aXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBmb3IgcGxheWxpc3Qgc29uZyByZW1vdmFsXG4gICAgLy8gRGVsZXRlU29uZ0Zyb21QbGF5bGlzdFxuICAgIC8vIGRlbHNvbmdpZFxuICAgIC8vIHBsYXlsaXN0bmFtZVxuICAgIC8vIHJlc3VsdFxuXG48L3NjcmlwdD5cblxuXG48YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVBbGxQbGF5bGlzdFNvbmdzRnJvbURCU3VibWl0fT5FZGl0PC9idXR0b24+XG57I2lmIGVkaXR2aXNpYmxlfVxuICAgIHsjaWYgc29uZ2xpc3RfY291bnQgPiAxfVxuICAgICAgICB7I2VhY2ggc29uZ2xpc3QgYXMgc29uZ31cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxwIGlkPXtzb25nWzFdfT57c29uZ1swXX08YnV0dG9uIGlkPVwicmVtb3ZlQnRuXCI+UmVtb3ZlPC9idXR0b24+PC9wPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICB7L2VhY2h9XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2Vkdml9PkNvbXBsZXRlPC9idXR0b24+XG4gICAgezplbHNlfVxuICAgICAgICA8cD5XaG9vcHMgemVybyBzb25nczwvcD5cbiAgICB7L2lmfVxuey9pZn1cblxuPHN0eWxlPlxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICAgIH1cbiAgICBidXR0b24jcmVtb3ZlQnRuIHtcbiAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgIH1cblxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBEZWxldGVQbGF5bGlzdCBmcm9tICcuL1BsYXlsaXN0Q29tcHMvRGVsZXRlUGxheWxpc3Quc3ZlbHRlJ1xuICAgIGltcG9ydCBMb2FkUGxheWxpc3QgZnJvbSAnLi9QbGF5bGlzdENvbXBzL0xvYWRQbGF5bGlzdC5zdmVsdGUnXG4gICAgaW1wb3J0IEVkaXRQbGF5bGlzdCBmcm9tICcuL1BsYXlsaXN0Q29tcHMvRWRpdFBsYXlsaXN0LnN2ZWx0ZSdcbiAgICBpbXBvcnQgeyBwbGF5bGlzdHN0b3JlLCBwbGF5bGlzdGlkc3RvcmUsIGFtcHZlbH0gZnJvbSAnLi9QbGF5ZXJTdG9yZS5qcydcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcblxuICAgIGxldCBwbGlkID0gXCJcIjtcbiAgICBsZXQgUExOQU1FUztcbiAgICBsZXQgUExDT1VOVCA9IDA7XG5cblx0b25Nb3VudChhc3luYyBmdW5jdGlvbiBnZXRBbGxQbGF5bGlzdHMoKSB7XG5cdFx0ZmV0Y2goYCR7YW1wYWRkcn0vQWxsUGxheWxpc3RzYCwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuXHRcdC50aGVuKHIgPT4gci5qc29uKCkpXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VudCA9IFtdO1xuICAgICAgICAgICAgbGV0IHZvbztcbiAgICAgICAgICAgIGxldCBtb28gPSBkYXRhLnBsbmFtZXMubWFwKChkYSkgPT4ge1xuICAgICAgICAgICAgICAgIHZvbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWxpc3RuYW1lIDogZGFbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0aWQgOiBkYVsxXSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VudC5wdXNoKHZvbylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBQTE5BTUVTID0gY3VudFxuICAgICAgICAgICAgcGxheWxpc3RzdG9yZS5zZXQoUExOQU1FUylcbiAgICAgICAgICAgIHBsYXlsaXN0aWRzdG9yZS5zZXQocGxpZClcbiAgICAgICAgICAgIGlmIChQTE5BTUVTICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIFBMQ09VTlQgPSBQTE5BTUVTLmxlbmd0aFxuICAgICAgICAgICAgfVxuXHRcdH0pXG4gICAgfSlcblxuICAgIGxldCBQUExOQU1FUztcbiAgICBsZXQgUFBMQ09VTlQ7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBwbGF5bGlzdHN0b3JlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIFBMTkFNRVMgPSB1bmRlZmluZWQ7XG4gICAgICAgIFBMQ09VTlQgPSB1bmRlZmluZWQ7XG4gICAgICAgIFBQTE5BTUVTID0gdmFsdWU7XG4gICAgICAgIFBQTENPVU5UID0gUFBMTkFNRVMubGVuZ3RoXG4gICAgfSk7XG4gICAgbGV0IHBsYXlsaXN0aWRzdG9yZV92YWx1ZTtcbiAgICBjb25zdCB1bnN1YnBsaWQgPSBwbGF5bGlzdGlkc3RvcmUuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgcGxheWxpc3RpZHN0b3JlX3ZhbHVlID0gdmFsdWVcbiAgICB9KVxuICAgICAgICAvLyBsZXQgcGxheWxpc3RpZHN0b3JlX3ZhbHVlO1xuPC9zY3JpcHQ+XG5cbjxkaXY+XG4gICAgPHA+Q3VycmVudGx5IHNlbGVjdGVkIHBsYXlsaXN0OiB7cGxpZH08L3A+XG4gICAgPGZvcm0+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICAgIHsjaWYgUExDT1VOVCA+IDF9XG4gICAgICAgICAgICAgICAgeyNlYWNoIFBMTkFNRVMgYXMgcGxufVxuICAgICAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPXtwbG5bMV19PntwbG5bMF19PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBiaW5kOmdyb3VwPXtwbGlkfSBpZD17cGxuWzFdfSBuYW1lPXtwbG5bMV19IHR5cGU9XCJyYWRpb1wiIHZhbHVlPXtwbG5bMV19PlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgIHs6ZWxzZSBpZiBQTENPVU5UIDwgMX1cbiAgICAgICAgICAgICAgICA8cD5XaG9vcHMgbm8gcGxheWxpc3RzIGZvdW5kPC9wPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDwhLS0gPGxhYmVsIGZvcj17UExOQU1FU1swXX0+e1BMTkFNRVNbMF19PC9sYWJlbD4gLS0+XG4gICAgICAgICAgICAgICAgPCEtLSA8aW5wdXQgYmluZDpncm91cD17cGxpZH0gaWQ9e1BMTkFNRVNbXCJwbGF5bGlzdGlkXCJdfSBuYW1lPXtQTE5cInBsYXlsaXN0bmFtZVwiW1wicGxheWxpc3RpZFwiXX0gdHlwZT1cInJhZFwicGxheWxpc3RuYW1lXCJ2YWx1ZT17UExOQU1FU1swXVswXX0+IC0tPlxuICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAgeyNpZiBQUExDT1VOVCA+IDF9XG4gICAgICAgICAgICAgICAgeyNlYWNoIFBQTE5BTUVTIGFzIHBsbn1cbiAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj17cGxuW1wicGxheWxpc3RpZFwiXX0+e3BsbltcInBsYXlsaXN0bmFtZVwiXX08L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGJpbmQ6Z3JvdXA9e3BsaWR9IGlkPXtwbG5bXCJwbGF5bGlzdGlkXCJdfSBuYW1lPSB7cGxuW1wicGxheWxpc3RpZFwiXX0gdHlwZT1cInJhZGlvXCIgdmFsdWU9e3BsbltcInBsYXlsaXN0aWRcIl19PlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgIHs6ZWxzZSBpZiBQUExDT1VOVCA8IDF9XG4gICAgICAgICAgICAgICAgPHA+V2hvb3BzIG5vIHBsYXlsaXN0cyBmb3VuZDwvcD5cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxwPnRoaXMgaXMgcHBsbmFtZXM6IHtQUExOQU1FU1swXVtcInBsYXlsaXN0aWRcIl19PC9wPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e1BQTE5BTUVTWzBdW1wicGxheWxpc3RpZFwiXX0+e1BQTE5BTUVTWzBdW1wicGxheWxpc3RuYW1lXCJdfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0IGJpbmQ6Z3JvdXA9e3BsaWR9IGlkPXtQUExOQU1FU1swXVtcInBsYXlsaXN0aWRcIl19IG5hbWU9e1BQTE5BTUVTWzBdW1wicGxheWxpc3RuYW1lXCJdfSB0eXBlPVwicmFkaW9cIiB2YWx1ZT17UFBMTkFNRVNbMF1bXCJwbGF5bGlzdG5hbWVcIl19PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC91bD5cbiAgICA8L2Zvcm0+XG48L2Rpdj5cblxuPG5hdj5cbiAgICA8TG9hZFBsYXlsaXN0IFBMSUQ9e3BsaWR9IC8+XG4gICAgPERlbGV0ZVBsYXlsaXN0IFBMSUQ9e3BsaWR9Lz5cbiAgICA8RWRpdFBsYXlsaXN0IFBMSUQ9e3BsaWR9IC8+XG4gICAgXG48L25hdj5cblxuPHN0eWxlPlxuICAgIG5hdiB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgfVxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICAvLyAvLyBIVE1MNSBhdWRpbyBwbGF5ZXIgKyBwbGF5bGlzdCBjb250cm9sc1xuICAgIGxldCBqc1BsYXllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wbGF5ZXItd3JhcCcpO1xuICAgIGlmIChqc1BsYXllcikge1xuICAgICAgICBqc1BsYXllciA9IHtcbiAgICAgICAgICAgIHdyYXA6IGpzUGxheWVyLFxuICAgICAgICAgICAgcGxheWVyOiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignYXVkaW8nKSApLFxuICAgIC8vICAgICAgICAgcGxheWVyOiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignYXVkaW8nKSB8fCB7IHBsYXk6IGZ1bmN0aW9uKCl7fSwgcGF1c2U6IGZ1bmN0aW9uKCl7fSB9KSxcblxuICAgIC8vICAgICAgICAgcGxheTogKGpzUGxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5wbGF5JykgfHwge30pLFxuICAgIC8vICAgICAgICAgcGF1c2U6IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcucGF1c2UnKSB8fCB7fSksXG4gICAgLy8gICAgICAgICBzZWVrOiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignLnNlZWsnKSB8fCB7fSksXG4gICAgLy8gICAgICAgICBwcmV2OiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignLnByZXYnKSB8fCB7fSksXG4gICAgICAgICAgICBuZXh0OiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignLm5leHQnKSB8fCB7fSksXG4gICAgLy8gICAgICAgICBidXR0b246IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcuYnV0dG9uJykgfHwgeyBzdHlsZToge30gfSksXG4gICAgLy8gICAgICAgICB3cmFwTGlzdDogKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wbGF5bGlzdC13cmFwJykgfHwge30pLFxuICAgIC8vICAgICAgICAgYWN0aW9uOiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignLmFjdGlvbicpIHx8IHt9KSxcbiAgICAvLyAgICAgICAgIHRpdGxlOiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignLnRpdGxlJykgfHwge30pLFxuICAgIC8vICAgICAgICAgY3VycmVudDogKGpzUGxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5jdXJyZW50JykgfHwge30pLFxuICAgIC8vICAgICAgICAgZHVyYXRpb246IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcuZHVyYXRpb24nKSB8fCB7fSksXG4gICAgICAgICAgICB0cmFja0NvdW50OiAwLFxuICAgIC8vICAgICBzZWVraW5nOiBudWxsLFxuICAgICAgICAgICAgcGxheWluZzogZmFsc2UsXG4gICAgICAgICAgICB0cmFja3M6IFtdLFxuICAgICAgICAgICAgdHJhY2s6IFtdLFxuICAgICAgICAgICAgaWR4OiAwXG4gICAgICAgIH07XG5cbiAgICAvLyAgICAganNQbGF5ZXIucGxheUNsaWNrZWQgPSBmdW5jdGlvbiBqc1BsYXllclBsYXlDbGlja2VkKCl7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5idXR0b24uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIC8vICAgICAgICAganNQbGF5ZXIucGF1c2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5aW5nID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLmFjdGlvbi5pbm5lckhUTUwgPSAnTm93IFBsYXlpbmcmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5ZXIucGxheSgpO1xuICAgIC8vICAgICAgICAganNQbGF5ZXIudXBkYXRlU2VlaygpO1xuICAgIC8vICAgICB9O1xuICAgIC8vICAgICBqc1BsYXllci5wYXVzZUNsaWNrZWQgPSBmdW5jdGlvbiBqc1BsYXllclBhdXNlQ2xpY2tlZCgpe1xuICAgIC8vICAgICAgICAganNQbGF5ZXIucGxheS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBhdXNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgLy8gICAgICAgICBjbGVhclRpbWVvdXQoanNQbGF5ZXIuc2Vla2luZyk7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5aW5nID0gZmFsc2U7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5hY3Rpb24uaW5uZXJIVE1MID0gJ1BhdXNlZCZoZWxsaXA7JztcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBsYXllci5wYXVzZSgpO1xuICAgIC8vICAgICB9O1xuICAgIC8vICAgICBqc1BsYXllci5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBqYVBsYXllckxvYWRQbGF5bGlzdCgpe1xuICAgIC8vICAgICAgICAganNQbGF5ZXIucGxheWxpc3QgPSBqc1BsYXllci53cmFwTGlzdD8ganNQbGF5ZXIud3JhcExpc3QucXVlcnlTZWxlY3RvckFsbCgnb2wgPiBsaScpIDogW107XG4gICAgLy8gICAgICAgICB2YXIgbGVuID0ganNQbGF5ZXIucGxheWxpc3QubGVuZ3RoLFxuICAgIC8vICAgICAgICAgICAgIHRtcCwgaTtcbiAgICAvLyAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vICAgICAgICAgICAgIGlmICghanNQbGF5ZXIucGxheWxpc3RbaV0uZGF0YXNldCkge1xuICAgIC8vICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5bGlzdFtpXS5kYXRhc2V0ID0ge307XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgIHRtcCA9IGpzUGxheWVyLnBsYXlsaXN0W2ldLnF1ZXJ5U2VsZWN0b3IoJ2EnKTtcbiAgICAvLyAgICAgICAgICAgICBpZiAodG1wICYmICFqc1BsYXllci5wbGF5bGlzdFtpXS5kYXRhc2V0LmlkeCkge1xuICAgIC8vICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5bGlzdFtpXS5kYXRhc2V0LmlkeCA9IGkgKyAxO1xuICAgIC8vICAgICAgICAgICAgICAgICBqc1BsYXllci50cmFja0NvdW50Kys7XG4gICAgLy8gICAgICAgICAgICAgICAgIGpzUGxheWVyLnRyYWNrcy5wdXNoKHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIFwiZmlsZVwiOiB0bXAuaHJlZixcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiAodG1wLnRleHRDb250ZW50IHx8IHRtcC5pbm5lclRleHQpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIFwidHJhY2tcIjogaSArIDFcbiAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9O1xuICAgIC8vICAgICBqc1BsYXllci5sb2FkVHJhY2sgPSBmdW5jdGlvbiBqc1BsYXllckxvYWRUcmFjayhpZHgpe1xuICAgIC8vICAgICAgICAgdmFyIGxlbiA9IGpzUGxheWVyLnBsYXlsaXN0Lmxlbmd0aCxcbiAgICAvLyAgICAgICAgICAgICBpO1xuICAgIC8vICAgICAgICAgZm9yIChpPTA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vICAgICAgICAgICAgIGlmIChqc1BsYXllci5wbGF5bGlzdFtpXS5jbGFzc0xpc3QpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGlkeCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheWxpc3RbaV0uY2xhc3NMaXN0LmFkZCgnc2VsJyk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5bGlzdFtpXS5jbGFzc0xpc3QucmVtb3ZlKCdzZWwnKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnRpdGxlLmlubmVySFRNTCA9IGpzUGxheWVyLnRyYWNrc1tpZHhdLm5hbWU7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5ZXIuc3JjID0ganNQbGF5ZXIudHJhY2tzW2lkeF0uZmlsZSArICcubXAzJztcbiAgICAvLyAgICAgfTtcbiAgICAvLyAgICAganNQbGF5ZXIucGxheVRyYWNrID0gZnVuY3Rpb24ganNQbGF5ZXJQbGF5VHJhY2soaWR4KXtcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLmxvYWRUcmFjayhpZHgpO1xuICAgIC8vICAgICAgICAganNQbGF5ZXIucGxheWluZyA9IHRydWU7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5Q2xpY2tlZCgpO1xuICAgIC8vICAgICB9O1xuICAgICAgICBqc1BsYXllci5pbml0ID0gZnVuY3Rpb24ganNQbGF5ZXJJbml0KCl7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSAoanNQbGF5ZXIud3JhcCAmJiBqc1BsYXllci53cmFwLmRhdGFzZXQgJiYganNQbGF5ZXIud3JhcC5kYXRhc2V0LnVybCk/IGpzUGxheWVyLndyYXAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHRtcCwgaTtcbiAgICAvLyAgICAgICAgIGlmICghIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJykuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWcnKSkge1xuICAgIC8vICAgICAgICAgICAgIGlmIChqc1BsYXllci53cmFwTGlzdCAmJiBqc1BsYXllci53cmFwTGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdvbCA+IGxpJykubGVuZ3RoID4gMCkge1xuICAgIC8vICAgICAgICAgICAgICAgICBqc1BsYXllci5sb2FkUGxheWxpc3QoKTtcbiAgICAvLyAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIGpzUGxheWVyLnRyYWNrcyA9IFt7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBcImZpbGVcIjogdHJhY2suZGF0YXNldC51cmwsXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogKHRyYWNrLmRhdGFzZXQudGl0bGUgfHwgJycpLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgXCJ0cmFja1wiOiAxXG4gICAgLy8gICAgICAgICAgICAgICAgIH1dO1xuICAgIC8vICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICBpZiAoanNQbGF5ZXIudHJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLnBsYXllcikge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZnVuY3Rpb24gcGxheWVyRW5kZWQoKXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIuaWR4ICsgMSA8IGpzUGxheWVyLnRyYWNrQ291bnQpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuaWR4Kys7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlUcmFjayhqc1BsYXllci5pZHgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmFjdGlvbi5pbm5lckhUTUwgPSAnUGF1c2VkJmhlbGxpcDsnO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIucGF1c2UoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuaWR4ID0gMDtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIubG9hZFRyYWNrKGpzUGxheWVyLmlkeCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uIHBsYXllckxvYWRlZGRhdGEoKXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5zZXREdXJhdGlvbigpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLnBsYXkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBqc1BsYXllci5wbGF5Q2xpY2tlZCwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLnBhdXNlKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wYXVzZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGpzUGxheWVyLnBhdXNlQ2xpY2tlZCwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLmJ1dHRvbikge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gYnV0dG9uQ2xpY2tlZChldmVudCl7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5Q2xpY2tlZCgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLnByZXYpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnByZXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBwcmV2Q2xpY2tlZChldmVudCl7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIuaWR4IC0gMSA+IC0xKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmlkeC0tO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5sb2FkVHJhY2soanNQbGF5ZXIuaWR4KTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLnBsYXlpbmcpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmFjdGlvbi5pbm5lckhUTUwgPSAnTm93IFBsYXlpbmcmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIucGxheSgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuYWN0aW9uLmlubmVySFRNTCA9ICdQYXVzZWQmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheWVyLnBhdXNlKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmlkeCA9IDA7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmxvYWRUcmFjayhqc1BsYXllci5pZHgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgIGlmIChqc1BsYXllci5uZXh0KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5uZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gbmV4dENsaWNrZWQoZXZlbnQpe1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLmlkeCArIDEgPCBqc1BsYXllci50cmFja0NvdW50KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmlkeCsrO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5sb2FkVHJhY2soanNQbGF5ZXIuaWR4KTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLnBsYXlpbmcpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmFjdGlvbi5pbm5lckhUTUwgPSAnTm93IFBsYXlpbmcmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIucGxheSgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuYWN0aW9uLmlubmVySFRNTCA9ICdQYXVzZWQmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheWVyLnBhdXNlKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmlkeCA9IDA7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmxvYWRUcmFjayhqc1BsYXllci5pZHgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgIGlmIChqc1BsYXllci5zZWVrKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5zZWVrLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uIHNlZWtDbGlja2VkKCl7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGpzUGxheWVyLnNlZWtpbmcpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmFjdGlvbi5pbm5lckhUTUwgPSAnUGF1c2VkJmhlbGxpcDsnO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXllci5wYXVzZSgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5zZWVrLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbiBzZWVrUmVsZWFzZWQoKXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIuY3VycmVudFRpbWUgPSBqc1BsYXllci5zZWVrLnZhbHVlICoganNQbGF5ZXIucGxheWVyLmR1cmF0aW9uIC8gMTAwO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnVwZGF0ZVNlZWsoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucGxheWluZykge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5hY3Rpb24uaW5uZXJIVE1MID0gJ05vdyBQbGF5aW5nJmhlbGxpcDsnO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIucGxheSgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgIGlmIChqc1BsYXllci53cmFwTGlzdCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIud3JhcExpc3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBsaXN0Q2xpY2tlZChldmVudCl7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbCcpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGpzUGxheWVyLnBsYXlsaXN0Lmxlbmd0aCxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmRhdGFzZXQuaWR4ID09IGkgKyAxKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuaWR4ID0gaTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5VHJhY2soanNQbGF5ZXIuaWR4KTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbGVuO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAganNQbGF5ZXIuc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBzZXREdXJhdGlvbigpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmR1cmF0aW9uLmlubmVySFRNTCA9IGpzUGxheWVyLmZvcm1hdFRpbWUoanNQbGF5ZXIucGxheWVyLmR1cmF0aW9uKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmN1cnJlbnQuaW5uZXJIVE1MID0ganNQbGF5ZXIuZm9ybWF0VGltZShqc1BsYXllci5wbGF5ZXIuY3VycmVudFRpbWUpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuc2Vlay52YWx1ZSA9IGpzUGxheWVyLnBsYXllci5jdXJyZW50VGltZSAvIGpzUGxheWVyLnBsYXllci5kdXJhdGlvbjtcbiAgICAvLyAgICAgICAgICAgICAgICAgfTtcbiAgICAvLyAgICAgICAgICAgICAgICAganNQbGF5ZXIudXBkYXRlU2VlayA9IGZ1bmN0aW9uIHVwZGF0ZVNlZWsoKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5zZWVrLnZhbHVlID0gMTAwICoganNQbGF5ZXIucGxheWVyLmN1cnJlbnRUaW1lIC8ganNQbGF5ZXIucGxheWVyLmR1cmF0aW9uO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuY3VycmVudC5pbm5lckhUTUwgPSBqc1BsYXllci5mb3JtYXRUaW1lKGpzUGxheWVyLnBsYXllci5jdXJyZW50VGltZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucGxheWluZykge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnNlZWtpbmcgPSBzZXRUaW1lb3V0KGpzUGxheWVyLnVwZGF0ZVNlZWssIDUwMCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgIH07XG4gICAgLy8gICAgICAgICAgICAgICAgIGpzUGxheWVyLmZvcm1hdFRpbWUgPSBmdW5jdGlvbiBmb3JtYXRUaW1lKHZhbCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSAwLCBtID0gMCwgcztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KHZhbCwgMTApO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IDYwICogNjApIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBoID0gcGFyc2VJbnQodmFsIC8gKDYwICogNjApLCAxMCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFsIC09IGggKiA2MCAqIDYwO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IDYwKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHBhcnNlSW50KHZhbCAvIDYwLCAxMCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFsIC09IG0gKiA2MDtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHMgPSB2YWw7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWwgPSAoaCA+IDApPyBoICsgJzonIDogJyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWwgKz0gKG0gPiAwKT8gKChtIDwgMTAgJiYgaCA+IDApPyAnMCcgOiAnJykgKyBtICsgJzonIDogJzA6JztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHZhbCArPSAoKHMgPCAxMCk/ICcwJyA6ICcnKSArIHM7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIC8vICAgICAgICAgICAgICAgICB9O1xuICAgIC8vICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIGlmIChqc1BsYXllci50cmFja3MubGVuZ3RoID4gMCkge1xuICAgIC8vICAgICAgICAgICAgIGpzUGxheWVyLndyYXAuY2xhc3NOYW1lICs9ICcgZW5hYmxlZCc7XG4gICAgLy8gICAgICAgICAgICAganNQbGF5ZXIubG9hZFRyYWNrKGpzUGxheWVyLmlkeCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGpzUGxheWVyLmluaXQoKTtcbiAgICB9XG5cbjwvc2NyaXB0PlxuXG5cblxuPCEtLSA8ZGl2IGNsYXNzPVwicGFnZVwiPiAtLT5cbiAgICA8IS0tIDxhdWRpbyBzcmM9XCJib28xLm1wM1wiIGNvbnRyb2xzID48L2F1ZGlvPiAtLT5cblx0PCEtLSA8ZGl2IGNsYXNzPVwicGxheWVyLXdyYXBcIiBkYXRhLXVybD1cIlwiIGRhdGEtdGl0bGU9XCJCb28xXCI+XG4gICAgICAgICAgICA8YXVkaW8gY29udHJvbHMgPjwvYXVkaW8+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uXCI+UGxheTwvZGl2PlxuXG4gICAgICAgIFxuICAgIDwvZGl2PiAtLT5cbiAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwiaW5mb1wiPiAtLT5cbiAgICAgICAgICAgIDwhLS0gPGgxPkFsYnVtOiBNeXRoaXVtPC9oMT4gLS0+XG4gICAgICAgICAgICA8IS0tIDxwIGNsYXNzPVwiYWN0aW9uXCI+Jm5ic3A7PC9wPlxuICAgICAgICAgICAgPHAgY2xhc3M9XCJ0aXRsZSBlbGxpcHNpc1wiPjwvcD4gLS0+XG5cbiAgICAgICAgICAgIDwhLS0gPGF1ZGlvIHNyYz1cIlwiIGNvbnRyb2xzID48L2F1ZGlvPiAtLT5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwicGxheWVyXCI+XG4gICAgICAgICAgICAgICAgPGF1ZGlvIHByZWxvYWQgY29udHJvbHMgPjwvYXVkaW8+IC0tPlxuICAgICAgICAgICAgICAgIDwhLS0gPGRpdiBjbGFzcz1cInBsYXlwYXVzZVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGxheVwiPjxzdmcgdmlld0JveD1cIjAgMCAyIDJcIj48cGF0aCBkPVwiTTAsMCBMMCwxNCBMMTEsNyBMMCwwIFpcIi8+PC9zdmc+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYXVzZVwiPjxzdmcgdmlld0JveD1cIjAgMCAxNCAxNFwiPjxwYXRoIGQ9XCJNMCwxNCBMNCwxNCBMNCwwIEwwLDAgTDAsMTQgTDAsMTQgWiBNOCwwIEw4LDE0IEwxMiwxNCBMMTIsMCBMOCwwIEw4LDAgWlwiLz48L3N2Zz48L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gLS0+XG4gICAgICAgICAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwidGltZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImN1cnJlbnRcIj4wOjAwOjAwPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+LzwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHVyYXRpb25cIj4wOjAwOjAwPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+IC0tPlxuICAgICAgICAgICAgICAgIDwhLS0gPGRpdj48aW5wdXQgdHlwZT1cInJhbmdlXCIgbWluPVwiMFwiIG1heD1cIjEwMFwiIHN0ZXA9XCIuMVwiIHZhbHVlPVwiMFwiIGNsYXNzPVwic2Vla1wiPjwvZGl2PiAtLT5cbiAgICAgICAgICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XCJwcmV2XCI+PHN2ZyB2aWV3Qm94PVwiMCAwIDEyIDEyXCI+PHBhdGggZD1cIk0zLjUsNiBMMTIsMTIgTDEyLDAgTDMuNSw2IFogTTAsMCBMMCwxMiBMMiwxMiBMMiwwIEwwLDAgTDAsMCBaXCIvPjwvc3ZnPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZXh0XCI+PHN2ZyB2aWV3Qm94PVwiMCAwIDEyIDEyXCI+PHBhdGggZD1cIk0wLDEyIEw4LjUsNiBMMCwwIEwwLDEyIEwwLDEyIFogTTEwLDAgTDEwLDEyIEwxMiwxMiBMMTIsMCBMMTAsMCBMMTAsMCBaXCIvPjwvc3ZnPjwvZGl2PiAtLT5cbiAgICAgICAgICAgIDwhLS0gPC9kaXY+IC0tPlxuICAgICAgICA8IS0tIDwvZGl2PiAtLT5cbiAgICA8IS0tIDwvZGl2PiAtLT5cblxuPGRpdiBjbGFzcz1cInBsYXllci13cmFwXCIgZGF0YS11cmw9XCJib28xLm1wM1wiIGRhdGEtdGl0bGU9XCJCb28xXCIgPlxuICAgIDxhdWRpbyBzcmM9XCJcIiBjb250cm9scyA+PC9hdWRpbz5cbjwvZGl2PlxuXG5cbjxkaXY+XG5cdDxkaXYgY2xhc3M9XCJwbGF5bGlzdC13cmFwXCI+XG5cdFx0PG9sPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCJib28xLm1wM1wiPkJvbzE8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiYm9vMi5tcDNcIj5Cb28yPC9hPjwvbGk+XG5cdFx0XHQ8IS0tIDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL0JTX0FUS01cIj5BbGwgVGhlIEtpbmcncyBNZW4gLSBCcm9hZHdpbmcgU3R1ZGlvIChGaW5hbCBNaXgpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9CU0ZNX1RGXCI+VGhlIEZvcnNha2VuIC0gQnJvYWR3aW5nIFN0dWRpbyAoRmlyc3QgTWl4KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vQlNGTV9BVEtNXCI+QWxsIFRoZSBLaW5nJ3MgTWVuIC0gQnJvYWR3aW5nIFN0dWRpbyAoRmlyc3QgTWl4KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vQUNfQVRJXCI+QWxsIFRoaXMgSXMgLSBBbHRlcm5hdGUgQ3V0czwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vQUNfQVRLTVRha2VfMVwiPkFsbCBUaGUgS2luZydzIE1lbiAoVGFrZSAxKSAtIEFsdGVybmF0ZSBDdXRzPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9BQ19BVEtNVGFrZV8yXCI+QWxsIFRoZSBLaW5nJ3MgTWVuIChUYWtlIDIpIC0gQWx0ZXJuYXRlIEN1dHM8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL0FDX01cIj5NYWd1cyAtIEFsdGVybmF0ZSBDdXRzPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9BQ19UU09XQWZ1Y2tlZF91cFwiPlRoZSBTdGF0ZSBPZiBXZWFyaW5nIEFkZHJlc3MgKGZ1Y2tlZCB1cCkgLSBBbHRlcm5hdGUgQ3V0czwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vUE5ZMDQtMDVfTVwiPk1hZ3VzIC0gUG9wZXllJ3MgKE5ldyBZZWFycyAnMDQgLSAnMDUpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9QTlkwNC0wNV9PVFdcIj5PbiBUaGUgV2F0ZXJmcm9udCAtIFBvcGV5ZSdzIChOZXcgWWVhcnMgJzA0IC0gJzA1KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vUE5ZMDQtMDVfVFwiPlRyYW5jZSAtIFBvcGV5ZSdzIChOZXcgWWVhcnMgJzA0IC0gJzA1KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vUE5ZMDQtMDVfVEZcIj5UaGUgRm9yc2FrZW4gLSBQb3BleWUncyAoTmV3IFllYXJzICcwNCAtICcwNSk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1BOWTA0LTA1X1RTT1dBXCI+VGhlIFN0YXRlIE9mIFdlYXJpbmcgQWRkcmVzcyAtIFBvcGV5ZSdzIChOZXcgWWVhcnMgJzA0IC0gJzA1KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vUFZEX01cIj5NYWd1cyAtIFBvcGV5ZSdzIChWYWxlbnRpbmUncyBEYXkgJzA1KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vUFZEX1RcIj5UcmFuY2UgLSBQb3BleWUncyAoVmFsZW50aW5lJ3MgRGF5ICcwNSk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1BWRF9UU09XQVwiPlRoZSBTdGF0ZSBPZiBXZWFyaW5nIEFkZHJlc3MgLSBQb3BleWUncyAoVmFsZW50aW5lJ3MgRGF5ICcwNSk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjAxXzA4XzA0X0FUSVwiPkFsbCBUaGlzIElzIC0gU21pdGggU3QuIEJhc2VtZW50ICgwMS8wOC8wNCk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjAxXzA4XzA0X01cIj5NYWd1cyAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMDEvMDgvMDQpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0IwNl8wNl8wM19CVFBFXCI+QmVuZWF0aCBUaGUgUGFpbnRlZCBFeWUgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKDA2LzA2LzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMDZfMDZfMDNfSVwiPklubm9jZW5jZSAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMDYvMDYvMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0IwNl8wNl8wM19NXCI+TWFndXMgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKDA2LzA2LzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMDZfMDZfMDNfTUVcIj5NYWRuZXNzIEV4cGxvcmVkIC0gU21pdGggU3QuIEJhc2VtZW50ICgwNi8wNi8wMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjA2XzA2XzAzX1RGXCI+VGhlIEZvcnNha2VuIC0gU21pdGggU3QuIEJhc2VtZW50ICgwNi8wNi8wMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjEyXzI4XzAzX0FUSVwiPkFsbCBUaGlzIElzIC0gU21pdGggU3QuIEJhc2VtZW50ICgxMi8yOC8wMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjEyXzI4XzAzX01cIj5NYWd1cyAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMTIvMjgvMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0IxMl8yOF8wM19NRVwiPk1hZG5lc3MgRXhwbG9yZWQgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKDEyLzI4LzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMTJfMjhfMDNfVFwiPlRyYW5jZSAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMTIvMjgvMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0IxMl8yOF8wM19URlwiPlRoZSBGb3JzYWtlbiAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMTIvMjgvMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0JfX18xMV8wM19BVElUYWtlXzFcIj5BbGwgVGhpcyBJcyAoVGFrZSAxKSAtIFNtaXRoIFN0LiBCYXNlbWVudCAoTm92LiAnMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0JfX18xMV8wM19BVElUYWtlXzJcIj5BbGwgVGhpcyBJcyAoVGFrZSAyKSAtIFNtaXRoIFN0LiBCYXNlbWVudCAoTm92LiAnMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0JfX18xMV8wM19CVFBFVGFrZV8xXCI+QmVuZWF0aCBUaGUgUGFpbnRlZCBFeWUgKFRha2UgMSkgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKE5vdi4gJzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCX19fMTFfMDNfQlRQRVRha2VfMlwiPkJlbmVhdGggVGhlIFBhaW50ZWQgRXllIChUYWtlIDIpIC0gU21pdGggU3QuIEJhc2VtZW50IChOb3YuICcwMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQl9fXzExXzAzX1RGVGFrZV8xXCI+VGhlIEZvcnNha2VuIChUYWtlIDEpIC0gU21pdGggU3QuIEJhc2VtZW50IChOb3YuICcwMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQl9fXzExXzAzX1RGVGFrZV8yXCI+VGhlIEZvcnNha2VuIChUYWtlIDIpIC0gU21pdGggU3QuIEJhc2VtZW50IChOb3YuICcwMyk8L2E+PC9saT4gLS0+XG5cdFx0PC9vbD5cblx0PC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAgIC8qID4+IHJlc2V0ICovXG4gICAgLyogaHRtbCwgYm9keSwgZGl2LCBzcGFuLCBoMSwgcCwgYSwgb2wsIGxpLCBhdWRpbyB7XG4gICAgICAgIGJvcmRlcjogMDtcbiAgICAgICAgZm9udDogaW5oZXJpdDtcbiAgICAgICAgZm9udC1zaXplOiAxMDAlO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbiAgICB9ICovXG4gICAgb2wge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgfVxuICAgIG9sIGxpIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBsaXN0LXN0eWxlOiBkZWNpbWFsIG91dHNpZGU7XG4gICAgfVxuICAgICoge1xuICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7XG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgfVxuICAgIC8qIGh0bWwsIGJvZHkge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9ICovXG4gICAgLyogYm9keSB7XG4gICAgICAgIHBhZGRpbmc6IDVweCAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiAjMTExIG5vbmU7XG4gICAgICAgIGZvbnQ6IDIwcHgvMjRweCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZjtcbiAgICAgICAgY29sb3I6ICNlZWU7XG4gICAgfSAqL1xuICAgIC8qIGEsIGE6Zm9jdXMsIGE6YWN0aXZlLCBhOmhvdmVyLCBhOnZpc2l0ZWQge1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgfVxuICAgIGFbaHJlZl0sIGFbaHJlZl06YWN0aXZlLCBhW2hyZWZdOnZpc2l0ZWQge1xuICAgICAgICBjb2xvcjogI2RkZDtcbiAgICAgICAgb3V0bGluZTogMCBub25lO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG4gICAgYVtocmVmXTpob3ZlciwgYVtocmVmXTpmb2N1cyB7XG4gICAgICAgIGNvbG9yOiAjYmJiO1xuICAgIH0gKi9cbiAgICAvKiA8PCByZXNldCAqL1xuXG4gICAgLyogcGFnZSBzdHlsZSAqL1xuICAgIC8qIC5wYWdlIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW46IDAgYXV0bztcbiAgICAgICAgd2lkdGg6IDcwJTtcbiAgICAgICAgbWluLXdpZHRoOiAzMDBweDtcbiAgICAgICAgbWF4LXdpZHRoOiA3MDBweDtcbiAgICB9ICovXG4gICAgLyogLmVsbGlwc2lzIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgfSAqL1xuXG4gICAgLyogQXVkaW8gUGxheWVyICovXG4gICAgLnBsYXllci13cmFwIHtcbiAgICAgICAgLyogcG9zaXRpb246IHJlbGF0aXZlOyAqL1xuICAgICAgICBtYXJnaW46IDAgMCAxZW07XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICAvKiBiYWNrZ3JvdW5kLWNvbG9yOiAjMjIyOyAqL1xuICAgIH1cbiAgICAvKiAucGxheWVyLXdyYXAuZW5hYmxlZCB7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA0ZW07XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCAuYnV0dG9uIHtcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMS41ZW0gMmVtO1xuICAgICAgICB3aWR0aDogNWVtO1xuICAgICAgICBoZWlnaHQ6IDVlbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcHVycGxlO1xuICAgICAgICBsaW5lLWhlaWdodDogNWVtO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDI1JTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgIH0gKi9cbiAgICAvKiAucGxheWVyLXdyYXAgLmJ1dHRvbjpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcHVycGxlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcC5lbmFibGVkIC5idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5pbmZvIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDEwZW07XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCBoMSB7XG4gICAgICAgIHBhZGRpbmc6IDEuNWVtIDA7XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCAuYWN0aW9uIHtcbiAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgIH0gKi9cbiAgICAvKiAucGxheWVyLXdyYXAgLnBsYXllciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIHBhZGRpbmc6IDAgMWVtIDAgNmVtO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAuZW5hYmxlZCAucGxheWVyIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCAucGxheWVyIHN2ZyB7XG4gICAgICAgIG1hcmdpbjogLjI1ZW07XG4gICAgICAgIHdpZHRoOiAuNWVtO1xuICAgICAgICBoZWlnaHQ6IC41ZW07XG4gICAgICAgIGZpbGw6IGN1cnJlbnRDb2xvcjtcbiAgICB9ICovXG4gICAgLyogLnBsYXllci13cmFwIC5wbGF5ZXIgZGl2IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIGhlaWdodDogMWVtO1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgYXVkaW8sXG4gICAgLnBsYXllci13cmFwIC5wbGF5ZXIgLnBhdXNlIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5wbGF5cGF1c2UsIC5wbGF5ZXItd3JhcCAudGltZXIsXG4gICAgLnBsYXllci13cmFwIC5wcmV2LCAucGxheWVyLXdyYXAgLm5leHQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIGhlaWdodDogMWVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMWVtO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfSAqL1xuICAgIC8qIC5wbGF5ZXItd3JhcCAucGxheXBhdXNlLFxuICAgIC5wbGF5ZXItd3JhcCAucHJldiwgLnBsYXllci13cmFwIC5uZXh0IHtcbiAgICAgICAgd2lkdGg6IDFlbTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgLnBsYXlwYXVzZSB7XG4gICAgICAgIGxlZnQ6IDFlbTtcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5uZXh0IHtcbiAgICAgICAgbGVmdDogYXV0bztcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCAucGxheXBhdXNlOmhvdmVyLFxuICAgIC5wbGF5ZXItd3JhcCAucHJldjpob3ZlciwgLnBsYXllci13cmFwIC5uZXh0OmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzQ0NDtcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5wbGF5cGF1c2UsIC5wbGF5ZXItd3JhcCAucGxheSwgLnBsYXllci13cmFwIC5wYXVzZSxcbiAgICAucGxheWVyLXdyYXAgLnByZXY6Oi1tb3otZm9jdXMtaW5uZXIsXG4gICAgLnBsYXllci13cmFwIC5uZXh0OjotbW96LWZvY3VzLWlubmVyIHtcbiAgICAgICAgYm9yZGVyOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH0gKi9cbiAgICAvKiAucGxheWVyLXdyYXAgLnRpbWVyIHtcbiAgICAgICAgbGVmdDogMmVtO1xuICAgICAgICB3aWR0aDogNGVtO1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgLnRpbWVyIGRpdiB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICBmb250LXNpemU6IC40NWVtO1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgLnNlZWsge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH0gKi9cbiAgICAucGxheWxpc3Qtd3JhcCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyMjI7XG4gICAgfVxuICAgIC5wbGF5bGlzdC13cmFwIGxpIHtcbiAgICAgICAgbWFyZ2luOiAwIDAgMCAzZW07XG4gICAgICAgIHBhZGRpbmc6IC4yNWVtIDAgLjI1ZW0gLjVlbTtcbiAgICAgICAgbGlzdC1zdHlsZTogZGVjaW1hbCBvdXRzaWRlO1xuICAgIH1cbiAgICAvKiAucGxheWxpc3Qtd3JhcCBsaS5zZWwge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgIH1cbiAgICAucGxheWxpc3Qtd3JhcCBsaTpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICM0NDQ7XG4gICAgfSAqL1xuXG4gICAgLyogPj4gaW5wdXRbdHlwZT1yYW5nZV0gY2xhc3M6IHNlZWsgKi9cbiAgICAvKiBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTpmb2N1cyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgfVxuICAgIGlucHV0LnNlZWtbdHlwZT1yYW5nZV06Oi13ZWJraXQtc2xpZGVyLXJ1bm5hYmxlLXRyYWNrIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgd2lkdGg6IDk4JTtcbiAgICAgICAgaGVpZ2h0OiAuMTdlbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAuMWVtO1xuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjJzIGVhc2U7XG4gICAgfVxuICAgIGlucHV0LnNlZWtbdHlwZT1yYW5nZV06Oi13ZWJraXQtc2xpZGVyLXRodW1iIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgd2lkdGg6IC4xN2VtO1xuICAgICAgICBoZWlnaHQ6IC43ZW07XG4gICAgICAgIG1hcmdpbi10b3A6IC0uMjdlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogLjFlbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgfVxuICAgIGlucHV0LnNlZWtbdHlwZT1yYW5nZV06Zm9jdXM6Oi13ZWJraXQtc2xpZGVyLXJ1bm5hYmxlLXRyYWNrIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTo6LW1vei1yYW5nZS10cmFjayB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlcjogMCBzb2xpZCAjZWVlO1xuICAgICAgICB3aWR0aDogOTglO1xuICAgICAgICBoZWlnaHQ6IC4xN2VtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IC4xZW07XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAuMnMgZWFzZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTo6LW1vei1yYW5nZS10aHVtYiB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlcjogMCBzb2xpZCAjZWVlO1xuICAgICAgICB3aWR0aDogLjE3ZW07XG4gICAgICAgIGhlaWdodDogLjdlbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAuMWVtO1xuICAgIH1cbiAgICBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdOjotbXMtdHJhY2sge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBib3JkZXI6IDAgbm9uZTtcbiAgICAgICAgd2lkdGg6IDk4JTtcbiAgICAgICAgaGVpZ2h0OiAuMTdlbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjJzIGVhc2U7XG4gICAgfVxuICAgIGlucHV0LnNlZWtbdHlwZT1yYW5nZV06Oi1tcy1maWxsLWxvd2VyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogLjFlbTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTo6LW1zLWZpbGwtdXBwZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAuMWVtO1xuICAgIH1cbiAgICBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdOjotbXMtdGh1bWIge1xuICAgICAgICBtYXJnaW4tdG9wOiAtLjAxZW07XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIHdpZHRoOiAuMTdlbTtcbiAgICAgICAgaGVpZ2h0OiAuN2VtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IC4xZW07XG4gICAgfVxuICAgIGlucHV0LnNlZWtbdHlwZT1yYW5nZV06Zm9jdXM6Oi1tcy1maWxsLWxvd2VyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTpmb2N1czo6LW1zLWZpbGwtdXBwZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgIH0gKi9cbiAgICAvKiA8PCBpbnB1dFt0eXBlPXJhbmdlXSBjbGFzczogc2VlayAqL1xuXG48L3N0eWxlPiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBFQXFDcUMsR0FBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUQ1QyxHQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzREFGRyxHQUFPOzs7OztzQkFFcEIsR0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWpDUCxVQUFVLEdBQUcsS0FBSzs7S0FDbEIsT0FBTztNQUNILFVBQVU7bUJBQ1YsVUFBVSxHQUFHLEtBQUs7O21CQUVsQixVQUFVLEdBQUcsSUFBSTs7OztLQUlyQixNQUFNO0tBQ04sT0FBTztLQUNQLFNBQVM7O2dCQUVFLFlBQVksQ0FBQyxLQUFLO2tCQUM3QixVQUFVLEdBQUcsS0FBSztFQUNsQixNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSztFQUNsQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSztNQUNoQyxPQUFPLEdBQUcsb0JBQW9CLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUc7OztnQkFHekQsb0JBQW9CO1FBQzVCLEtBQUssSUFBSSxNQUFNLG1DQUFtQyxNQUFNLGtCQUFrQixPQUFPLE1BQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxJQUN0SCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQ2hCLElB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QUFLO2tCQUNoQixRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU07OztLQUUxQixxQkFBcUI7O09BQ25CLFNBQVMsR0FBRyxlQUFlLENBQUMsU0FBUyxDQUFDLEtBQUs7RUFDN0MscUJBQXFCLEdBQUcsS0FBSzs7Ozs7Ozs7Ozs7Ozs7RUFhTSxJQUFJOzs7OztFQWNKLElBQUk7Ozs7O0VBUVosSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0M1RS9CLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGNBQWM7O0tBQ2hELFFBQVE7RUFDUixRQUFRO0dBQ0osSUFBSSxFQUFFLFFBQVE7R0FDZCxNQUFNLEVBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPOzs7Ozs7R0FPdkMsSUFBSSxFQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTzs7Ozs7OztHQU9yQyxVQUFVLEVBQUUsQ0FBQzs7R0FFYixPQUFPLEVBQUUsS0FBSztHQUNkLE1BQU07R0FDTixLQUFLO0dBQ0wsR0FBRyxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTREVixRQUFRLENBQUMsSUFBSSxZQUFZLFlBQVk7T0FDN0IsS0FBSyxHQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRztNQUFHLFFBQVEsQ0FBQyxJQUFJO01BQUcsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFtSjNHLFFBQVEsQ0FBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
