import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, v as validate_slots, U as TVlocalplayURL, e as element, t as text, p as space, c as claim_element, a as children, b as claim_text, f as detach_dev, q as claim_space, j as add_location, h as attr_dev, k as insert_dev, l as append_dev, m as listen_dev, r as run_all, B as validate_each_argument, A as empty, C as destroy_each, O as is_function, w as set_data_dev, n as noop, o as onMount, V as set_store_value, E as create_component, F as claim_component, G as mount_component, H as transition_in, I as transition_out, J as destroy_component, u as query_selector_all, P as check_outros, Q as group_outros } from './client.f90ee688.js';
import { C as Controls } from './Controls.c9e3f9f6.js';

/* src/components/TVComps/Discovery.svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;
const file = "src/components/TVComps/Discovery.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleDis}
function create_if_block(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file, 73, 8, 2015);
			add_location(button1, file, 74, 8, 2071);
			add_location(nav, file, 72, 4, 2001);
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file, 76, 4, 2134);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleDiscovery1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleDiscovery2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(72:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (78:8) {#if showlistcount > 0}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShow*/ 65) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(78:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each showlist as sshow }
function create_each_block(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file, 80, 20, 2251);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file, 81, 20, 2349);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file, 79, 16, 2226);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(79:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Discovery");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Discovery");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file, 69, 0, 1933);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	console.log("this is y");
	console.log(y);
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	// onMount(
	async function getDiscovery(x) {
		let addr = `http://192.168.0.42:8888/intDiscovery?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	//)
	let handleDiscovery1 = () => {
		let promise = getDiscovery(`01`).catch(err => console.log(err));
	};

	let handleDiscovery2 = () => {
		let promise = getDiscovery(`02`).catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + "/" + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Discovery> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Discovery", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getDiscovery,
		handleDiscovery1,
		handleDiscovery2,
		fuckDis,
		getPlayMedia,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleDiscovery1" in $$props) $$invalidate(3, handleDiscovery1 = $$props.handleDiscovery1);
		if ("handleDiscovery2" in $$props) $$invalidate(4, handleDiscovery2 = $$props.handleDiscovery2);
		if ("fuckDis" in $$props) $$invalidate(5, fuckDis = $$props.fuckDis);
		if ("handlePlayShow" in $$props) $$invalidate(6, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleDiscovery1,
		handleDiscovery2,
		fuckDis,
		handlePlayShow,
		LP
	];
}

class Discovery extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Discovery",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1.warn("<Discovery> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Discovery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Discovery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Enterprise.svelte generated by Svelte v3.24.0 */

const { console: console_1$1 } = globals;
const file$1 = "src/components/TVComps/Enterprise.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleEnt}
function create_if_block$1(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*Entshowlistcount*/ ctx[1] > 0 && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$1, 73, 8, 2108);
			add_location(button1, file$1, 74, 8, 2165);
			add_location(button2, file$1, 75, 8, 2222);
			add_location(button3, file$1, 76, 8, 2279);
			add_location(nav, file$1, 72, 4, 2094);
			attr_dev(ul, "class", "svelte-13j0val");
			add_location(ul, file$1, 79, 4, 2344);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleEnterprise1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleEnterprise2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleEnterprise3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleEnterprise4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*Entshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(72:0) {#if visibleEnt}",
		ctx
	});

	return block;
}

// (81:8) {#if Entshowlistcount > 0}
function create_if_block_1$1(ctx) {
	let each_1_anchor;
	let each_value = /*Entshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Entshowlist, handlePlayShow*/ 257) {
				each_value = /*Entshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(81:8) {#if Entshowlistcount > 0}",
		ctx
	});

	return block;
}

// (82:12) {#each Entshowlist as sshow }
function create_each_block$1(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-13j0val");
			add_location(a, file$1, 83, 20, 2467);
			attr_dev(span, "class", "svelte-13j0val");
			add_location(span, file$1, 84, 20, 2565);
			attr_dev(li, "class", "svelte-13j0val");
			add_location(li, file$1, 82, 16, 2442);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].tvfspath))) /*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*Entshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*Entshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(82:12) {#each Entshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleEnt*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Enterprise");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Enterprise");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$1, 69, 0, 2024);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckEnt*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleEnt*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$1(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$1($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let Entshowlist;
	let Entshowlistcount;
	let visibleEnt = false;

	async function getEnterprise(x) {
		let addr = `http://192.168.0.42:8888/intEnterprise?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, Entshowlist = data);
			$$invalidate(1, Entshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleEnterprise1 = () => {
		let promise = getEnterprise(`01`).catch(err => console.log(err));
	};

	let handleEnterprise2 = () => {
		let promise = getEnterprise(`02`).catch(err => console.log(err));
	};

	let handleEnterprise3 = () => {
		let promise = getEnterprise(`03`).catch(err => console.log(err));
	};

	let handleEnterprise4 = () => {
		let promise = getEnterprise(`04`).catch(err => console.log(err));
	};

	let fuckEnt = () => {
		if (visibleEnt) {
			$$invalidate(2, visibleEnt = false);
		} else {
			$$invalidate(2, visibleEnt = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log("this is media");
			console.log(media);

			// let foo = media.split("TVShows", 2)
			let newpath = `http://192.168.0.42:8082` + "/" + media;

			console.log("this is newpath");
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleEnt = false);
		} else {
			let promise = getPlayMedia$1(media).catch(err => console.log(err));
			$$invalidate(2, visibleEnt = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Enterprise> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Enterprise", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		getEnterprise,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		getPlayMedia: getPlayMedia$1,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("Entshowlist" in $$props) $$invalidate(0, Entshowlist = $$props.Entshowlist);
		if ("Entshowlistcount" in $$props) $$invalidate(1, Entshowlistcount = $$props.Entshowlistcount);
		if ("visibleEnt" in $$props) $$invalidate(2, visibleEnt = $$props.visibleEnt);
		if ("handleEnterprise1" in $$props) $$invalidate(3, handleEnterprise1 = $$props.handleEnterprise1);
		if ("handleEnterprise2" in $$props) $$invalidate(4, handleEnterprise2 = $$props.handleEnterprise2);
		if ("handleEnterprise3" in $$props) $$invalidate(5, handleEnterprise3 = $$props.handleEnterprise3);
		if ("handleEnterprise4" in $$props) $$invalidate(6, handleEnterprise4 = $$props.handleEnterprise4);
		if ("fuckEnt" in $$props) $$invalidate(7, fuckEnt = $$props.fuckEnt);
		if ("handlePlayShow" in $$props) $$invalidate(8, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		handlePlayShow,
		LP
	];
}

class Enterprise extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Enterprise",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$1.warn("<Enterprise> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Enterprise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Enterprise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Orville.svelte generated by Svelte v3.24.0 */

const { console: console_1$2 } = globals;
const file$2 = "src/components/TVComps/Orville.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (60:0) {#if visibleOrv}
function create_if_block$2(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*ORVshowlistcount*/ ctx[1] > 0 && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$2, 61, 8, 1699);
			add_location(button1, file$2, 62, 8, 1748);
			add_location(nav, file$2, 60, 4, 1685);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$2, 65, 4, 1805);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleOR1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleOR2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*ORVshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(60:0) {#if visibleOrv}",
		ctx
	});

	return block;
}

// (67:8) {#if ORVshowlistcount > 0}
function create_if_block_1$2(ctx) {
	let each_1_anchor;
	let each_value = /*ORVshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ORVshowlist, handlePlayShowOr*/ 65) {
				each_value = /*ORVshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(67:8) {#if ORVshowlistcount > 0}",
		ctx
	});

	return block;
}

// (68:12) {#each ORVshowlist as sshow }
function create_each_block$2(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$2, 69, 20, 1928);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$2, 70, 20, 2028);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$2, 68, 16, 1903);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*ORVshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*ORVshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(68:12) {#each ORVshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleOrv*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Orville");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Orville");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$2, 57, 0, 1619);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckOrv*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleOrv*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$2(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$2($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let ORVshowlist;
	let ORVshowlistcount;
	let visibleOrv = false;

	async function getOrville(x) {
		let addr = `http://192.168.0.42:8888/intOrville?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, ORVshowlist = data);
			$$invalidate(1, ORVshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleOR1 = () => {
		let promise = getOrville(`01`).catch(err => console.log(err));
	};

	let handleOR2 = () => {
		let promise = getOrville(`02`).catch(err => console.log(err));
	};

	let fuckOrv = () => {
		if (visibleOrv) {
			$$invalidate(2, visibleOrv = false);
		} else {
			$$invalidate(2, visibleOrv = true);
		}
	};

	let handlePlayShowOr = media => {
		if (LP) {
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleOrv = false);
		} else {
			let promise = getPlayMedia$2(media).catch(err => console.log(err));
			$$invalidate(2, visibleOrv = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Orville> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Orville", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		getOrville,
		handleOR1,
		handleOR2,
		fuckOrv,
		getPlayMedia: getPlayMedia$2,
		handlePlayShowOr
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("ORVshowlist" in $$props) $$invalidate(0, ORVshowlist = $$props.ORVshowlist);
		if ("ORVshowlistcount" in $$props) $$invalidate(1, ORVshowlistcount = $$props.ORVshowlistcount);
		if ("visibleOrv" in $$props) $$invalidate(2, visibleOrv = $$props.visibleOrv);
		if ("handleOR1" in $$props) $$invalidate(3, handleOR1 = $$props.handleOR1);
		if ("handleOR2" in $$props) $$invalidate(4, handleOR2 = $$props.handleOR2);
		if ("fuckOrv" in $$props) $$invalidate(5, fuckOrv = $$props.fuckOrv);
		if ("handlePlayShowOr" in $$props) $$invalidate(6, handlePlayShowOr = $$props.handlePlayShowOr);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		handleOR1,
		handleOR2,
		fuckOrv,
		handlePlayShowOr,
		LP
	];
}

class Orville extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Orville",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$2.warn("<Orville> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Orville>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Orville>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/STTV.svelte generated by Svelte v3.24.0 */

const { console: console_1$3 } = globals;
const file$3 = "src/components/TVComps/STTV.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (67:0) {#if visibleDis}
function create_if_block$3(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$3(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$3, 68, 8, 1835);
			add_location(button1, file$3, 69, 8, 1891);
			add_location(button2, file$3, 70, 8, 1947);
			add_location(nav, file$3, 67, 4, 1821);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$3, 73, 4, 2011);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleSTTVClick1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleSTTVClick2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleSTTVClick3*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(67:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (75:8) {#if showlistcount > 0}
function create_if_block_1$3(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShowSTTV*/ 129) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(75:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (76:12) {#each showlist as sshow }
function create_each_block$3(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[10].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[10].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$3, 77, 20, 2128);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$3, 78, 20, 2230);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$3, 76, 16, 2103);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].tvfspath))) /*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[10].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[10].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(76:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("STTV");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "STTV");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$3, 64, 0, 1757);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$3(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$3($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	async function getSTTV(x) {
		let addr = `http://192.168.0.42:8888/intSTTV?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleSTTVClick1 = () => {
		let promise = getSTTV(`01`).catch(err => console.log(err));
	};

	let handleSTTVClick2 = () => {
		let promise = getSTTV(`02`).catch(err => console.log(err));
	};

	let handleSTTVClick3 = () => {
		let promise = getSTTV(`03`).catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShowSTTV = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$3(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<STTV> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("STTV", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getSTTV,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		getPlayMedia: getPlayMedia$3,
		handlePlayShowSTTV
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleSTTVClick1" in $$props) $$invalidate(3, handleSTTVClick1 = $$props.handleSTTVClick1);
		if ("handleSTTVClick2" in $$props) $$invalidate(4, handleSTTVClick2 = $$props.handleSTTVClick2);
		if ("handleSTTVClick3" in $$props) $$invalidate(5, handleSTTVClick3 = $$props.handleSTTVClick3);
		if ("fuckDis" in $$props) $$invalidate(6, fuckDis = $$props.fuckDis);
		if ("handlePlayShowSTTV" in $$props) $$invalidate(7, handlePlayShowSTTV = $$props.handlePlayShowSTTV);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		handlePlayShowSTTV,
		LP
	];
}

class STTV extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { LP: 8 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "STTV",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[8] === undefined && !("LP" in props)) {
			console_1$3.warn("<STTV> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<STTV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<STTV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/TNG.svelte generated by Svelte v3.24.0 */

const { console: console_1$4 } = globals;
const file$4 = "src/components/TVComps/TNG.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (81:0) {#if visibleTNG}
function create_if_block$4(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*TNGshowlistcount*/ ctx[1] > 0 && create_if_block_1$4(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$4, 82, 8, 2235);
			add_location(button1, file$4, 83, 8, 2285);
			add_location(button2, file$4, 84, 8, 2335);
			add_location(button3, file$4, 85, 8, 2385);
			add_location(button4, file$4, 86, 8, 2435);
			add_location(button5, file$4, 87, 8, 2485);
			add_location(button6, file$4, 88, 8, 2535);
			add_location(nav, file$4, 81, 4, 2221);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$4, 91, 4, 2593);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleTNG1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleTNG2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleTNG3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleTNG4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleTNG5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleTNG6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleTNG7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*TNGshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(81:0) {#if visibleTNG}",
		ctx
	});

	return block;
}

// (93:8) {#if TNGshowlistcount > 0}
function create_if_block_1$4(ctx) {
	let each_1_anchor;
	let each_value = /*TNGshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TNGshowlist, handlePlayTNG*/ 2049) {
				each_value = /*TNGshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(93:8) {#if TNGshowlistcount > 0}",
		ctx
	});

	return block;
}

// (94:12) {#each TNGshowlist as sshow }
function create_each_block$4(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$4, 95, 20, 2716);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$4, 96, 20, 2813);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$4, 94, 16, 2691);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].tvfspath))) /*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*TNGshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*TNGshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(94:12) {#each TNGshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleTNG*/ ctx[2] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Next Generation");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Next Generation");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 78, 0, 2143);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckTNG*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleTNG*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$4(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$4($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let TNGshowlist;
	let TNGshowlistcount;
	let visibleTNG = false;

	async function getTNG(x) {
		let addr = `http://192.168.0.42:8888/intTNG?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, TNGshowlist = data);
			$$invalidate(1, TNGshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleTNG1 = () => {
		let promise = getTNG(`01`).catch(err => console.log(err));
	};

	let handleTNG2 = () => {
		let promise = getTNG(`02`).catch(err => console.log(err));
	};

	let handleTNG3 = () => {
		let promise = getTNG(`03`).catch(err => console.log(err));
	};

	let handleTNG4 = () => {
		let promise = getTNG(`04`).catch(err => console.log(err));
	};

	let handleTNG5 = () => {
		let promise = getTNG(`05`).catch(err => console.log(err));
	};

	let handleTNG6 = () => {
		let promise = getTNG(`06`).catch(err => console.log(err));
	};

	let handleTNG7 = () => {
		let promise = getTNG(`07`).catch(err => console.log(err));
	};

	let fuckTNG = () => {
		if (visibleTNG) {
			$$invalidate(2, visibleTNG = false);
		} else {
			$$invalidate(2, visibleTNG = true);
		}
	};

	let handlePlayTNG = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleTNG = false);
		} else {
			let promise = getPlayMedia$4(media).catch(err => console.log(err));
			$$invalidate(2, visibleTNG = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<TNG> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TNG", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		getTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		getPlayMedia: getPlayMedia$4,
		handlePlayTNG
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("TNGshowlist" in $$props) $$invalidate(0, TNGshowlist = $$props.TNGshowlist);
		if ("TNGshowlistcount" in $$props) $$invalidate(1, TNGshowlistcount = $$props.TNGshowlistcount);
		if ("visibleTNG" in $$props) $$invalidate(2, visibleTNG = $$props.visibleTNG);
		if ("handleTNG1" in $$props) $$invalidate(3, handleTNG1 = $$props.handleTNG1);
		if ("handleTNG2" in $$props) $$invalidate(4, handleTNG2 = $$props.handleTNG2);
		if ("handleTNG3" in $$props) $$invalidate(5, handleTNG3 = $$props.handleTNG3);
		if ("handleTNG4" in $$props) $$invalidate(6, handleTNG4 = $$props.handleTNG4);
		if ("handleTNG5" in $$props) $$invalidate(7, handleTNG5 = $$props.handleTNG5);
		if ("handleTNG6" in $$props) $$invalidate(8, handleTNG6 = $$props.handleTNG6);
		if ("handleTNG7" in $$props) $$invalidate(9, handleTNG7 = $$props.handleTNG7);
		if ("fuckTNG" in $$props) $$invalidate(10, fuckTNG = $$props.fuckTNG);
		if ("handlePlayTNG" in $$props) $$invalidate(11, handlePlayTNG = $$props.handlePlayTNG);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		handlePlayTNG,
		LP
	];
}

class TNG extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TNG",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$4.warn("<TNG> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<TNG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<TNG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Voyager.svelte generated by Svelte v3.24.0 */

const { console: console_1$5 } = globals;
const file$5 = "src/components/TVComps/Voyager.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (81:0) {#if visibleVoy}
function create_if_block$5(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*VOYshowlistcount*/ ctx[1] > 0 && create_if_block_1$5(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$5, 82, 8, 2227);
			add_location(button1, file$5, 83, 8, 2277);
			add_location(button2, file$5, 84, 8, 2327);
			add_location(button3, file$5, 85, 8, 2377);
			add_location(button4, file$5, 86, 8, 2427);
			add_location(button5, file$5, 87, 8, 2477);
			add_location(button6, file$5, 88, 8, 2527);
			add_location(nav, file$5, 81, 4, 2213);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$5, 91, 4, 2585);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleVOY1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleVOY2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleVOY3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleVOY4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleVOY5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleVOY6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleVOY7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*VOYshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(81:0) {#if visibleVoy}",
		ctx
	});

	return block;
}

// (93:8) {#if VOYshowlistcount > 0}
function create_if_block_1$5(ctx) {
	let each_1_anchor;
	let each_value = /*VOYshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*VOYshowlist, handlePlayVOY*/ 2049) {
				each_value = /*VOYshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(93:8) {#if VOYshowlistcount > 0}",
		ctx
	});

	return block;
}

// (94:12) {#each VOYshowlist as sshow }
function create_each_block$5(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$5, 95, 20, 2708);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$5, 96, 20, 2805);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$5, 94, 16, 2683);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].tvfspath))) /*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*VOYshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*VOYshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(94:12) {#each VOYshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleVoy*/ ctx[2] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Voyager");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Voyager");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$5, 78, 0, 2147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckVOY*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleVoy*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$5(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$5($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let VOYshowlist;
	let VOYshowlistcount;
	let visibleVoy = false;

	async function getVOY(x) {
		let addr = `http://192.168.0.42:8888/intVoyager?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, VOYshowlist = data);
			$$invalidate(1, VOYshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleVOY1 = () => {
		let promise = getVOY(`01`).catch(err => console.log(err));
	};

	let handleVOY2 = () => {
		let promise = getVOY(`02`).catch(err => console.log(err));
	};

	let handleVOY3 = () => {
		let promise = getVOY(`03`).catch(err => console.log(err));
	};

	let handleVOY4 = () => {
		let promise = getVOY(`04`).catch(err => console.log(err));
	};

	let handleVOY5 = () => {
		let promise = getVOY(`05`).catch(err => console.log(err));
	};

	let handleVOY6 = () => {
		let promise = getVOY(`06`).catch(err => console.log(err));
	};

	let handleVOY7 = () => {
		let promise = getVOY(`07`).catch(err => console.log(err));
	};

	let fuckVOY = () => {
		if (visibleVoy) {
			$$invalidate(2, visibleVoy = false);
		} else {
			$$invalidate(2, visibleVoy = true);
		}
	};

	let handlePlayVOY = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			visibleVOY = false;
		} else {
			let promise = getPlayMedia$5(media).catch(err => console.log(err));
			visibleVOY = false;
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Voyager> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Voyager", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		getVOY,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		getPlayMedia: getPlayMedia$5,
		handlePlayVOY
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("VOYshowlist" in $$props) $$invalidate(0, VOYshowlist = $$props.VOYshowlist);
		if ("VOYshowlistcount" in $$props) $$invalidate(1, VOYshowlistcount = $$props.VOYshowlistcount);
		if ("visibleVoy" in $$props) $$invalidate(2, visibleVoy = $$props.visibleVoy);
		if ("handleVOY1" in $$props) $$invalidate(3, handleVOY1 = $$props.handleVOY1);
		if ("handleVOY2" in $$props) $$invalidate(4, handleVOY2 = $$props.handleVOY2);
		if ("handleVOY3" in $$props) $$invalidate(5, handleVOY3 = $$props.handleVOY3);
		if ("handleVOY4" in $$props) $$invalidate(6, handleVOY4 = $$props.handleVOY4);
		if ("handleVOY5" in $$props) $$invalidate(7, handleVOY5 = $$props.handleVOY5);
		if ("handleVOY6" in $$props) $$invalidate(8, handleVOY6 = $$props.handleVOY6);
		if ("handleVOY7" in $$props) $$invalidate(9, handleVOY7 = $$props.handleVOY7);
		if ("fuckVOY" in $$props) $$invalidate(10, fuckVOY = $$props.fuckVOY);
		if ("handlePlayVOY" in $$props) $$invalidate(11, handlePlayVOY = $$props.handlePlayVOY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		handlePlayVOY,
		LP
	];
}

class Voyager extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Voyager",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$5.warn("<Voyager> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Voyager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Voyager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LastShip.svelte generated by Svelte v3.24.0 */

const { console: console_1$6 } = globals;
const file$6 = "src/components/TVComps/LastShip.svelte";

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (70:0) {#if visibleLS}
function create_if_block$6(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LSshowlistcount*/ ctx[1] > 0 && create_if_block_1$6(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$6, 71, 8, 1905);
			add_location(button1, file$6, 72, 8, 1954);
			add_location(button2, file$6, 73, 8, 2003);
			add_location(button3, file$6, 74, 8, 2052);
			add_location(nav, file$6, 70, 4, 1891);
			attr_dev(ul, "class", "svelte-1omye9l");
			add_location(ul, file$6, 77, 4, 2109);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLS2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleLS3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleLS4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LSshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(70:0) {#if visibleLS}",
		ctx
	});

	return block;
}

// (79:8) {#if LSshowlistcount > 0}
function create_if_block_1$6(ctx) {
	let each_1_anchor;
	let each_value = /*LSshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LSshowlist, handlePlayLS*/ 257) {
				each_value = /*LSshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(79:8) {#if LSshowlistcount > 0}",
		ctx
	});

	return block;
}

// (80:12) {#each LSshowlist as sshow }
function create_each_block$6(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-1omye9l");
			add_location(a, file$6, 81, 20, 2230);
			attr_dev(span, "class", "svelte-1omye9l");
			add_location(span, file$6, 82, 20, 2326);
			attr_dev(li, "class", "svelte-1omye9l");
			add_location(li, file$6, 80, 16, 2205);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].tvfspath))) /*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LSshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LSshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(80:12) {#each LSshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLS*/ ctx[2] && create_if_block$6(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Last Ship");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Last Ship");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$6, 67, 0, 1820);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLS*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$6(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$6($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LSshowlist;
	let LSshowlistcount;

	async function getLS(x) {
		let addr = `http://192.168.0.42:8888/intLastShip?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, LSshowlist = data);
			$$invalidate(1, LSshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLS1 = () => {
		let promise = getLS(`01`).catch(err => console.log(err));
	};

	let handleLS2 = () => {
		let promise = getLS(`02`).catch(err => console.log(err));
	};

	let handleLS3 = () => {
		let promise = getLS(`03`).catch(err => console.log(err));
	};

	let handleLS4 = () => {
		let promise = getLS(`04`).catch(err => console.log(err));
	};

	let visibleLS = false;

	let fuckLS = () => {
		if (visibleLS) {
			$$invalidate(2, visibleLS = false);
		} else {
			$$invalidate(2, visibleLS = true);
		}
	};

	let handlePlayLS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleLS = false);
		} else {
			let promise = getPlayMedia$6(media).catch(err => console.log(err));
			$$invalidate(2, visibleLS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<LastShip> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LastShip", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		LSshowlist,
		LSshowlistcount,
		getLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		visibleLS,
		fuckLS,
		getPlayMedia: getPlayMedia$6,
		handlePlayLS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("LSshowlist" in $$props) $$invalidate(0, LSshowlist = $$props.LSshowlist);
		if ("LSshowlistcount" in $$props) $$invalidate(1, LSshowlistcount = $$props.LSshowlistcount);
		if ("handleLS1" in $$props) $$invalidate(3, handleLS1 = $$props.handleLS1);
		if ("handleLS2" in $$props) $$invalidate(4, handleLS2 = $$props.handleLS2);
		if ("handleLS3" in $$props) $$invalidate(5, handleLS3 = $$props.handleLS3);
		if ("handleLS4" in $$props) $$invalidate(6, handleLS4 = $$props.handleLS4);
		if ("visibleLS" in $$props) $$invalidate(2, visibleLS = $$props.visibleLS);
		if ("fuckLS" in $$props) $$invalidate(7, fuckLS = $$props.fuckLS);
		if ("handlePlayLS" in $$props) $$invalidate(8, handlePlayLS = $$props.handlePlayLS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LSshowlist,
		LSshowlistcount,
		visibleLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		fuckLS,
		handlePlayLS,
		LP
	];
}

class LastShip extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LastShip",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$6.warn("<LastShip> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LastShip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LastShip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LostInSpace.svelte generated by Svelte v3.24.0 */

const { console: console_1$7 } = globals;
const file$7 = "src/components/TVComps/LostInSpace.svelte";

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (64:0) {#if visibleLIS}
function create_if_block$7(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LISshowlistcount*/ ctx[1] > 0 && create_if_block_1$7(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$7, 65, 8, 1844);
			add_location(button1, file$7, 66, 8, 1894);
			add_location(nav, file$7, 64, 4, 1830);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$7, 69, 4, 1952);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLIS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLIS2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LISshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$7(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(64:0) {#if visibleLIS}",
		ctx
	});

	return block;
}

// (71:8) {#if LISshowlistcount > 0}
function create_if_block_1$7(ctx) {
	let each_1_anchor;
	let each_value = /*LISshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LISshowlist, handlePlayShowLIS*/ 65) {
				each_value = /*LISshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(71:8) {#if LISshowlistcount > 0}",
		ctx
	});

	return block;
}

// (72:12) {#each LISshowlist as sshow }
function create_each_block$7(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$7, 73, 20, 2075);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$7, 74, 20, 2176);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$7, 72, 16, 2050);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LISshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LISshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(72:12) {#each LISshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLIS*/ ctx[2] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Lost In Space");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Lost In Space");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$7, 61, 0, 1758);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLIS*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLIS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$7(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$7($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LISshowlist;
	let LISshowlistcount;
	let visibleLIS = false;

	async function getLostInSpace(x) {
		let addr = `http://192.168.0.42:8888/intLostInSpace?season=${x}`;
		console.log(addr);

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			$$invalidate(0, LISshowlist = data);
			$$invalidate(1, LISshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLIS1 = () => {
		let promise = getLostInSpace(`01`).catch(err => console.log(err));
	};

	let handleLIS2 = () => {
		let promise = getLostInSpace(`02`).catch(err => console.log(err));
	};

	let fuckLIS = () => {
		if (visibleLIS) {
			$$invalidate(2, visibleLIS = false);
		} else {
			$$invalidate(2, visibleLIS = true);
		}
	};

	let handlePlayShowLIS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleLIS = false);
		} else {
			let promise = getPlayMedia$7(media).catch(err => console.log(err));
			$$invalidate(2, visibleLIS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<LostInSpace> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LostInSpace", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		getLostInSpace,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		getPlayMedia: getPlayMedia$7,
		handlePlayShowLIS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("LISshowlist" in $$props) $$invalidate(0, LISshowlist = $$props.LISshowlist);
		if ("LISshowlistcount" in $$props) $$invalidate(1, LISshowlistcount = $$props.LISshowlistcount);
		if ("visibleLIS" in $$props) $$invalidate(2, visibleLIS = $$props.visibleLIS);
		if ("handleLIS1" in $$props) $$invalidate(3, handleLIS1 = $$props.handleLIS1);
		if ("handleLIS2" in $$props) $$invalidate(4, handleLIS2 = $$props.handleLIS2);
		if ("fuckLIS" in $$props) $$invalidate(5, fuckLIS = $$props.fuckLIS);
		if ("handlePlayShowLIS" in $$props) $$invalidate(6, handlePlayShowLIS = $$props.handlePlayShowLIS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		handlePlayShowLIS,
		LP
	];
}

class LostInSpace extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LostInSpace",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$7.warn("<LostInSpace> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LostInSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LostInSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Picard.svelte generated by Svelte v3.24.0 */

const { console: console_1$8 } = globals;
const file$8 = "src/components/TVComps/Picard.svelte";

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleDis}
function create_if_block$8(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$8(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$8, 73, 8, 1992);
			add_location(button1, file$8, 74, 8, 2045);
			add_location(nav, file$8, 72, 4, 1978);
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file$8, 76, 4, 2105);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handlePicard1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handlePicard2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$8(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(72:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (78:8) {#if showlistcount > 0}
function create_if_block_1$8(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShow*/ 65) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(78:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each showlist as sshow }
function create_each_block$8(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file$8, 80, 20, 2222);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file$8, 81, 20, 2320);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file$8, 79, 16, 2197);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$8.name,
		type: "each",
		source: "(79:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$8(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Picard");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Picard");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$8, 69, 0, 1913);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$8(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	console.log("this is y");
	console.log(y);
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$8($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	// onMount(
	async function getPicard(x) {
		let addr = `http://192.168.0.42:8888/intPicard?season=01`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	//)
	let handlePicard1 = () => {
		let promise = getPicard().catch(err => console.log(err));
	};

	let handlePicard2 = () => {
		let promise = getPicard().catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + "/" + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$8(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<Picard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Picard", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getPicard,
		handlePicard1,
		handlePicard2,
		fuckDis,
		getPlayMedia: getPlayMedia$8,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handlePicard1" in $$props) $$invalidate(3, handlePicard1 = $$props.handlePicard1);
		if ("handlePicard2" in $$props) $$invalidate(4, handlePicard2 = $$props.handlePicard2);
		if ("fuckDis" in $$props) $$invalidate(5, fuckDis = $$props.fuckDis);
		if ("handlePlayShow" in $$props) $$invalidate(6, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handlePicard1,
		handlePicard2,
		fuckDis,
		handlePlayShow,
		LP
	];
}

class Picard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Picard",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$8.warn("<Picard> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Picard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Picard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Mandalorian.svelte generated by Svelte v3.24.0 */

const { console: console_1$9 } = globals;
const file$9 = "src/components/TVComps/Mandalorian.svelte";

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (72:0) {#if visibleDis}
function create_if_block$9(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$9(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$9, 73, 8, 2027);
			add_location(button1, file$9, 74, 8, 2085);
			add_location(nav, file$9, 72, 4, 2013);
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file$9, 76, 4, 2150);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleMandalorian1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleMandalorian2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$9(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(72:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (78:8) {#if showlistcount > 0}
function create_if_block_1$9(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShow*/ 65) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(78:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each showlist as sshow }
function create_each_block$9(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file$9, 80, 20, 2267);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file$9, 81, 20, 2365);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file$9, 79, 16, 2242);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath))) /*handlePlayShow*/ ctx[6](/*sshow*/ ctx[9].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$9.name,
		type: "each",
		source: "(79:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$9(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Mandalorian");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Mandalorian");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$9, 69, 0, 1943);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$9(x) {
	let y = "/media/pi/PiTB/media/TVShows" + x;
	console.log("this is y");
	console.log(y);
	let addr = `http://192.168.0.42:8888/playMediaReact?movie=${y}`;
	console.log(addr);

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$9($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	// onMount(
	async function getMandalorian(x) {
		let addr = `http://192.168.0.42:8888/intMandalorian?season=01`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	//)
	let handleMandalorian1 = () => {
		let promise = getMandalorian().catch(err => console.log(err));
	};

	let handleMandalorian2 = () => {
		let promise = getMandalorian().catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + "/" + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$9(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<Mandalorian> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Mandalorian", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getMandalorian,
		handleMandalorian1,
		handleMandalorian2,
		fuckDis,
		getPlayMedia: getPlayMedia$9,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleMandalorian1" in $$props) $$invalidate(3, handleMandalorian1 = $$props.handleMandalorian1);
		if ("handleMandalorian2" in $$props) $$invalidate(4, handleMandalorian2 = $$props.handleMandalorian2);
		if ("fuckDis" in $$props) $$invalidate(5, fuckDis = $$props.fuckDis);
		if ("handlePlayShow" in $$props) $$invalidate(6, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleMandalorian1,
		handleMandalorian2,
		fuckDis,
		handlePlayShow,
		LP
	];
}

class Mandalorian extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Mandalorian",
			options,
			id: create_fragment$9.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$9.warn("<Mandalorian> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Mandalorian>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Mandalorian>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVShowsListComp.svelte generated by Svelte v3.24.0 */
const file$a = "src/components/TVShowsListComp.svelte";

function create_fragment$a(ctx) {
	let nav;
	let discovery;
	let t0;
	let enterprise;
	let t1;
	let orville;
	let t2;
	let sttv;
	let t3;
	let tng;
	let t4;
	let voy;
	let t5;
	let ls;
	let t6;
	let lis;
	let t7;
	let picard;
	let t8;
	let mand;
	let current;

	discovery = new Discovery({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	enterprise = new Enterprise({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	orville = new Orville({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	sttv = new STTV({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	tng = new TNG({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	voy = new Voyager({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	ls = new LastShip({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	lis = new LostInSpace({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	picard = new Picard({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	mand = new Mandalorian({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			create_component(discovery.$$.fragment);
			t0 = space();
			create_component(enterprise.$$.fragment);
			t1 = space();
			create_component(orville.$$.fragment);
			t2 = space();
			create_component(sttv.$$.fragment);
			t3 = space();
			create_component(tng.$$.fragment);
			t4 = space();
			create_component(voy.$$.fragment);
			t5 = space();
			create_component(ls.$$.fragment);
			t6 = space();
			create_component(lis.$$.fragment);
			t7 = space();
			create_component(picard.$$.fragment);
			t8 = space();
			create_component(mand.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(discovery.$$.fragment, nav_nodes);
			t0 = claim_space(nav_nodes);
			claim_component(enterprise.$$.fragment, nav_nodes);
			t1 = claim_space(nav_nodes);
			claim_component(orville.$$.fragment, nav_nodes);
			t2 = claim_space(nav_nodes);
			claim_component(sttv.$$.fragment, nav_nodes);
			t3 = claim_space(nav_nodes);
			claim_component(tng.$$.fragment, nav_nodes);
			t4 = claim_space(nav_nodes);
			claim_component(voy.$$.fragment, nav_nodes);
			t5 = claim_space(nav_nodes);
			claim_component(ls.$$.fragment, nav_nodes);
			t6 = claim_space(nav_nodes);
			claim_component(lis.$$.fragment, nav_nodes);
			t7 = claim_space(nav_nodes);
			claim_component(picard.$$.fragment, nav_nodes);
			t8 = claim_space(nav_nodes);
			claim_component(mand.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(nav, "class", "svelte-14m8txd");
			add_location(nav, file$a, 15, 0, 718);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			mount_component(discovery, nav, null);
			append_dev(nav, t0);
			mount_component(enterprise, nav, null);
			append_dev(nav, t1);
			mount_component(orville, nav, null);
			append_dev(nav, t2);
			mount_component(sttv, nav, null);
			append_dev(nav, t3);
			mount_component(tng, nav, null);
			append_dev(nav, t4);
			mount_component(voy, nav, null);
			append_dev(nav, t5);
			mount_component(ls, nav, null);
			append_dev(nav, t6);
			mount_component(lis, nav, null);
			append_dev(nav, t7);
			mount_component(picard, nav, null);
			append_dev(nav, t8);
			mount_component(mand, nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const discovery_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) discovery_changes.LP = /*LOCALPLAY*/ ctx[0];
			discovery.$set(discovery_changes);
			const enterprise_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) enterprise_changes.LP = /*LOCALPLAY*/ ctx[0];
			enterprise.$set(enterprise_changes);
			const orville_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) orville_changes.LP = /*LOCALPLAY*/ ctx[0];
			orville.$set(orville_changes);
			const sttv_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) sttv_changes.LP = /*LOCALPLAY*/ ctx[0];
			sttv.$set(sttv_changes);
			const tng_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) tng_changes.LP = /*LOCALPLAY*/ ctx[0];
			tng.$set(tng_changes);
			const voy_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) voy_changes.LP = /*LOCALPLAY*/ ctx[0];
			voy.$set(voy_changes);
			const ls_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) ls_changes.LP = /*LOCALPLAY*/ ctx[0];
			ls.$set(ls_changes);
			const lis_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) lis_changes.LP = /*LOCALPLAY*/ ctx[0];
			lis.$set(lis_changes);
			const picard_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) picard_changes.LP = /*LOCALPLAY*/ ctx[0];
			picard.$set(picard_changes);
			const mand_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) mand_changes.LP = /*LOCALPLAY*/ ctx[0];
			mand.$set(mand_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(discovery.$$.fragment, local);
			transition_in(enterprise.$$.fragment, local);
			transition_in(orville.$$.fragment, local);
			transition_in(sttv.$$.fragment, local);
			transition_in(tng.$$.fragment, local);
			transition_in(voy.$$.fragment, local);
			transition_in(ls.$$.fragment, local);
			transition_in(lis.$$.fragment, local);
			transition_in(picard.$$.fragment, local);
			transition_in(mand.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(discovery.$$.fragment, local);
			transition_out(enterprise.$$.fragment, local);
			transition_out(orville.$$.fragment, local);
			transition_out(sttv.$$.fragment, local);
			transition_out(tng.$$.fragment, local);
			transition_out(voy.$$.fragment, local);
			transition_out(ls.$$.fragment, local);
			transition_out(lis.$$.fragment, local);
			transition_out(picard.$$.fragment, local);
			transition_out(mand.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(discovery);
			destroy_component(enterprise);
			destroy_component(orville);
			destroy_component(sttv);
			destroy_component(tng);
			destroy_component(voy);
			destroy_component(ls);
			destroy_component(lis);
			destroy_component(picard);
			destroy_component(mand);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { LOCALPLAY } = $$props;
	const writable_props = ["LOCALPLAY"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TVShowsListComp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TVShowsListComp", $$slots, []);

	$$self.$set = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	$$self.$capture_state = () => ({
		set_store_value,
		Discovery,
		Enterprise,
		Orville,
		STTV,
		TNG,
		VOY: Voyager,
		LS: LastShip,
		LIS: LostInSpace,
		PICARD: Picard,
		MAND: Mandalorian,
		LOCALPLAY
	});

	$$self.$inject_state = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [LOCALPLAY];
}

class TVShowsListComp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { LOCALPLAY: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TVShowsListComp",
			options,
			id: create_fragment$a.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LOCALPLAY*/ ctx[0] === undefined && !("LOCALPLAY" in props)) {
			console.warn("<TVShowsListComp> was created without expected prop 'LOCALPLAY'");
		}
	}

	get LOCALPLAY() {
		throw new Error("<TVShowsListComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LOCALPLAY(value) {
		throw new Error("<TVShowsListComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/tvshows.svelte generated by Svelte v3.24.0 */
const file$b = "src/routes/tvshows.svelte";

// (34:0) {#if visible3}
function create_if_block_1$a(ctx) {
	let div;
	let video;
	let video_src_value;

	const block = {
		c: function create() {
			div = element("div");
			video = element("video");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);

			video = claim_element(div_nodes, "VIDEO", {
				src: true,
				controls: true,
				autoplay: true,
				class: true
			});

			children(video).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) attr_dev(video, "src", video_src_value);
			video.controls = true;
			video.autoplay = true;
			attr_dev(video, "class", "svelte-calnre");
			add_location(video, file$b, 36, 8, 825);
			attr_dev(div, "id", "vid2");
			attr_dev(div, "class", "svelte-calnre");
			add_location(div, file$b, 34, 4, 729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, video);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TVlocalplayURL_value*/ 2 && video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) {
				attr_dev(video, "src", video_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$a.name,
		type: "if",
		source: "(34:0) {#if visible3}",
		ctx
	});

	return block;
}

// (44:0) {#if !visible3}
function create_if_block$a(ctx) {
	let controls;
	let current;
	controls = new Controls({ $$inline: true });

	const block = {
		c: function create() {
			create_component(controls.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(controls.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(controls, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(controls.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(controls.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(controls, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(44:0) {#if !visible3}",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let t0;
	let t1;
	let input;
	let t2;
	let lable;
	let t3;
	let t4;
	let t5;
	let tvshows;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*visible3*/ ctx[0] && create_if_block_1$a(ctx);
	let if_block1 = !/*visible3*/ ctx[0] && create_if_block$a(ctx);

	tvshows = new TVShowsListComp({
			props: { LOCALPLAY: /*visible3*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			lable = element("lable");
			t3 = text("localplay");
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			create_component(tvshows.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-xfr3l7\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			input = claim_element(nodes, "INPUT", { type: true, value: true });
			t2 = claim_space(nodes);
			lable = claim_element(nodes, "LABLE", {});
			var lable_nodes = children(lable);
			t3 = claim_text(lable_nodes, "localplay");
			lable_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t5 = claim_space(nodes);
			claim_component(tvshows.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "TV Shows";
			attr_dev(input, "type", "checkbox");
			input.__value = "fuck";
			input.value = input.__value;
			add_location(input, file$b, 40, 0, 904);
			add_location(lable, file$b, 41, 0, 965);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, input, anchor);
			input.checked = /*visible3*/ ctx[0];
			insert_dev(target, t2, anchor);
			insert_dev(target, lable, anchor);
			append_dev(lable, t3);
			insert_dev(target, t4, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(tvshows, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible3*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$a(ctx);
					if_block0.c();
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*visible3*/ 1) {
				input.checked = /*visible3*/ ctx[0];
			}

			if (!/*visible3*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*visible3*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$a(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t5.parentNode, t5);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const tvshows_changes = {};
			if (dirty & /*visible3*/ 1) tvshows_changes.LOCALPLAY = /*visible3*/ ctx[0];
			tvshows.$set(tvshows_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(tvshows.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(tvshows.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(lable);
			if (detaching) detach_dev(t4);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t5);
			destroy_component(tvshows, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let visible = false;
	let visible3 = false;

	let fuck = () => {
		if (visible) {
			visible = false;
		} else {
			visible = true;
		}
	};

	let fuck3 = () => {
		if (visible3) {
			$$invalidate(0, visible3 = false);
		} else {
			$$invalidate(0, visible3 = true);
		}
	};

	let TVlocalplayURL_value;

	const unsubplid = TVlocalplayURL.subscribe(value => {
		$$invalidate(1, TVlocalplayURL_value = value);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tvshows> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Tvshows", $$slots, []);

	function input_change_handler() {
		visible3 = this.checked;
		$$invalidate(0, visible3);
	}

	$$self.$capture_state = () => ({
		TVShows: TVShowsListComp,
		Controls,
		TVlocalplayURL,
		visible,
		visible3,
		fuck,
		fuck3,
		TVlocalplayURL_value,
		unsubplid
	});

	$$self.$inject_state = $$props => {
		if ("visible" in $$props) visible = $$props.visible;
		if ("visible3" in $$props) $$invalidate(0, visible3 = $$props.visible3);
		if ("fuck" in $$props) fuck = $$props.fuck;
		if ("fuck3" in $$props) fuck3 = $$props.fuck3;
		if ("TVlocalplayURL_value" in $$props) $$invalidate(1, TVlocalplayURL_value = $$props.TVlocalplayURL_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [visible3, TVlocalplayURL_value, input_change_handler];
}

class Tvshows extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tvshows",
			options,
			id: create_fragment$b.name
		});
	}
}

export default Tvshows;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHZzaG93cy5kNDI4YmJkMy5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9EaXNjb3Zlcnkuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9FbnRlcnByaXNlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvT3J2aWxsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL1NUVFYuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9UTkcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Wb3lhZ2VyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvTGFzdFNoaXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Mb3N0SW5TcGFjZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL1BpY2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL01hbmRhbG9yaWFuLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWU2hvd3NMaXN0Q29tcC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL3R2c2hvd3Muc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgLy8gaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG5cbiAgICBsZXQgc2hvd2xpc3Q7XG4gICAgbGV0IHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVEaXMgPSBmYWxzZVxuXG4gICAgLy8gb25Nb3VudChcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0RGlzY292ZXJ5KHgpIHtcbiAgICAgICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnREaXNjb3Zlcnk/c2Vhc29uPSR7eH1gXG4gICAgICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhWzBdLmVwaXNvZGUpXG4gICAgICAgICAgICAgICAgc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICAgICAgc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgIH1cbiAgICAvLylcblxuICAgIGxldCBoYW5kbGVEaXNjb3ZlcnkxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldERpc2NvdmVyeShgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZURpc2NvdmVyeTIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0RGlzY292ZXJ5KGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0RpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVEaXMpIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCB5ID0gXCIvbWVkaWEvcGkvUGlUQi9tZWRpYS9UVlNob3dzXCIgKyB4XG4gICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyB5XCIpXG4gICAgICAgIGNvbnNvbGUubG9nKHkpXG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD9tb3ZpZT0ke3l9YFxuICAgICAgICBjb25zb2xlLmxvZyhhZGRyKVxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgICBsZXQgaGFuZGxlUGxheVNob3cgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgyYCArIFwiL1wiICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRGlzfT5EaXNjb3Zlcnk8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlRGlzfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZURpc2NvdmVyeTF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZURpc2NvdmVyeTJ9PnMyPC9idXR0b24+XG4gICAgPC9uYXY+XG4gICAgPHVsPlxuICAgICAgICB7I2lmIHNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIHNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlTaG93KHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIFxuICAgIH1cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgRW50c2hvd2xpc3Q7XG4gICAgbGV0IEVudHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVFbnQgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0RW50ZXJwcmlzZSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRFbnRlcnByaXNlP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgRW50c2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBFbnRzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVFbnRlcnByaXNlMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRFbnRlcnByaXNlKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlRW50ZXJwcmlzZTIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0RW50ZXJwcmlzZShgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVFbnRlcnByaXNlMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRFbnRlcnByaXNlKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUVudGVycHJpc2U0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldEVudGVycHJpc2UoYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrRW50ID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZUVudCkge1xuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlRW50ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IHkgPSBcIi9tZWRpYS9waS9QaVRCL21lZGlhL1RWU2hvd3NcIiArIHhcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P21vdmllPSR7eX1gXG4gICAgICAgIGNvbnNvbGUubG9nKGFkZHIpXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlTaG93ID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0aGlzIGlzIG1lZGlhXCIpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgLy8gbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgyYCArIFwiL1wiICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyBuZXdwYXRoXCIpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlRW50ID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlRW50ID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tFbnR9ID5FbnRlcnByaXNlPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZUVudH1cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVFbnRlcnByaXNlMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlRW50ZXJwcmlzZTJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUVudGVycHJpc2UzfT5zMzwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVFbnRlcnByaXNlNH0+czQ8L2J1dHRvbj5cbiAgICA8L25hdj5cblxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBFbnRzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBFbnRzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5U2hvdyhzc2hvdy50dmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cblxuXG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IE9SVnNob3dsaXN0O1xuICAgIGxldCBPUlZzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlT3J2ID0gZmFsc2VcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldE9ydmlsbGUoeCkge1xuXG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRPcnZpbGxlP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgT1JWc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBPUlZzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlT1IxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldE9ydmlsbGUoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlT1IyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldE9ydmlsbGUoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuXG4gICAgbGV0IGZ1Y2tPcnYgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlT3J2KSB7XG4gICAgICAgICAgICB2aXNpYmxlT3J2ID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVPcnYgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgeSA9IFwiL21lZGlhL3BpL1BpVEIvbWVkaWEvVFZTaG93c1wiICsgeFxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/bW92aWU9JHt5fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVNob3dPciA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBtZWRpYVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlT3J2ID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlT3J2ID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrT3J2fT5PcnZpbGxlPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZU9ydn1cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVPUjF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZU9SMn0+czI8L2J1dHRvbj5cbiAgICA8L25hdj5cblxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBPUlZzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBPUlZzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5U2hvd09yKHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgc2hvd2xpc3Q7XG4gICAgbGV0IHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVEaXMgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0U1RUVih4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRTVFRWP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVTVFRWQ2xpY2sxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFNUVFYoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVTVFRWQ2xpY2syID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFNUVFYoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlU1RUVkNsaWNrMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRTVFRWKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0RpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVEaXMpIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCB5ID0gXCIvbWVkaWEvcGkvUGlUQi9tZWRpYS9UVlNob3dzXCIgKyB4XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD9tb3ZpZT0ke3l9YFxuICAgICAgICBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVNob3dTVFRWID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRGlzfSA+U1RUVjwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVEaXN9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlU1RUVkNsaWNrMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlU1RUVkNsaWNrMn0+czI8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlU1RUVkNsaWNrM30+czM8L2J1dHRvbj5cbiAgICA8L25hdj5cblxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5U2hvd1NUVFYoc3Nob3cudHZmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cbiAgICBcbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgVE5Hc2hvd2xpc3Q7XG4gICAgbGV0IFROR3Nob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVUTkcgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VE5HKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L2ludFRORz9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIFROR3Nob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgVE5Hc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVE5HMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVUTkcyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVUTkczID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDNgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVUTkc0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDRgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVRORzUgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwNWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVE5HNiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDA2YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVUTkc3ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDdgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGZ1Y2tUTkcgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlVE5HKSB7XG4gICAgICAgICAgICB2aXNpYmxlVE5HID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVUTkcgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgeSA9IFwiL21lZGlhL3BpL1BpVEIvbWVkaWEvVFZTaG93c1wiICsgeFxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/bW92aWU9JHt5fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVRORyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVUTkcgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVUTkcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja1ROR30+VGhlIE5leHQgR2VuZXJhdGlvbjwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVUTkd9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlVE5HMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlVE5HMn0+czI8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlVE5HM30+czM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlVE5HNH0+czQ8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlVE5HNX0+czU8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlVE5HNn0+czY8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlVE5HN30+czc8L2J1dHRvbj5cbiAgICA8L25hdj5cblxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBUTkdzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBUTkdzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5VE5HKHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgVk9Zc2hvd2xpc3Q7XG4gICAgbGV0IFZPWXNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVWb3kgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0Vk9ZKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L2ludFZveWFnZXI/c2Vhc29uPSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBWT1lzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIFZPWXNob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVZPWTEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVk9ZMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVk9ZMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDAzYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVk9ZNCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVWT1k1ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDVgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVZPWTYgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwNmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVk9ZNyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDA3YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrVk9ZID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZVZveSkge1xuICAgICAgICAgICAgdmlzaWJsZVZveSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlVm95ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IHkgPSBcIi9tZWRpYS9waS9QaVRCL21lZGlhL1RWU2hvd3NcIiArIHhcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P21vdmllPSR7eX1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlWT1kgPSAobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKExQKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZWRpYSlcblxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgyYCArIG1lZGlhXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlVk9ZID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlVk9ZID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tWT1l9PlZveWFnZXI8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlVm95fVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZPWTF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZPWTJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZPWTN9PnMzPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZPWTR9PnM0PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZPWTV9PnM1PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZPWTZ9PnM2PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZVZPWTd9PnM3PC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgVk9Zc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggVk9Zc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVZPWShzc2hvdy50dmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cblxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuICAgIFxuICAgIGEge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuICAgIGxldCBMU3Nob3dsaXN0O1xuICAgIGxldCBMU3Nob3dsaXN0Y291bnQ7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRMUyh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRMYXN0U2hpcD9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIExTc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBMU3Nob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZUxTMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRMUyhgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZUxTMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRMUyhgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVMUzMgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TFMoYDAzYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlTFM0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExTKGAwNGApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cblxuICAgIGxldCB2aXNpYmxlTFMgPSBmYWxzZVxuICAgIGxldCBmdWNrTFMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlTFMpIHtcbiAgICAgICAgICAgIHZpc2libGVMUyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlTFMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgeSA9IFwiL21lZGlhL3BpL1BpVEIvbWVkaWEvVFZTaG93c1wiICsgeFxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/bW92aWU9JHt5fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheUxTID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBmb29bMV1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVMUyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZUxTID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tMU30gPlRoZSBMYXN0IFNoaXA8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlTFN9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTFMxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMUzJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUxTM30+czM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTFM0fT5zNDwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIExTc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggTFNzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5TFMoc3Nob3cudHZmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cblxuICAgIGEgeyBcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuICAgIGxldCBMSVNzaG93bGlzdDtcbiAgICBsZXQgTElTc2hvd2xpc3Rjb3VudDtcbiAgICBsZXQgdmlzaWJsZUxJUyA9IGZhbHNlXG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldExvc3RJblNwYWNlKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L2ludExvc3RJblNwYWNlP3NlYXNvbj0ke3h9YFxuICAgICAgICBjb25zb2xlLmxvZyhhZGRyKVxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgICAgIExJU3Nob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgTElTc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUxJUzEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TG9zdEluU3BhY2UoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlTElTMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRMb3N0SW5TcGFjZShgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG5cbiAgICBsZXQgZnVja0xJUyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVMSVMpIHtcbiAgICAgICAgICAgIHZpc2libGVMSVMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZUxJUyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCB5ID0gXCIvbWVkaWEvcGkvUGlUQi9tZWRpYS9UVlNob3dzXCIgKyB4XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD9tb3ZpZT0ke3l9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVQbGF5U2hvd0xJUyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuICAgICAgICAgICAgbGV0IGZvbyA9IG1lZGlhLnNwbGl0KFwiVFZTaG93c1wiLCAyKVxuICAgICAgICAgICAgbGV0IG5ld3BhdGggPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgyYCArIG1lZGlhXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlTElTID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlTElTID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrTElTfT5Mb3N0IEluIFNwYWNlPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZUxJU31cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMSVMxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMSVMyfT5zMjwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIExJU3Nob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIExJU3Nob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlTaG93TElTKHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIC8vIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuXG4gICAgbGV0IHNob3dsaXN0O1xuICAgIGxldCBzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRGlzID0gZmFsc2VcblxuICAgIC8vIG9uTW91bnQoXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBpY2FyZCh4KSB7XG4gICAgICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50UGljYXJkP3NlYXNvbj0wMWBcbiAgICAgICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFbMF0uZXBpc29kZSlcbiAgICAgICAgICAgICAgICBzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgICAgICBzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgfVxuICAgIC8vKVxuXG4gICAgbGV0IGhhbmRsZVBpY2FyZDEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGljYXJkKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGljYXJkMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQaWNhcmQoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrRGlzID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZURpcykge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IHkgPSBcIi9tZWRpYS9waS9QaVRCL21lZGlhL1RWU2hvd3NcIiArIHhcbiAgICAgICAgY29uc29sZS5sb2coXCJ0aGlzIGlzIHlcIilcbiAgICAgICAgY29uc29sZS5sb2coeSlcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P21vdmllPSR7eX1gXG4gICAgICAgIGNvbnNvbGUubG9nKGFkZHIpXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgIGxldCBoYW5kbGVQbGF5U2hvdyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgXCIvXCIgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tEaXN9PlBpY2FyZDwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVEaXN9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlUGljYXJkMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlUGljYXJkMn0+czI8L2J1dHRvbj5cbiAgICA8L25hdj5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3coc3Nob3cudHZmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICAgICAgXG4gICAgfVxuICAgIGEge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgLy8gaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG5cbiAgICBsZXQgc2hvd2xpc3Q7XG4gICAgbGV0IHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVEaXMgPSBmYWxzZVxuXG4gICAgLy8gb25Nb3VudChcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0TWFuZGFsb3JpYW4oeCkge1xuICAgICAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L2ludE1hbmRhbG9yaWFuP3NlYXNvbj0wMWBcbiAgICAgICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFbMF0uZXBpc29kZSlcbiAgICAgICAgICAgICAgICBzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgICAgICBzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgfVxuICAgIC8vKVxuXG4gICAgbGV0IGhhbmRsZU1hbmRhbG9yaWFuMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRNYW5kYWxvcmlhbihgMDFgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZU1hbmRhbG9yaWFuMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRNYW5kYWxvcmlhbihgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGZ1Y2tEaXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlRGlzKSB7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgeSA9IFwiL21lZGlhL3BpL1BpVEIvbWVkaWEvVFZTaG93c1wiICsgeFxuICAgICAgICBjb25zb2xlLmxvZyhcInRoaXMgaXMgeVwiKVxuICAgICAgICBjb25zb2xlLmxvZyh5KVxuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/bW92aWU9JHt5fWBcbiAgICAgICAgY29uc29sZS5sb2coYWRkcilcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICAgbGV0IGhhbmRsZVBsYXlTaG93ID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBcIi9cIiArIG1lZGlhXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja0Rpc30+TWFuZGFsb3JpYW48L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlRGlzfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZU1hbmRhbG9yaWFuMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTWFuZGFsb3JpYW4yfT5zMjwvYnV0dG9uPlxuICAgIDwvbmF2PlxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5U2hvdyhzc2hvdy50dmZzcGF0aCl9Pntzc2hvdy50aXRsZX08L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntzc2hvdy5lcGlzb2RlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgc3BhbiB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICBcbiAgICB9XG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBzZXRfc3RvcmVfdmFsdWUgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gICAgaW1wb3J0IERpc2NvdmVyeSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvRGlzY292ZXJ5LnN2ZWx0ZSdcbiAgICBpbXBvcnQgRW50ZXJwcmlzZSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvRW50ZXJwcmlzZS5zdmVsdGUnXG4gICAgaW1wb3J0IE9ydmlsbGUgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL09ydmlsbGUuc3ZlbHRlJ1xuICAgIGltcG9ydCBTVFRWIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9TVFRWLnN2ZWx0ZSdcbiAgICBpbXBvcnQgVE5HIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9UTkcuc3ZlbHRlJ1xuICAgIGltcG9ydCBWT1kgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL1ZveWFnZXIuc3ZlbHRlJ1xuICAgIGltcG9ydCBMUyBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvTGFzdFNoaXAuc3ZlbHRlJ1xuICAgIGltcG9ydCBMSVMgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL0xvc3RJblNwYWNlLnN2ZWx0ZSdcbiAgICBpbXBvcnQgUElDQVJEIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9QaWNhcmQuc3ZlbHRlJ1xuICAgIGltcG9ydCBNQU5EIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9NYW5kYWxvcmlhbi5zdmVsdGUnXG4gICAgZXhwb3J0IGxldCBMT0NBTFBMQVk7XG48L3NjcmlwdD5cblxuPG5hdj5cbiAgICA8RGlzY292ZXJ5IExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8RW50ZXJwcmlzZSBMUD17TE9DQUxQTEFZfS8+XG4gICAgPE9ydmlsbGUgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxTVFRWIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8VE5HIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8Vk9ZIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8TFMgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxMSVMgTFA9e0xPQ0FMUExBWX0gLz5cbiAgICA8UElDQVJEIExQPXtMT0NBTFBMQVl9IC8+XG4gICAgPE1BTkQgTFA9e0xPQ0FMUExBWX0gLz5cbjwvbmF2PlxuXG48c3R5bGU+XG4gICAgbmF2IHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBUVlNob3dzIGZyb20gJy4uL2NvbXBvbmVudHMvVFZTaG93c0xpc3RDb21wLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29tcG9uZW50cy9Db250cm9scy5zdmVsdGUnXG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9jb21wb25lbnRzL1BsYXllclN0b3JlJ1xuICAgIFxuICAgIGxldCB2aXNpYmxlID0gZmFsc2VcbiAgICBsZXQgdmlzaWJsZTMgPSBmYWxzZVxuXG5cdGxldCBmdWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZ1Y2szID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZTMpIHtcbiAgICAgICAgICAgIHZpc2libGUzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGUzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IFRWbG9jYWxwbGF5VVJMX3ZhbHVlXG5cdGNvbnN0IHVuc3VicGxpZCA9IFRWbG9jYWxwbGF5VVJMLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIFRWbG9jYWxwbGF5VVJMX3ZhbHVlID0gdmFsdWVcbiAgICB9KVxuXG48L3NjcmlwdD5cblxuPHN2ZWx0ZTpoZWFkPjx0aXRsZT5UViBTaG93czwvdGl0bGU+PC9zdmVsdGU6aGVhZD5cblxueyNpZiB2aXNpYmxlM31cbiAgICA8ZGl2IGlkPVwidmlkMlwiPlxuICAgICAgICA8IS0tIFwiaHR0cDovLzE5Mi4xNjguMC40Mjo4MDgxL0FjdGlvbi8xMiBTdHJvbmcgKDIwMTgpLm1wNFwiIC0tPlxuICAgICAgICA8dmlkZW8gc3JjPXtUVmxvY2FscGxheVVSTF92YWx1ZX0gY29udHJvbHMgYXV0b3BsYXk+PC92aWRlbz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9e3Zpc2libGUzfSB2YWx1ZT1cImZ1Y2tcIj5cbjxsYWJsZT5sb2NhbHBsYXk8L2xhYmxlPlxuXG57I2lmICF2aXNpYmxlM31cbiAgICA8Q29udHJvbHMgLz5cbiAgICA8IS0tIDxidXR0b24gY2xhc3M9XCJjb250cm9sbGVyXCIgb246Y2xpY2s9e2Z1Y2t9ID5jb250cm9sczwvYnV0dG9uPiAtLT5cbnsvaWZ9XG5cbjxUVlNob3dzIExPQ0FMUExBWT17dmlzaWJsZTN9IC8+XG5cbjxzdHlsZT5cblxuICAgICN2aWQyIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIHZpZGVvIHtcbiAgICAgICAgd2lkdGg6IDg1JTtcbiAgICB9XG5cbjwvc3R5bGU+Il0sIm5hbWVzIjpbImdldFBsYXlNZWRpYSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBNkVhLEdBQWEsTUFBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VEQUpKLEdBQWdCO3VEQUNoQixHQUFnQjs7Ozs7Ozt5QkFHN0IsR0FBYSxNQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQ1gsR0FBUTs7OztnQ0FBYixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUFDLEdBQVE7Ozs7K0JBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBRStELEdBQUssSUFBQyxLQUFLOzs7OzBCQUNqRSxHQUFLLElBQUMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUNBRFEsR0FBYyxjQUFDLEdBQUssSUFBQyxRQUFRLHVCQUE3QixHQUFjLGNBQUMsR0FBSyxJQUFDLFFBQVE7Ozs7Ozs7Ozs7OztvRUFBSSxHQUFLLElBQUMsS0FBSztvRUFDakUsR0FBSyxJQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFWbkMsR0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RBRkcsR0FBTzs7Ozs7c0JBRXBCLEdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWhDSSxZQUFZLENBQUMsQ0FBQztLQUNyQixDQUFDLEdBQUcsOEJBQThCLEdBQUcsQ0FBQztDQUMxQyxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVc7Q0FDdkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ1QsSUFBSSxvREFBb0QsQ0FBQztDQUM3RCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUk7O0NBQ2hC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
