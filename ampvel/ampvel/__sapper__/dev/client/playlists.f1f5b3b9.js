import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, g as globals, e as element, p as space, t as text, c as claim_element, a as children, r as claim_space, b as claim_text, f as detach_dev, h as attr_dev, j as add_location, k as insert_dev, l as append_dev, m as listen_dev, w as prevent_default, n as noop, x as empty, y as validate_each_argument, u as set_data_dev, z as destroy_each, o as onMount, A as create_component, B as claim_component, C as mount_component, D as transition_in, E as transition_out, F as destroy_component, G as prop_dev, q as query_selector_all } from './client.8f7890db.js';
import { p as playliststore, a as playlistidstore } from './PlaylistListStore.aeaed8f7.js';

/* src/components/PlaylistComps/AddRandomPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;
const file = "src/components/PlaylistComps/AddRandomPlaylist.svelte";

// (37:0) {#if radvisible}
function create_if_block(ctx) {
	let form;
	let input0;
	let t0;
	let label0;
	let t1;
	let br0;
	let t2;
	let input1;
	let t3;
	let label1;
	let t4;
	let br1;
	let t5;
	let input2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			input0 = element("input");
			t0 = space();
			label0 = element("label");
			t1 = text("Playlist Name");
			br0 = element("br");
			t2 = space();
			input1 = element("input");
			t3 = space();
			label1 = element("label");
			t4 = text("Number Of Songs");
			br1 = element("br");
			t5 = space();
			input2 = element("input");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { class: true });
			var form_nodes = children(form);
			input0 = claim_element(form_nodes, "INPUT", { id: true, name: true, type: true });
			t0 = claim_space(form_nodes);
			label0 = claim_element(form_nodes, "LABEL", {});
			var label0_nodes = children(label0);
			t1 = claim_text(label0_nodes, "Playlist Name");
			label0_nodes.forEach(detach_dev);
			br0 = claim_element(form_nodes, "BR", {});
			t2 = claim_space(form_nodes);
			input1 = claim_element(form_nodes, "INPUT", { id: true, name: true, type: true });
			t3 = claim_space(form_nodes);
			label1 = claim_element(form_nodes, "LABEL", {});
			var label1_nodes = children(label1);
			t4 = claim_text(label1_nodes, "Number Of Songs");
			label1_nodes.forEach(detach_dev);
			br1 = claim_element(form_nodes, "BR", {});
			t5 = claim_space(form_nodes);
			input2 = claim_element(form_nodes, "INPUT", { type: true, value: true });
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input0, "id", "plname");
			attr_dev(input0, "name", "plname");
			attr_dev(input0, "type", "text");
			add_location(input0, file, 38, 8, 1031);
			add_location(label0, file, 39, 8, 1087);
			add_location(br0, file, 39, 36, 1115);
			attr_dev(input1, "id", "plcount");
			attr_dev(input1, "name", "plcount");
			attr_dev(input1, "type", "text");
			add_location(input1, file, 40, 8, 1130);
			add_location(label1, file, 41, 8, 1188);
			add_location(br1, file, 41, 38, 1218);
			attr_dev(input2, "type", "submit");
			input2.value = "Add";
			add_location(input2, file, 42, 8, 1233);
			attr_dev(form, "class", "svelte-1wja0j");
			add_location(form, file, 37, 4, 974);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, input0);
			append_dev(form, t0);
			append_dev(form, label0);
			append_dev(label0, t1);
			append_dev(form, br0);
			append_dev(form, t2);
			append_dev(form, input1);
			append_dev(form, t3);
			append_dev(form, label1);
			append_dev(label1, t4);
			append_dev(form, br1);
			append_dev(form, t5);
			append_dev(form, input2);

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[2]), false, true, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(37:0) {#if radvisible}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*radvisible*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Add Random Playlist");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Add Random Playlist");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file, 34, 0, 895);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*randvis*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*radvisible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let radvisible = false;

	let randvis = () => {
		if (radvisible) {
			$$invalidate(0, radvisible = false);
		} else {
			$$invalidate(0, radvisible = true);
		}
	};

	let plname;
	let plcount;
	let playlists;

	async function handleSubmit(event) {
		$$invalidate(0, radvisible = false);
		plname = event.target.plname.value;
		plcount = event.target.plcount.value;
		let promise = getAddRandomPlaylist().catch(err => console.log(err));
	}

	async function getAddRandomPlaylist() {
		await fetch(`http://192.168.0.74:6790/AddRandomPlaylist?playlistname=${plname}&playlistcount=${plcount}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			playlists = data.plists;
			playliststore.set(playlists);
		}).catch(err => console.log(err));
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<AddRandomPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AddRandomPlaylist", $$slots, []);

	$$self.$capture_state = () => ({
		playliststore,
		radvisible,
		randvis,
		plname,
		plcount,
		playlists,
		handleSubmit,
		getAddRandomPlaylist
	});

	$$self.$inject_state = $$props => {
		if ("radvisible" in $$props) $$invalidate(0, radvisible = $$props.radvisible);
		if ("randvis" in $$props) $$invalidate(1, randvis = $$props.randvis);
		if ("plname" in $$props) plname = $$props.plname;
		if ("plcount" in $$props) plcount = $$props.plcount;
		if ("playlists" in $$props) playlists = $$props.playlists;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [radvisible, randvis, handleSubmit];
}

class AddRandomPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AddRandomPlaylist",
			options,
			id: create_fragment.name
		});
	}
}

/* src/components/PlaylistComps/AddEmptyPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$1 } = globals;
const file$1 = "src/components/PlaylistComps/AddEmptyPlaylist.svelte";

// (34:0) {#if visible}
function create_if_block$1(ctx) {
	let form;
	let input0;
	let t0;
	let label;
	let t1;
	let br;
	let t2;
	let input1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			input0 = element("input");
			t0 = space();
			label = element("label");
			t1 = text("Playlist Name");
			br = element("br");
			t2 = space();
			input1 = element("input");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", {});
			var form_nodes = children(form);

			input0 = claim_element(form_nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			t0 = claim_space(form_nodes);
			label = claim_element(form_nodes, "LABEL", {});
			var label_nodes = children(label);
			t1 = claim_text(label_nodes, "Playlist Name");
			label_nodes.forEach(detach_dev);
			br = claim_element(form_nodes, "BR", {});
			t2 = claim_space(form_nodes);
			input1 = claim_element(form_nodes, "INPUT", { type: true, value: true });
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input0, "id", "plname");
			attr_dev(input0, "name", "plname");
			attr_dev(input0, "type", "text");
			input0.value = "";
			add_location(input0, file$1, 35, 8, 987);
			add_location(label, file$1, 36, 8, 1051);
			add_location(br, file$1, 36, 36, 1079);
			attr_dev(input1, "type", "submit");
			input1.value = "Add";
			add_location(input1, file$1, 37, 8, 1094);
			add_location(form, file$1, 34, 4, 911);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, input0);
			append_dev(form, t0);
			append_dev(form, label);
			append_dev(label, t1);
			append_dev(form, br);
			append_dev(form, t2);
			append_dev(form, input1);

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*handleAddPlayListNameToDBSubmit*/ ctx[2]), false, true, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(34:0) {#if visible}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visible*/ ctx[0] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Add Empty Playlist");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Add Empty Playlist");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$1, 31, 0, 840);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuck*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let visible = false;

	let fuck = () => {
		if (visible) {
			$$invalidate(0, visible = false);
		} else {
			$$invalidate(0, visible = true);
		}
	};

	let newplname;

	async function handleAddPlayListNameToDBSubmit(event) {
		$$invalidate(0, visible = false);
		newplname = event.target.plname.value;
		let promise = getAddPlayListNameToDB().catch(err => console.log(err));
	}

	async function getAddPlayListNameToDB() {
		fetch(`http://192.168.0.74:6790/AddPlayListNameToDB?playlistname=${newplname}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			let pname = data.pnames;
			playliststore.set(pname);
		}).catch(err => console.log(err));
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<AddEmptyPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AddEmptyPlaylist", $$slots, []);

	$$self.$capture_state = () => ({
		text,
		playliststore,
		visible,
		fuck,
		newplname,
		handleAddPlayListNameToDBSubmit,
		getAddPlayListNameToDB
	});

	$$self.$inject_state = $$props => {
		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
		if ("fuck" in $$props) $$invalidate(1, fuck = $$props.fuck);
		if ("newplname" in $$props) newplname = $$props.newplname;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [visible, fuck, handleAddPlayListNameToDBSubmit];
}

class AddEmptyPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AddEmptyPlaylist",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/components/PlaylistComps/DeletePlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$2 } = globals;
const file$2 = "src/components/PlaylistComps/DeletePlaylist.svelte";

function create_fragment$2(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Delete");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { id: true, class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Delete");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", "delete");
			attr_dev(button, "class", "svelte-1le1i94");
			add_location(button, file$2, 18, 0, 518);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*deleteClick*/ ctx[0], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { PLID } = $$props;
	let NPL;

	async function getDeletePlaylistFromDB() {
		fetch(`http://192.168.0.:6789/DeletePlaylistFromDB?playlistid=${PLID}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			NPL = data.npl;
			playliststore.set(NPL);
		});
	}

	let deleteClick = () => {
		let promise = getDeletePlaylistFromDB().catch(err => console.log(err));
	};

	const writable_props = ["PLID"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<DeletePlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("DeletePlaylist", $$slots, []);

	$$self.$set = $$props => {
		if ("PLID" in $$props) $$invalidate(1, PLID = $$props.PLID);
	};

	$$self.$capture_state = () => ({
		playliststore,
		PLID,
		NPL,
		getDeletePlaylistFromDB,
		deleteClick
	});

	$$self.$inject_state = $$props => {
		if ("PLID" in $$props) $$invalidate(1, PLID = $$props.PLID);
		if ("NPL" in $$props) NPL = $$props.NPL;
		if ("deleteClick" in $$props) $$invalidate(0, deleteClick = $$props.deleteClick);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [deleteClick, PLID];
}

class DeletePlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { PLID: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DeletePlaylist",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*PLID*/ ctx[1] === undefined && !("PLID" in props)) {
			console_1$2.warn("<DeletePlaylist> was created without expected prop 'PLID'");
		}
	}

	get PLID() {
		throw new Error("<DeletePlaylist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set PLID(value) {
		throw new Error("<DeletePlaylist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PlaylistComps/LoadPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$3 } = globals;
const file$3 = "src/components/PlaylistComps/LoadPlaylist.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (39:0) {:else}
function create_else_block(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops no Playlist selected");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops no Playlist selected");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$3, 39, 4, 1087);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(39:0) {:else}",
		ctx
	});

	return block;
}

// (30:0) {#if PLID !== ""}
function create_if_block$2(ctx) {
	let each_1_anchor;
	let each_value = /*SONGS*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*SONGS*/ 2) {
				each_value = /*SONGS*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(30:0) {#if PLID !== \\\"\\\"}",
		ctx
	});

	return block;
}

// (31:4) {#each SONGS as s}
function create_each_block(ctx) {
	let div;
	let img;
	let img_src_value;
	let t0;
	let p0;
	let t1_value = /*s*/ ctx[4].artist + "";
	let t1;
	let t2;
	let p1;
	let t3_value = /*s*/ ctx[4].album + "";
	let t3;
	let t4;
	let p2;
	let t5_value = /*s*/ ctx[4].name + "";
	let t5;
	let t6;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			t0 = space();
			p0 = element("p");
			t1 = text(t1_value);
			t2 = space();
			p1 = element("p");
			t3 = text(t3_value);
			t4 = space();
			p2 = element("p");
			t5 = text(t5_value);
			t6 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
			t0 = claim_space(div_nodes);
			p0 = claim_element(div_nodes, "P", {});
			var p0_nodes = children(p0);
			t1 = claim_text(p0_nodes, t1_value);
			p0_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", {});
			var p1_nodes = children(p1);
			t3 = claim_text(p1_nodes, t3_value);
			p1_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			p2 = claim_element(div_nodes, "P", {});
			var p2_nodes = children(p2);
			t5 = claim_text(p2_nodes, t5_value);
			p2_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = /*s*/ ctx[4].thumbnail)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "fuck");
			attr_dev(img, "class", "svelte-rmqprw");
			add_location(img, file$3, 32, 12, 925);
			add_location(p0, file$3, 33, 12, 973);
			add_location(p1, file$3, 34, 12, 1003);
			add_location(p2, file$3, 35, 12, 1032);
			add_location(div, file$3, 31, 8, 907);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t0);
			append_dev(div, p0);
			append_dev(p0, t1);
			append_dev(div, t2);
			append_dev(div, p1);
			append_dev(p1, t3);
			append_dev(div, t4);
			append_dev(div, p2);
			append_dev(p2, t5);
			append_dev(div, t6);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*SONGS*/ 2 && img.src !== (img_src_value = /*s*/ ctx[4].thumbnail)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*SONGS*/ 2 && t1_value !== (t1_value = /*s*/ ctx[4].artist + "")) set_data_dev(t1, t1_value);
			if (dirty & /*SONGS*/ 2 && t3_value !== (t3_value = /*s*/ ctx[4].album + "")) set_data_dev(t3, t3_value);
			if (dirty & /*SONGS*/ 2 && t5_value !== (t5_value = /*s*/ ctx[4].name + "")) set_data_dev(t5, t5_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(31:4) {#each SONGS as s}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*PLID*/ ctx[0] !== "") return create_if_block$2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Load");
			t1 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { id: true });
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Load");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", "playlistLoadBtn");
			add_location(button, file$3, 27, 0, 785);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*handleLoadSubmit*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { PLID } = $$props;
	let SONGS = [];

	async function getCreatePlayerPlaylist() {
		let addr = `http://192.168.0.31:6789/CreatePlayerPlaylist?playlistid=${PLID}`;
		console.log(addr);

		await fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(1, SONGS = data.makePL);
			console.log(SONGS[0]);
		}).catch(err => console.log(err));
	}

	// async function handleLoadSubmit(event) {
	async function handleLoadSubmit() {
		// console.log(event.target.SONGS)
		// plname = event.target.plname.value;
		let promise = getCreatePlayerPlaylist().catch(err => console.log(err));

		console.log("this is songs from loadplaylist page");
		console.log(SONGS);
	}

	const writable_props = ["PLID"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<LoadPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LoadPlaylist", $$slots, []);

	$$self.$set = $$props => {
		if ("PLID" in $$props) $$invalidate(0, PLID = $$props.PLID);
	};

	$$self.$capture_state = () => ({
		PLID,
		SONGS,
		getCreatePlayerPlaylist,
		handleLoadSubmit
	});

	$$self.$inject_state = $$props => {
		if ("PLID" in $$props) $$invalidate(0, PLID = $$props.PLID);
		if ("SONGS" in $$props) $$invalidate(1, SONGS = $$props.SONGS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [PLID, SONGS, handleLoadSubmit];
}

class LoadPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { PLID: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadPlaylist",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*PLID*/ ctx[0] === undefined && !("PLID" in props)) {
			console_1$3.warn("<LoadPlaylist> was created without expected prop 'PLID'");
		}
	}

	get PLID() {
		throw new Error("<LoadPlaylist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set PLID(value) {
		throw new Error("<LoadPlaylist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PlaylistComps/EditPlaylist.svelte generated by Svelte v3.24.0 */

const { console: console_1$4 } = globals;
const file$4 = "src/components/PlaylistComps/EditPlaylist.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (38:0) {#if editvisible}
function create_if_block$3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*songlist_count*/ ctx[1] > 1) return create_if_block_1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(38:0) {#if editvisible}",
		ctx
	});

	return block;
}

// (48:4) {:else}
function create_else_block$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops zero songs");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops zero songs");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$4, 48, 8, 1269);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(48:4) {:else}",
		ctx
	});

	return block;
}

// (39:4) {#if songlist_count > 1}
function create_if_block_1(ctx) {
	let t0;
	let button;
	let t1;
	let mounted;
	let dispose;
	let each_value = /*songlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			button = element("button");
			t1 = text("Complete");
			this.h();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			t0 = claim_space(nodes);
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t1 = claim_text(button_nodes, "Complete");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 46, 8, 1207);
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			insert_dev(target, button, anchor);
			append_dev(button, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*edvi*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*songlist*/ 1) {
				each_value = /*songlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(t0.parentNode, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(39:4) {#if songlist_count > 1}",
		ctx
	});

	return block;
}

// (40:8) {#each songlist as song}
function create_each_block$1(ctx) {
	let ul;
	let li;
	let p;
	let t0_value = /*song*/ ctx[7][0] + "";
	let t0;
	let button;
	let t1;
	let p_id_value;

	const block = {
		c: function create() {
			ul = element("ul");
			li = element("li");
			p = element("p");
			t0 = text(t0_value);
			button = element("button");
			t1 = text("Remove");
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li = claim_element(ul_nodes, "LI", {});
			var li_nodes = children(li);
			p = claim_element(li_nodes, "P", { id: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, t0_value);
			button = claim_element(p_nodes, "BUTTON", { id: true, class: true });
			var button_nodes = children(button);
			t1 = claim_text(button_nodes, "Remove");
			button_nodes.forEach(detach_dev);
			p_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", "removeBtn");
			attr_dev(button, "class", "svelte-1bwgj62");
			add_location(button, file$4, 42, 45, 1100);
			attr_dev(p, "id", p_id_value = /*song*/ ctx[7][1]);
			add_location(p, file$4, 42, 20, 1075);
			add_location(li, file$4, 41, 16, 1050);
			attr_dev(ul, "class", "svelte-1bwgj62");
			add_location(ul, file$4, 40, 12, 1029);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			append_dev(ul, li);
			append_dev(li, p);
			append_dev(p, t0);
			append_dev(p, button);
			append_dev(button, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*songlist*/ 1 && t0_value !== (t0_value = /*song*/ ctx[7][0] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*songlist*/ 1 && p_id_value !== (p_id_value = /*song*/ ctx[7][1])) {
				attr_dev(p, "id", p_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(40:8) {#each songlist as song}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*editvisible*/ ctx[2] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Edit");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Edit");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 36, 0, 869);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*handleAllPlaylistSongsFromDBSubmit*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*editvisible*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { PLID } = $$props;

	let handleAllPlaylistSongsFromDBSubmit = () => {
		$$invalidate(2, editvisible = true);
		let promise = getAllPlaylistSongsFromDB().catch(err => console.log(err));
	};

	let songlist;
	let songlist_count;

	async function getAllPlaylistSongsFromDB() {
		fetch(`http://192.168.0.31:6789/AllPlaylistSongsFromDB?playlistid=${PLID}`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, songlist = data.taz);
			$$invalidate(1, songlist_count = songlist.length);
		}).catch(err => console.log(err));
	}

	let editvisible = true;

	let edvi = () => {
		if (editvisible) {
			$$invalidate(2, editvisible = false);
		} else {
			$$invalidate(2, editvisible = true);
		}
	};

	const writable_props = ["PLID"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<EditPlaylist> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("EditPlaylist", $$slots, []);

	$$self.$set = $$props => {
		if ("PLID" in $$props) $$invalidate(5, PLID = $$props.PLID);
	};

	$$self.$capture_state = () => ({
		PLID,
		handleAllPlaylistSongsFromDBSubmit,
		songlist,
		songlist_count,
		getAllPlaylistSongsFromDB,
		editvisible,
		edvi
	});

	$$self.$inject_state = $$props => {
		if ("PLID" in $$props) $$invalidate(5, PLID = $$props.PLID);
		if ("handleAllPlaylistSongsFromDBSubmit" in $$props) $$invalidate(3, handleAllPlaylistSongsFromDBSubmit = $$props.handleAllPlaylistSongsFromDBSubmit);
		if ("songlist" in $$props) $$invalidate(0, songlist = $$props.songlist);
		if ("songlist_count" in $$props) $$invalidate(1, songlist_count = $$props.songlist_count);
		if ("editvisible" in $$props) $$invalidate(2, editvisible = $$props.editvisible);
		if ("edvi" in $$props) $$invalidate(4, edvi = $$props.edvi);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		songlist,
		songlist_count,
		editvisible,
		handleAllPlaylistSongsFromDBSubmit,
		edvi,
		PLID
	];
}

class EditPlaylist extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { PLID: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditPlaylist",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*PLID*/ ctx[5] === undefined && !("PLID" in props)) {
			console_1$4.warn("<EditPlaylist> was created without expected prop 'PLID'");
		}
	}

	get PLID() {
		throw new Error("<EditPlaylist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set PLID(value) {
		throw new Error("<EditPlaylist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/PlaylistList.svelte generated by Svelte v3.24.0 */
const file$5 = "src/components/PlaylistList.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (62:12) {:else}
function create_else_block_1(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(62:12) {:else}",
		ctx
	});

	return block;
}

// (60:34) 
function create_if_block_3(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops no playlists found");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops no playlists found");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 60, 16, 1888);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(60:34) ",
		ctx
	});

	return block;
}

// (53:12) {#if PLCOUNT > 1}
function create_if_block_2(ctx) {
	let each_1_anchor;
	let each_value_1 = /*PLNAMES*/ ctx[1];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PLNAMES, plid*/ 3) {
				each_value_1 = /*PLNAMES*/ ctx[1];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(53:12) {#if PLCOUNT > 1}",
		ctx
	});

	return block;
}

// (54:16) {#each PLNAMES as pln}
function create_each_block_1(ctx) {
	let li;
	let label;
	let t0_value = /*pln*/ ctx[12][0] + "";
	let t0;
	let label_for_value;
	let t1;
	let input;
	let input_id_value;
	let input_name_value;
	let input_value_value;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			label = element("label");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			label = claim_element(li_nodes, "LABEL", { for: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, t0_value);
			label_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);

			input = claim_element(li_nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", label_for_value = /*pln*/ ctx[12][1]);
			add_location(label, file$5, 55, 24, 1646);
			attr_dev(input, "id", input_id_value = /*pln*/ ctx[12][1]);
			attr_dev(input, "name", input_name_value = /*pln*/ ctx[12][1]);
			attr_dev(input, "type", "radio");
			input.__value = input_value_value = /*pln*/ ctx[12][1];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[6][0].push(input);
			add_location(input, file$5, 56, 24, 1707);
			add_location(li, file$5, 54, 20, 1617);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, label);
			append_dev(label, t0);
			append_dev(li, t1);
			append_dev(li, input);
			input.checked = input.__value === /*plid*/ ctx[0];
			append_dev(li, t2);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PLNAMES*/ 2 && t0_value !== (t0_value = /*pln*/ ctx[12][0] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*PLNAMES*/ 2 && label_for_value !== (label_for_value = /*pln*/ ctx[12][1])) {
				attr_dev(label, "for", label_for_value);
			}

			if (dirty & /*PLNAMES*/ 2 && input_id_value !== (input_id_value = /*pln*/ ctx[12][1])) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty & /*PLNAMES*/ 2 && input_name_value !== (input_name_value = /*pln*/ ctx[12][1])) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty & /*PLNAMES*/ 2 && input_value_value !== (input_value_value = /*pln*/ ctx[12][1])) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*plid*/ 1) {
				input.checked = input.__value === /*plid*/ ctx[0];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			/*$$binding_groups*/ ctx[6][0].splice(/*$$binding_groups*/ ctx[6][0].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(54:16) {#each PLNAMES as pln}",
		ctx
	});

	return block;
}

// (76:12) {:else}
function create_else_block$2(ctx) {
	let p;
	let t0;
	let t1_value = /*PPLNAMES*/ ctx[3][0]["playlistid"] + "";
	let t1;
	let t2;
	let label;
	let t3_value = /*PPLNAMES*/ ctx[3][0]["playlistname"] + "";
	let t3;
	let label_for_value;
	let t4;
	let input;
	let input_id_value;
	let input_name_value;
	let input_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("this is pplnames: ");
			t1 = text(t1_value);
			t2 = space();
			label = element("label");
			t3 = text(t3_value);
			t4 = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "this is pplnames: ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			label = claim_element(nodes, "LABEL", { for: true });
			var label_nodes = children(label);
			t3 = claim_text(label_nodes, t3_value);
			label_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);

			input = claim_element(nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 76, 12, 2678);
			attr_dev(label, "for", label_for_value = /*PPLNAMES*/ ctx[3][0]["playlistid"]);
			add_location(label, file$5, 77, 16, 2747);
			attr_dev(input, "id", input_id_value = /*PPLNAMES*/ ctx[3][0]["playlistid"]);
			attr_dev(input, "name", input_name_value = /*PPLNAMES*/ ctx[3][0]["playlistname"]);
			attr_dev(input, "type", "radio");
			input.__value = input_value_value = /*PPLNAMES*/ ctx[3][0]["playlistname"];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[6][0].push(input);
			add_location(input, file$5, 78, 16, 2840);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, label, anchor);
			append_dev(label, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, input, anchor);
			input.checked = input.__value === /*plid*/ ctx[0];

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler_2*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PPLNAMES*/ 8 && t1_value !== (t1_value = /*PPLNAMES*/ ctx[3][0]["playlistid"] + "")) set_data_dev(t1, t1_value);
			if (dirty & /*PPLNAMES*/ 8 && t3_value !== (t3_value = /*PPLNAMES*/ ctx[3][0]["playlistname"] + "")) set_data_dev(t3, t3_value);

			if (dirty & /*PPLNAMES*/ 8 && label_for_value !== (label_for_value = /*PPLNAMES*/ ctx[3][0]["playlistid"])) {
				attr_dev(label, "for", label_for_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_id_value !== (input_id_value = /*PPLNAMES*/ ctx[3][0]["playlistid"])) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_name_value !== (input_name_value = /*PPLNAMES*/ ctx[3][0]["playlistname"])) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_value_value !== (input_value_value = /*PPLNAMES*/ ctx[3][0]["playlistname"])) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*plid*/ 1) {
				input.checked = input.__value === /*plid*/ ctx[0];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(label);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(input);
			/*$$binding_groups*/ ctx[6][0].splice(/*$$binding_groups*/ ctx[6][0].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(76:12) {:else}",
		ctx
	});

	return block;
}

// (74:35) 
function create_if_block_1$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Whoops no playlists found");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Whoops no playlists found");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 74, 16, 2613);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(74:35) ",
		ctx
	});

	return block;
}

// (67:12) {#if PPLCOUNT > 1}
function create_if_block$4(ctx) {
	let each_1_anchor;
	let each_value = /*PPLNAMES*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PPLNAMES, plid*/ 9) {
				each_value = /*PPLNAMES*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(67:12) {#if PPLCOUNT > 1}",
		ctx
	});

	return block;
}

// (68:16) {#each PPLNAMES as pln}
function create_each_block$2(ctx) {
	let li;
	let label;
	let t0_value = /*pln*/ ctx[12]["playlistname"] + "";
	let t0;
	let label_for_value;
	let t1;
	let input;
	let input_id_value;
	let input_name_value;
	let input_value_value;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			label = element("label");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			label = claim_element(li_nodes, "LABEL", { for: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, t0_value);
			label_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);

			input = claim_element(li_nodes, "INPUT", {
				id: true,
				name: true,
				type: true,
				value: true
			});

			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", label_for_value = /*pln*/ ctx[12]["playlistid"]);
			add_location(label, file$5, 69, 24, 2312);
			attr_dev(input, "id", input_id_value = /*pln*/ ctx[12]["playlistid"]);
			attr_dev(input, "name", input_name_value = /*pln*/ ctx[12]["playlistid"]);
			attr_dev(input, "type", "radio");
			input.__value = input_value_value = /*pln*/ ctx[12]["playlistid"];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[6][0].push(input);
			add_location(input, file$5, 70, 24, 2397);
			add_location(li, file$5, 68, 20, 2283);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, label);
			append_dev(label, t0);
			append_dev(li, t1);
			append_dev(li, input);
			input.checked = input.__value === /*plid*/ ctx[0];
			append_dev(li, t2);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler_1*/ ctx[7]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*PPLNAMES*/ 8 && t0_value !== (t0_value = /*pln*/ ctx[12]["playlistname"] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*PPLNAMES*/ 8 && label_for_value !== (label_for_value = /*pln*/ ctx[12]["playlistid"])) {
				attr_dev(label, "for", label_for_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_id_value !== (input_id_value = /*pln*/ ctx[12]["playlistid"])) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_name_value !== (input_name_value = /*pln*/ ctx[12]["playlistid"])) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty & /*PPLNAMES*/ 8 && input_value_value !== (input_value_value = /*pln*/ ctx[12]["playlistid"])) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*plid*/ 1) {
				input.checked = input.__value === /*plid*/ ctx[0];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			/*$$binding_groups*/ ctx[6][0].splice(/*$$binding_groups*/ ctx[6][0].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(68:16) {#each PPLNAMES as pln}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let p;
	let t0;
	let t1;
	let t2;
	let form;
	let ul;
	let t3;
	let t4;
	let nav;
	let loadplaylist;
	let t5;
	let deleteplaylist;
	let t6;
	let editplaylist;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*PLCOUNT*/ ctx[2] > 1) return create_if_block_2;
		if (/*PLCOUNT*/ ctx[2] < 1) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*PPLCOUNT*/ ctx[4] > 1) return create_if_block$4;
		if (/*PPLCOUNT*/ ctx[4] < 1) return create_if_block_1$1;
		return create_else_block$2;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1(ctx);

	loadplaylist = new LoadPlaylist({
			props: { PLID: /*plid*/ ctx[0] },
			$$inline: true
		});

	deleteplaylist = new DeletePlaylist({
			props: { PLID: /*plid*/ ctx[0] },
			$$inline: true
		});

	editplaylist = new EditPlaylist({
			props: { PLID: /*plid*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			p = element("p");
			t0 = text("Currently selected playlist: ");
			t1 = text(/*plid*/ ctx[0]);
			t2 = space();
			form = element("form");
			ul = element("ul");
			if_block0.c();
			t3 = space();
			if_block1.c();
			t4 = space();
			nav = element("nav");
			create_component(loadplaylist.$$.fragment);
			t5 = space();
			create_component(deleteplaylist.$$.fragment);
			t6 = space();
			create_component(editplaylist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			p = claim_element(div_nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "Currently selected playlist: ");
			t1 = claim_text(p_nodes, /*plid*/ ctx[0]);
			p_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			form = claim_element(div_nodes, "FORM", {});
			var form_nodes = children(form);
			ul = claim_element(form_nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if_block0.l(ul_nodes);
			t3 = claim_space(ul_nodes);
			if_block1.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(loadplaylist.$$.fragment, nav_nodes);
			t5 = claim_space(nav_nodes);
			claim_component(deleteplaylist.$$.fragment, nav_nodes);
			t6 = claim_space(nav_nodes);
			claim_component(editplaylist.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$5, 49, 4, 1461);
			attr_dev(ul, "class", "svelte-hk3op");
			add_location(ul, file$5, 51, 8, 1523);
			add_location(form, file$5, 50, 4, 1508);
			add_location(div, file$5, 48, 0, 1451);
			attr_dev(nav, "class", "svelte-hk3op");
			add_location(nav, file$5, 84, 0, 3033);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, p);
			append_dev(p, t0);
			append_dev(p, t1);
			append_dev(div, t2);
			append_dev(div, form);
			append_dev(form, ul);
			if_block0.m(ul, null);
			append_dev(ul, t3);
			if_block1.m(ul, null);
			insert_dev(target, t4, anchor);
			insert_dev(target, nav, anchor);
			mount_component(loadplaylist, nav, null);
			append_dev(nav, t5);
			mount_component(deleteplaylist, nav, null);
			append_dev(nav, t6);
			mount_component(editplaylist, nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*plid*/ 1) set_data_dev(t1, /*plid*/ ctx[0]);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(ul, t3);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(ul, null);
				}
			}

			const loadplaylist_changes = {};
			if (dirty & /*plid*/ 1) loadplaylist_changes.PLID = /*plid*/ ctx[0];
			loadplaylist.$set(loadplaylist_changes);
			const deleteplaylist_changes = {};
			if (dirty & /*plid*/ 1) deleteplaylist_changes.PLID = /*plid*/ ctx[0];
			deleteplaylist.$set(deleteplaylist_changes);
			const editplaylist_changes = {};
			if (dirty & /*plid*/ 1) editplaylist_changes.PLID = /*plid*/ ctx[0];
			editplaylist.$set(editplaylist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadplaylist.$$.fragment, local);
			transition_in(deleteplaylist.$$.fragment, local);
			transition_in(editplaylist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadplaylist.$$.fragment, local);
			transition_out(deleteplaylist.$$.fragment, local);
			transition_out(editplaylist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block0.d();
			if_block1.d();
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(nav);
			destroy_component(loadplaylist);
			destroy_component(deleteplaylist);
			destroy_component(editplaylist);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let plid = "";
	let PLNAMES;
	let PLCOUNT = 0;

	onMount(async function getAllPlaylists() {
		fetch(`http://192.168.0.74:6790/AllPlaylists`, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			let cunt = [];
			let voo;

			let moo = data.plnames.map(da => {
				voo = { playlistname: da[0], playlistid: da[1] };
				cunt.push(voo);
			});

			$$invalidate(1, PLNAMES = cunt);
			playliststore.set(PLNAMES);
			playlistidstore.set(plid);

			if (PLNAMES != undefined) {
				$$invalidate(2, PLCOUNT = PLNAMES.length);
			}
		});
	});

	let PPLNAMES;
	let PPLCOUNT;

	const unsubscribe = playliststore.subscribe(value => {
		$$invalidate(1, PLNAMES = undefined);
		$$invalidate(2, PLCOUNT = undefined);
		$$invalidate(3, PPLNAMES = value);
		$$invalidate(4, PPLCOUNT = PPLNAMES.length);
	});

	let playlistidstore_value;

	const unsubplid = playlistidstore.subscribe(value => {
		playlistidstore_value = value;
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PlaylistList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("PlaylistList", $$slots, []);
	const $$binding_groups = [[]];

	function input_change_handler() {
		plid = this.__value;
		$$invalidate(0, plid);
	}

	function input_change_handler_1() {
		plid = this.__value;
		$$invalidate(0, plid);
	}

	function input_change_handler_2() {
		plid = this.__value;
		$$invalidate(0, plid);
	}

	$$self.$capture_state = () => ({
		DeletePlaylist,
		LoadPlaylist,
		EditPlaylist,
		playliststore,
		playlistidstore,
		onMount,
		plid,
		PLNAMES,
		PLCOUNT,
		PPLNAMES,
		PPLCOUNT,
		unsubscribe,
		playlistidstore_value,
		unsubplid
	});

	$$self.$inject_state = $$props => {
		if ("plid" in $$props) $$invalidate(0, plid = $$props.plid);
		if ("PLNAMES" in $$props) $$invalidate(1, PLNAMES = $$props.PLNAMES);
		if ("PLCOUNT" in $$props) $$invalidate(2, PLCOUNT = $$props.PLCOUNT);
		if ("PPLNAMES" in $$props) $$invalidate(3, PPLNAMES = $$props.PPLNAMES);
		if ("PPLCOUNT" in $$props) $$invalidate(4, PPLCOUNT = $$props.PPLCOUNT);
		if ("playlistidstore_value" in $$props) playlistidstore_value = $$props.playlistidstore_value;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		plid,
		PLNAMES,
		PLCOUNT,
		PPLNAMES,
		PPLCOUNT,
		input_change_handler,
		$$binding_groups,
		input_change_handler_1,
		input_change_handler_2
	];
}

class PlaylistList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PlaylistList",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/components/PlaylistComps/AudioPlayer.svelte generated by Svelte v3.24.0 */

const file$6 = "src/components/PlaylistComps/AudioPlayer.svelte";

function create_fragment$6(ctx) {
	let div0;
	let audio;
	let audio_src_value;
	let t0;
	let div2;
	let div1;
	let ol;
	let li0;
	let a0;
	let t1;
	let t2;
	let li1;
	let a1;
	let t3;

	const block = {
		c: function create() {
			div0 = element("div");
			audio = element("audio");
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			ol = element("ol");
			li0 = element("li");
			a0 = element("a");
			t1 = text("Boo1");
			t2 = space();
			li1 = element("li");
			a1 = element("a");
			t3 = text("Boo2");
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", {
				class: true,
				"data-url": true,
				"data-title": true
			});

			var div0_nodes = children(div0);
			audio = claim_element(div0_nodes, "AUDIO", { src: true, controls: true, class: true });
			children(audio).forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			ol = claim_element(div1_nodes, "OL", { class: true });
			var ol_nodes = children(ol);
			li0 = claim_element(ol_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			a0 = claim_element(li0_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);
			t1 = claim_text(a0_nodes, "Boo1");
			a0_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t2 = claim_space(ol_nodes);
			li1 = claim_element(ol_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			a1 = claim_element(li1_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			t3 = claim_text(a1_nodes, "Boo2");
			a1_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			ol_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (audio.src !== (audio_src_value = "")) attr_dev(audio, "src", audio_src_value);
			audio.controls = true;
			attr_dev(audio, "class", "svelte-1fl1oc6");
			add_location(audio, file$6, 274, 4, 14037);
			attr_dev(div0, "class", "player-wrap svelte-1fl1oc6");
			attr_dev(div0, "data-url", "boo1.mp3");
			attr_dev(div0, "data-title", "Boo1");
			add_location(div0, file$6, 273, 0, 13968);
			attr_dev(a0, "href", "boo1.mp3");
			attr_dev(a0, "class", "svelte-1fl1oc6");
			add_location(a0, file$6, 281, 7, 14128);
			attr_dev(li0, "class", "svelte-1fl1oc6");
			add_location(li0, file$6, 281, 3, 14124);
			attr_dev(a1, "href", "boo2.mp3");
			attr_dev(a1, "class", "svelte-1fl1oc6");
			add_location(a1, file$6, 282, 7, 14168);
			attr_dev(li1, "class", "svelte-1fl1oc6");
			add_location(li1, file$6, 282, 3, 14164);
			attr_dev(ol, "class", "svelte-1fl1oc6");
			add_location(ol, file$6, 280, 2, 14116);
			attr_dev(div1, "class", "playlist-wrap svelte-1fl1oc6");
			add_location(div1, file$6, 279, 1, 14086);
			attr_dev(div2, "class", "svelte-1fl1oc6");
			add_location(div2, file$6, 278, 0, 14079);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, audio);
			insert_dev(target, t0, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, ol);
			append_dev(ol, li0);
			append_dev(li0, a0);
			append_dev(a0, t1);
			append_dev(ol, t2);
			append_dev(ol, li1);
			append_dev(li1, a1);
			append_dev(a1, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let jsPlayer = document.querySelector(".player-wrap");

	if (jsPlayer) {
		jsPlayer = {
			wrap: jsPlayer,
			player: jsPlayer.querySelector("audio"),
			//         player: (jsPlayer.querySelector('audio') || { play: function(){}, pause: function(){} }),
			//         play: (jsPlayer.querySelector('.play') || {}),
			//         pause: (jsPlayer.querySelector('.pause') || {}),
			//         seek: (jsPlayer.querySelector('.seek') || {}),
			//         prev: (jsPlayer.querySelector('.prev') || {}),
			next: jsPlayer.querySelector(".next") || {},
			//         button: (jsPlayer.querySelector('.button') || { style: {} }),
			//         wrapList: (document.querySelector('.playlist-wrap') || {}),
			//         action: (jsPlayer.querySelector('.action') || {}),
			//         title: (jsPlayer.querySelector('.title') || {}),
			//         current: (jsPlayer.querySelector('.current') || {}),
			//         duration: (jsPlayer.querySelector('.duration') || {}),
			trackCount: 0,
			//     seeking: null,
			playing: false,
			tracks: [],
			track: [],
			idx: 0
		};

		//     jsPlayer.playClicked = function jsPlayerPlayClicked(){
		//         jsPlayer.button.style.visibility = 'hidden';
		//         jsPlayer.pause.style.display = 'block';
		//         jsPlayer.play.style.display = 'none';
		//         jsPlayer.playing = true;
		//         jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//         jsPlayer.player.play();
		//         jsPlayer.updateSeek();
		//     };
		//     jsPlayer.pauseClicked = function jsPlayerPauseClicked(){
		//         jsPlayer.play.style.display = 'block';
		//         jsPlayer.pause.style.display = 'none';
		//         clearTimeout(jsPlayer.seeking);
		//         jsPlayer.playing = false;
		//         jsPlayer.action.innerHTML = 'Paused&hellip;';
		//         jsPlayer.player.pause();
		//     };
		//     jsPlayer.loadPlaylist = function jaPlayerLoadPlaylist(){
		//         jsPlayer.playlist = jsPlayer.wrapList? jsPlayer.wrapList.querySelectorAll('ol > li') : [];
		//         var len = jsPlayer.playlist.length,
		//             tmp, i;
		//         for (i = 0; i < len; i++) {
		//             if (!jsPlayer.playlist[i].dataset) {
		//                 jsPlayer.playlist[i].dataset = {};
		//             }
		//             tmp = jsPlayer.playlist[i].querySelector('a');
		//             if (tmp && !jsPlayer.playlist[i].dataset.idx) {
		//                 jsPlayer.playlist[i].dataset.idx = i + 1;
		//                 jsPlayer.trackCount++;
		//                 jsPlayer.tracks.push({
		//                     "file": tmp.href,
		//                     "name": (tmp.textContent || tmp.innerText).replace(/^\s+|\s+$/g, ''),
		//                     "track": i + 1
		//                 });
		//             }
		//         }
		//     };
		//     jsPlayer.loadTrack = function jsPlayerLoadTrack(idx){
		//         var len = jsPlayer.playlist.length,
		//             i;
		//         for (i=0; i < len; i++) {
		//             if (jsPlayer.playlist[i].classList) {
		//                 if (i === idx) {
		//                     jsPlayer.playlist[i].classList.add('sel');
		//                 } else {
		//                     jsPlayer.playlist[i].classList.remove('sel');
		//                 }
		//             }
		//         }
		//         jsPlayer.title.innerHTML = jsPlayer.tracks[idx].name;
		//         jsPlayer.player.src = jsPlayer.tracks[idx].file + '.mp3';
		//     };
		//     jsPlayer.playTrack = function jsPlayerPlayTrack(idx){
		//         jsPlayer.loadTrack(idx);
		//         jsPlayer.playing = true;
		//         jsPlayer.playClicked();
		//     };
		jsPlayer.init = function jsPlayerInit() {
			var track = jsPlayer.wrap && jsPlayer.wrap.dataset && jsPlayer.wrap.dataset.url
				? jsPlayer.wrap
				: null;
		}; //         if (!!document.createElement('audio').canPlayType('audio/mpeg')) {
		//             if (jsPlayer.wrapList && jsPlayer.wrapList.querySelectorAll('ol > li').length > 0) {
		//                 jsPlayer.loadPlaylist();
		//             } else if (track) {

		//                 jsPlayer.tracks = [{
		//                     "file": track.dataset.url,
		//                     "name": (track.dataset.title || ''),
		//                     "track": 1
		//                 }];
		//             }
		//             if (jsPlayer.tracks.length > 0) {
		//                 if (jsPlayer.player) {
		//                     jsPlayer.player.addEventListener('ended', function playerEnded(){
		//                         if (jsPlayer.idx + 1 < jsPlayer.trackCount) {
		//                             jsPlayer.idx++;
		//                             jsPlayer.playTrack(jsPlayer.idx);
		//                         } else {
		//                             jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                             jsPlayer.player.pause();
		//                             jsPlayer.idx = 0;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                         }
		//                     }, true);
		//                     jsPlayer.player.addEventListener('loadeddata', function playerLoadeddata(){
		//                         jsPlayer.setDuration();
		//                     }, true);
		//                 }
		//                 if (jsPlayer.play) {
		//                     jsPlayer.play.addEventListener('click', jsPlayer.playClicked, true);
		//                 }
		//                 if (jsPlayer.pause) {
		//                     jsPlayer.pause.addEventListener('click', jsPlayer.pauseClicked, true);
		//                 }
		//                 if (jsPlayer.button) {
		//                     jsPlayer.button.addEventListener('click', function buttonClicked(event){
		//                         event.preventDefault();
		//                         jsPlayer.playClicked();
		//                     }, true);
		//                 }
		//                 if (jsPlayer.prev) {
		//                     jsPlayer.prev.addEventListener('click', function prevClicked(event){
		//                         event.preventDefault();
		//                         if (jsPlayer.idx - 1 > -1) {
		//                             jsPlayer.idx--;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                             if (jsPlayer.playing) {
		//                                 jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//                                 jsPlayer.player.play();
		//                             }
		//                         } else {
		//                             jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                             jsPlayer.playing = false;
		//                             jsPlayer.player.pause();
		//                             jsPlayer.idx = 0;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                         }
		//                     }, true);
		//                 }
		//                 if (jsPlayer.next) {
		//                     jsPlayer.next.addEventListener('click', function nextClicked(event){
		//                         event.preventDefault();
		//                         if (jsPlayer.idx + 1 < jsPlayer.trackCount) {
		//                             jsPlayer.idx++;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                             if (jsPlayer.playing) {
		//                                 jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//                                 jsPlayer.player.play();
		//                             }
		//                         } else {
		//                             jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                             jsPlayer.playing = false;
		//                             jsPlayer.player.pause();
		//                             jsPlayer.idx = 0;
		//                             jsPlayer.loadTrack(jsPlayer.idx);
		//                         }
		//                     }, true);
		//                 }
		//                 if (jsPlayer.seek) {
		//                     jsPlayer.seek.addEventListener('mousedown', function seekClicked(){
		//                         clearTimeout(jsPlayer.seeking);
		//                         jsPlayer.action.innerHTML = 'Paused&hellip;';
		//                         jsPlayer.player.pause();
		//                     }, true);
		//                     jsPlayer.seek.addEventListener('mouseup', function seekReleased(){
		//                         jsPlayer.player.currentTime = jsPlayer.seek.value * jsPlayer.player.duration / 100;
		//                         jsPlayer.updateSeek();
		//                         if (jsPlayer.playing) {
		//                             jsPlayer.action.innerHTML = 'Now Playing&hellip;';
		//                             jsPlayer.player.play();
		//                         }
		//                     }, true);
		//                 }
		//                 if (jsPlayer.wrapList) {
		//                     jsPlayer.wrapList.addEventListener('click', function listClicked(event){
		//                         var parent = event.target.parentNode;
		//                         if (parent.parentNode.tagName.toLowerCase() === 'ol') {
		//                             event.preventDefault();
		//                             var len = jsPlayer.playlist.length,
		//                             i;
		//                             for (i = 0; i < len; i++) {
		//                                 if (parent.dataset.idx == i + 1) {
		//                                     jsPlayer.idx = i;
		//                                     jsPlayer.playTrack(jsPlayer.idx);
		//                                     i = len;
		//                                 }
		//                             }
		//                         }
		//                     }, true);
		//                 }
		//                 jsPlayer.setDuration = function setDuration() {
		//                     jsPlayer.duration.innerHTML = jsPlayer.formatTime(jsPlayer.player.duration);
		//                     jsPlayer.current.innerHTML = jsPlayer.formatTime(jsPlayer.player.currentTime);
		//                     jsPlayer.seek.value = jsPlayer.player.currentTime / jsPlayer.player.duration;
		//                 };
		//                 jsPlayer.updateSeek = function updateSeek() {
		//                     jsPlayer.seek.value = 100 * jsPlayer.player.currentTime / jsPlayer.player.duration;
		//                     jsPlayer.current.innerHTML = jsPlayer.formatTime(jsPlayer.player.currentTime);
		//                     if (jsPlayer.playing) {
		//                         jsPlayer.seeking = setTimeout(jsPlayer.updateSeek, 500);
		//                     }
		//                 };
		//                 jsPlayer.formatTime = function formatTime(val) {
		//                     var h = 0, m = 0, s;
		//                     val = parseInt(val, 10);
		//                     if (val > 60 * 60) {
		//                         h = parseInt(val / (60 * 60), 10);
		//                         val -= h * 60 * 60;
		//                     }
		//                     if (val > 60) {
		//                         m = parseInt(val / 60, 10);
		//                         val -= m * 60;
		//                     }
		//                     s = val;
		//                     val = (h > 0)? h + ':' : '';
		//                     val += (m > 0)? ((m < 10 && h > 0)? '0' : '') + m + ':' : '0:';
		//                     val += ((s < 10)? '0' : '') + s;
		//                     return val;
		//                 };
		//             }
		//         }
		//         if (jsPlayer.tracks.length > 0) {
		//             jsPlayer.wrap.className += ' enabled';
		//             jsPlayer.loadTrack(jsPlayer.idx);
		//         }
		jsPlayer.init();
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AudioPlayer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AudioPlayer", $$slots, []);
	$$self.$capture_state = () => ({ jsPlayer });

	$$self.$inject_state = $$props => {
		if ("jsPlayer" in $$props) jsPlayer = $$props.jsPlayer;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [];
}

class AudioPlayer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AudioPlayer",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/playlists.svelte generated by Svelte v3.24.0 */

const file$7 = "src/routes/playlists.svelte";

function create_fragment$7(ctx) {
	let t0;
	let h2;
	let t1;
	let t2;
	let addrandomplaylist;
	let t3;
	let addemptyplaylist;
	let t4;
	let playlistlist;
	let t5;
	let audioplayer;
	let current;
	addrandomplaylist = new AddRandomPlaylist({ $$inline: true });
	addemptyplaylist = new AddEmptyPlaylist({ $$inline: true });
	playlistlist = new PlaylistList({ $$inline: true });
	audioplayer = new AudioPlayer({ $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			h2 = element("h2");
			t1 = text("Playlists");
			t2 = space();
			create_component(addrandomplaylist.$$.fragment);
			t3 = space();
			create_component(addemptyplaylist.$$.fragment);
			t4 = space();
			create_component(playlistlist.$$.fragment);
			t5 = space();
			create_component(audioplayer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-kgurgq\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Playlists");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			claim_component(addrandomplaylist.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(addemptyplaylist.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(playlistlist.$$.fragment, nodes);
			t5 = claim_space(nodes);
			claim_component(audioplayer.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Playlists";
			add_location(h2, file$7, 15, 0, 506);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, h2, anchor);
			append_dev(h2, t1);
			insert_dev(target, t2, anchor);
			mount_component(addrandomplaylist, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(addemptyplaylist, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(playlistlist, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(audioplayer, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(addrandomplaylist.$$.fragment, local);
			transition_in(addemptyplaylist.$$.fragment, local);
			transition_in(playlistlist.$$.fragment, local);
			transition_in(audioplayer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(addrandomplaylist.$$.fragment, local);
			transition_out(addemptyplaylist.$$.fragment, local);
			transition_out(playlistlist.$$.fragment, local);
			transition_out(audioplayer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t2);
			destroy_component(addrandomplaylist, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(addemptyplaylist, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(playlistlist, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(audioplayer, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Playlists> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Playlists", $$slots, []);

	$$self.$capture_state = () => ({
		AddRandomPlaylist,
		AddEmptyPlaylist,
		PlaylistList,
		AudioPlayer
	});

	return [];
}

class Playlists extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Playlists",
			options,
			id: create_fragment$7.name
		});
	}
}

export default Playlists;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxheWxpc3RzLmYxZjViM2I5LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QbGF5bGlzdENvbXBzL0FkZFJhbmRvbVBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0Q29tcHMvQWRkRW1wdHlQbGF5bGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QbGF5bGlzdENvbXBzL0RlbGV0ZVBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0Q29tcHMvTG9hZFBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0Q29tcHMvRWRpdFBsYXlsaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BsYXlsaXN0TGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QbGF5bGlzdENvbXBzL0F1ZGlvUGxheWVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHBsYXlsaXN0c3RvcmUgfSBmcm9tICcuL1BsYXlsaXN0TGlzdFN0b3JlJ1xuXG4gICAgbGV0IHJhZHZpc2libGUgPSBmYWxzZTtcbiAgICBsZXQgcmFuZHZpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJhZHZpc2libGUpIHtcbiAgICAgICAgICAgIHJhZHZpc2libGUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFkdmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwbG5hbWU7XG4gICAgbGV0IHBsY291bnQ7XG4gICAgbGV0IHBsYXlsaXN0cztcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVN1Ym1pdChldmVudCkge1xuICAgICAgICByYWR2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHBsbmFtZSA9IGV2ZW50LnRhcmdldC5wbG5hbWUudmFsdWU7XG4gICAgICAgIHBsY291bnQgPSBldmVudC50YXJnZXQucGxjb3VudC52YWx1ZTtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRBZGRSYW5kb21QbGF5bGlzdCgpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cdFxuXHRhc3luYyBmdW5jdGlvbiBnZXRBZGRSYW5kb21QbGF5bGlzdCgpIHtcblx0XHRhd2FpdCBmZXRjaChgaHR0cDovLzE5Mi4xNjguMC43NDo2NzkwL0FkZFJhbmRvbVBsYXlsaXN0P3BsYXlsaXN0bmFtZT0ke3BsbmFtZX0mcGxheWxpc3Rjb3VudD0ke3BsY291bnR9YCwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuXHRcdC50aGVuKHIgPT4gci5qc29uKCkpXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBwbGF5bGlzdHMgPSBkYXRhLnBsaXN0cztcbiAgICAgICAgICAgIHBsYXlsaXN0c3RvcmUuc2V0KHBsYXlsaXN0cylcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHR9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtyYW5kdmlzfSA+QWRkIFJhbmRvbSBQbGF5bGlzdDwvYnV0dG9uPlxuXG57I2lmIHJhZHZpc2libGV9XG4gICAgPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PVwie2hhbmRsZVN1Ym1pdH1cIj5cbiAgICAgICAgPGlucHV0IGlkPVwicGxuYW1lXCIgbmFtZT1cInBsbmFtZVwiIHR5cGU9XCJ0ZXh0XCIgLz5cbiAgICAgICAgPGxhYmVsPlBsYXlsaXN0IE5hbWU8L2xhYmVsPjxiciAvPlxuICAgICAgICA8aW5wdXQgaWQ9XCJwbGNvdW50XCIgbmFtZT1cInBsY291bnRcIiB0eXBlPVwidGV4dFwiIC8+XG4gICAgICAgIDxsYWJlbD5OdW1iZXIgT2YgU29uZ3M8L2xhYmVsPjxiciAvPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIHZhbHVlPVwiQWRkXCIgLz5cbiAgICA8L2Zvcm0+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgZm9ybSB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHRleHQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XG4gICAgaW1wb3J0IHsgcGxheWxpc3RzdG9yZSB9IGZyb20gJy4vUGxheWxpc3RMaXN0U3RvcmUuanMnXG5cbiAgICBsZXQgdmlzaWJsZSA9IGZhbHNlO1xuICAgIGxldCBmdWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5ld3BsbmFtZTtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBZGRQbGF5TGlzdE5hbWVUb0RCU3VibWl0KGV2ZW50KSB7XG4gICAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgbmV3cGxuYW1lID0gZXZlbnQudGFyZ2V0LnBsbmFtZS52YWx1ZTtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRBZGRQbGF5TGlzdE5hbWVUb0RCKCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblx0XG5cdGFzeW5jIGZ1bmN0aW9uIGdldEFkZFBsYXlMaXN0TmFtZVRvREIoKSB7XG5cdFx0ZmV0Y2goYGh0dHA6Ly8xOTIuMTY4LjAuNzQ6Njc5MC9BZGRQbGF5TGlzdE5hbWVUb0RCP3BsYXlsaXN0bmFtZT0ke25ld3BsbmFtZX1gLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG5cdFx0LnRoZW4ociA9PiByLmpzb24oKSlcblx0XHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGxldCBwbmFtZSA9IGRhdGEucG5hbWVzO1xuICAgICAgICAgICAgcGxheWxpc3RzdG9yZS5zZXQocG5hbWUpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0fVxuXG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja30+QWRkIEVtcHR5IFBsYXlsaXN0PC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZX1cbiAgICA8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ9XCJ7aGFuZGxlQWRkUGxheUxpc3ROYW1lVG9EQlN1Ym1pdH1cIj5cbiAgICAgICAgPGlucHV0IGlkPVwicGxuYW1lXCIgbmFtZT1cInBsbmFtZVwiIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCJcIi8+XG4gICAgICAgIDxsYWJlbD5QbGF5bGlzdCBOYW1lPC9sYWJlbD48YnIgLz5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIkFkZFwiLz5cbiAgICA8L2Zvcm0+XG57L2lmfVxuXG5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgcGxheWxpc3RzdG9yZSB9IGZyb20gJy4vUGxheWxpc3RMaXN0U3RvcmUuanMnXG4gICAgZXhwb3J0IGxldCBQTElEO1xuICAgIGxldCBOUEw7XG5cdGFzeW5jIGZ1bmN0aW9uIGdldERlbGV0ZVBsYXlsaXN0RnJvbURCKCkge1xuICAgICAgICBmZXRjaChgaHR0cDovLzE5Mi4xNjguMC46Njc4OS9EZWxldGVQbGF5bGlzdEZyb21EQj9wbGF5bGlzdGlkPSR7UExJRH1gLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgTlBMID0gZGF0YS5ucGw7XG4gICAgICAgICAgICBwbGF5bGlzdHN0b3JlLnNldChOUEwpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGxldCBkZWxldGVDbGljayA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXREZWxldGVQbGF5bGlzdEZyb21EQigpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIGlkPVwiZGVsZXRlXCIgb246Y2xpY2s9e2RlbGV0ZUNsaWNrfSA+RGVsZXRlPC9idXR0b24+XG5cbjxzdHlsZT5cblxuICAgIGJ1dHRvbiNkZWxldGUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBwYWRkaW5nOiA3cHg7XG4gICAgfVxuXG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgZXhwb3J0IGxldCBQTElEO1xuICAgIFxuXG5cdGxldCBTT05HUyA9IFtdO1xuXHRhc3luYyBmdW5jdGlvbiBnZXRDcmVhdGVQbGF5ZXJQbGF5bGlzdCgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC4zMTo2Nzg5L0NyZWF0ZVBsYXllclBsYXlsaXN0P3BsYXlsaXN0aWQ9JHtQTElEfWBcbiAgICAgICAgY29uc29sZS5sb2coYWRkcilcblx0XHRhd2FpdCBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG5cdFx0LnRoZW4ociA9PiByLmpzb24oKSlcblx0XHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIFNPTkdTID0gZGF0YS5tYWtlUEw7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhTT05HU1swXSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBcbiAgICAvLyBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkU3VibWl0KGV2ZW50KSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZFN1Ym1pdCgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQudGFyZ2V0LlNPTkdTKVxuICAgICAgICAvLyBwbG5hbWUgPSBldmVudC50YXJnZXQucGxuYW1lLnZhbHVlO1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldENyZWF0ZVBsYXllclBsYXlsaXN0KCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInRoaXMgaXMgc29uZ3MgZnJvbSBsb2FkcGxheWxpc3QgcGFnZVwiKVxuICAgICAgICBjb25zb2xlLmxvZyhTT05HUylcbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIGlkPVwicGxheWxpc3RMb2FkQnRuXCIgb246Y2xpY2s9e2hhbmRsZUxvYWRTdWJtaXR9ID5Mb2FkPC9idXR0b24+XG5cbnsjaWYgUExJRCAhPT0gXCJcIn1cbiAgICB7I2VhY2ggU09OR1MgYXMgc31cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxpbWcgc3JjPXtzLnRodW1ibmFpbH0gYWx0PVwiZnVja1wiLz5cbiAgICAgICAgICAgIDxwPntzLmFydGlzdH08L3A+XG4gICAgICAgICAgICA8cD57cy5hbGJ1bX08L3A+XG4gICAgICAgICAgICA8cD57cy5uYW1lfTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgey9lYWNofVxuezplbHNlfVxuICAgIDxwPldob29wcyBubyBQbGF5bGlzdCBzZWxlY3RlZDwvcD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBpbWcge1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIG1hcmdpbi1yaWdodDogNTBweDtcbiAgICB9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgZXhwb3J0IGxldCBQTElEXG4gXG4gICAgbGV0IGhhbmRsZUFsbFBsYXlsaXN0U29uZ3NGcm9tREJTdWJtaXQgPSAoKSA9PiB7XG4gICAgICAgIGVkaXR2aXNpYmxlID0gdHJ1ZVxuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldEFsbFBsYXlsaXN0U29uZ3NGcm9tREIoKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXHRsZXQgc29uZ2xpc3Q7XG4gICAgbGV0IHNvbmdsaXN0X2NvdW50O1xuXHRhc3luYyBmdW5jdGlvbiBnZXRBbGxQbGF5bGlzdFNvbmdzRnJvbURCKCkge1xuXHRcdGZldGNoKGBodHRwOi8vMTkyLjE2OC4wLjMxOjY3ODkvQWxsUGxheWxpc3RTb25nc0Zyb21EQj9wbGF5bGlzdGlkPSR7UExJRH1gLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG5cdFx0LnRoZW4ociA9PiByLmpzb24oKSlcblx0XHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIHNvbmdsaXN0ID0gZGF0YS50YXo7XG4gICAgICAgICAgICBzb25nbGlzdF9jb3VudCA9IHNvbmdsaXN0Lmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdH1cblxuICAgIGxldCBlZGl0dmlzaWJsZSA9IHRydWU7XG4gICAgbGV0IGVkdmkgPSAoKSA9PiB7XG4gICAgICAgIGlmIChlZGl0dmlzaWJsZSkge1xuICAgICAgICAgICAgZWRpdHZpc2libGUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRpdHZpc2libGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIGZvciBwbGF5bGlzdCBzb25nIHJlbW92YWxcbiAgICAvLyBEZWxldGVTb25nRnJvbVBsYXlsaXN0XG4gICAgLy8gZGVsc29uZ2lkXG4gICAgLy8gcGxheWxpc3RuYW1lXG4gICAgLy8gcmVzdWx0XG5cbjwvc2NyaXB0PlxuXG5cbjxidXR0b24gb246Y2xpY2s9e2hhbmRsZUFsbFBsYXlsaXN0U29uZ3NGcm9tREJTdWJtaXR9PkVkaXQ8L2J1dHRvbj5cbnsjaWYgZWRpdHZpc2libGV9XG4gICAgeyNpZiBzb25nbGlzdF9jb3VudCA+IDF9XG4gICAgICAgIHsjZWFjaCBzb25nbGlzdCBhcyBzb25nfVxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPHAgaWQ9e3NvbmdbMV19Pntzb25nWzBdfTxidXR0b24gaWQ9XCJyZW1vdmVCdG5cIj5SZW1vdmU8L2J1dHRvbj48L3A+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIHsvZWFjaH1cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17ZWR2aX0+Q29tcGxldGU8L2J1dHRvbj5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxwPldob29wcyB6ZXJvIHNvbmdzPC9wPlxuICAgIHsvaWZ9XG57L2lmfVxuXG48c3R5bGU+XG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XG4gICAgfVxuICAgIGJ1dHRvbiNyZW1vdmVCdG4ge1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgfVxuXG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IERlbGV0ZVBsYXlsaXN0IGZyb20gJy4vUGxheWxpc3RDb21wcy9EZWxldGVQbGF5bGlzdC5zdmVsdGUnXG4gICAgaW1wb3J0IExvYWRQbGF5bGlzdCBmcm9tICcuL1BsYXlsaXN0Q29tcHMvTG9hZFBsYXlsaXN0LnN2ZWx0ZSdcbiAgICBpbXBvcnQgRWRpdFBsYXlsaXN0IGZyb20gJy4vUGxheWxpc3RDb21wcy9FZGl0UGxheWxpc3Quc3ZlbHRlJ1xuICAgIGltcG9ydCB7IHBsYXlsaXN0c3RvcmUsIHBsYXlsaXN0aWRzdG9yZSB9IGZyb20gJy4vUGxheWxpc3RDb21wcy9QbGF5bGlzdExpc3RTdG9yZS5qcydcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcblxuICAgIGxldCBwbGlkID0gXCJcIjtcbiAgICBsZXQgUExOQU1FUztcbiAgICBsZXQgUExDT1VOVCA9IDA7XG5cblx0b25Nb3VudChhc3luYyBmdW5jdGlvbiBnZXRBbGxQbGF5bGlzdHMoKSB7XG5cdFx0ZmV0Y2goYGh0dHA6Ly8xOTIuMTY4LjAuNzQ6Njc5MC9BbGxQbGF5bGlzdHNgLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG5cdFx0LnRoZW4ociA9PiByLmpzb24oKSlcblx0XHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGxldCBjdW50ID0gW107XG4gICAgICAgICAgICBsZXQgdm9vO1xuICAgICAgICAgICAgbGV0IG1vbyA9IGRhdGEucGxuYW1lcy5tYXAoKGRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdm9vID0ge1xuICAgICAgICAgICAgICAgICAgICBwbGF5bGlzdG5hbWUgOiBkYVswXSxcbiAgICAgICAgICAgICAgICAgICAgcGxheWxpc3RpZCA6IGRhWzFdLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdW50LnB1c2godm9vKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFBMTkFNRVMgPSBjdW50XG4gICAgICAgICAgICBwbGF5bGlzdHN0b3JlLnNldChQTE5BTUVTKVxuICAgICAgICAgICAgcGxheWxpc3RpZHN0b3JlLnNldChwbGlkKVxuICAgICAgICAgICAgaWYgKFBMTkFNRVMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgUExDT1VOVCA9IFBMTkFNRVMubGVuZ3RoXG4gICAgICAgICAgICB9XG5cdFx0fSlcbiAgICB9KVxuXG4gICAgbGV0IFBQTE5BTUVTO1xuICAgIGxldCBQUExDT1VOVDtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHBsYXlsaXN0c3RvcmUuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgUExOQU1FUyA9IHVuZGVmaW5lZDtcbiAgICAgICAgUExDT1VOVCA9IHVuZGVmaW5lZDtcbiAgICAgICAgUFBMTkFNRVMgPSB2YWx1ZTtcbiAgICAgICAgUFBMQ09VTlQgPSBQUExOQU1FUy5sZW5ndGhcbiAgICB9KTtcbiAgICBsZXQgcGxheWxpc3RpZHN0b3JlX3ZhbHVlO1xuICAgIGNvbnN0IHVuc3VicGxpZCA9IHBsYXlsaXN0aWRzdG9yZS5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICBwbGF5bGlzdGlkc3RvcmVfdmFsdWUgPSB2YWx1ZVxuICAgIH0pXG4gICAgICAgIC8vIGxldCBwbGF5bGlzdGlkc3RvcmVfdmFsdWU7XG48L3NjcmlwdD5cblxuPGRpdj5cbiAgICA8cD5DdXJyZW50bHkgc2VsZWN0ZWQgcGxheWxpc3Q6IHtwbGlkfTwvcD5cbiAgICA8Zm9ybT5cbiAgICAgICAgPHVsPlxuICAgICAgICAgICAgeyNpZiBQTENPVU5UID4gMX1cbiAgICAgICAgICAgICAgICB7I2VhY2ggUExOQU1FUyBhcyBwbG59XG4gICAgICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e3BsblsxXX0+e3BsblswXX08L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGJpbmQ6Z3JvdXA9e3BsaWR9IGlkPXtwbG5bMV19IG5hbWU9e3BsblsxXX0gdHlwZT1cInJhZGlvXCIgdmFsdWU9e3BsblsxXX0+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgezplbHNlIGlmIFBMQ09VTlQgPCAxfVxuICAgICAgICAgICAgICAgIDxwPldob29wcyBubyBwbGF5bGlzdHMgZm91bmQ8L3A+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPCEtLSA8bGFiZWwgZm9yPXtQTE5BTUVTWzBdfT57UExOQU1FU1swXX08L2xhYmVsPiAtLT5cbiAgICAgICAgICAgICAgICA8IS0tIDxpbnB1dCBiaW5kOmdyb3VwPXtwbGlkfSBpZD17UExOQU1FU1tcInBsYXlsaXN0aWRcIl19IG5hbWU9e1BMTlwicGxheWxpc3RuYW1lXCJbXCJwbGF5bGlzdGlkXCJdfSB0eXBlPVwicmFkXCJwbGF5bGlzdG5hbWVcInZhbHVlPXtQTE5BTUVTWzBdWzBdfT4gLS0+XG4gICAgICAgICAgICB7L2lmfVxuXG4gICAgICAgICAgICB7I2lmIFBQTENPVU5UID4gMX1cbiAgICAgICAgICAgICAgICB7I2VhY2ggUFBMTkFNRVMgYXMgcGxufVxuICAgICAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPXtwbG5bXCJwbGF5bGlzdGlkXCJdfT57cGxuW1wicGxheWxpc3RuYW1lXCJdfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgYmluZDpncm91cD17cGxpZH0gaWQ9e3BsbltcInBsYXlsaXN0aWRcIl19IG5hbWU9IHtwbG5bXCJwbGF5bGlzdGlkXCJdfSB0eXBlPVwicmFkaW9cIiB2YWx1ZT17cGxuW1wicGxheWxpc3RpZFwiXX0+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgezplbHNlIGlmIFBQTENPVU5UIDwgMX1cbiAgICAgICAgICAgICAgICA8cD5XaG9vcHMgbm8gcGxheWxpc3RzIGZvdW5kPC9wPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHA+dGhpcyBpcyBwcGxuYW1lczoge1BQTE5BTUVTWzBdW1wicGxheWxpc3RpZFwiXX08L3A+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj17UFBMTkFNRVNbMF1bXCJwbGF5bGlzdGlkXCJdfT57UFBMTkFNRVNbMF1bXCJwbGF5bGlzdG5hbWVcIl19PC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXQgYmluZDpncm91cD17cGxpZH0gaWQ9e1BQTE5BTUVTWzBdW1wicGxheWxpc3RpZFwiXX0gbmFtZT17UFBMTkFNRVNbMF1bXCJwbGF5bGlzdG5hbWVcIl19IHR5cGU9XCJyYWRpb1wiIHZhbHVlPXtQUExOQU1FU1swXVtcInBsYXlsaXN0bmFtZVwiXX0+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3VsPlxuICAgIDwvZm9ybT5cbjwvZGl2PlxuXG48bmF2PlxuICAgIDxMb2FkUGxheWxpc3QgUExJRD17cGxpZH0gLz5cbiAgICA8RGVsZXRlUGxheWxpc3QgUExJRD17cGxpZH0vPlxuICAgIDxFZGl0UGxheWxpc3QgUExJRD17cGxpZH0gLz5cbiAgICBcbjwvbmF2PlxuXG48c3R5bGU+XG4gICAgbmF2IHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgICB9XG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIC8vIC8vIEhUTUw1IGF1ZGlvIHBsYXllciArIHBsYXlsaXN0IGNvbnRyb2xzXG4gICAgbGV0IGpzUGxheWVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBsYXllci13cmFwJyk7XG4gICAgaWYgKGpzUGxheWVyKSB7XG4gICAgICAgIGpzUGxheWVyID0ge1xuICAgICAgICAgICAgd3JhcDoganNQbGF5ZXIsXG4gICAgICAgICAgICBwbGF5ZXI6IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCdhdWRpbycpICksXG4gICAgLy8gICAgICAgICBwbGF5ZXI6IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCdhdWRpbycpIHx8IHsgcGxheTogZnVuY3Rpb24oKXt9LCBwYXVzZTogZnVuY3Rpb24oKXt9IH0pLFxuXG4gICAgLy8gICAgICAgICBwbGF5OiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignLnBsYXknKSB8fCB7fSksXG4gICAgLy8gICAgICAgICBwYXVzZTogKGpzUGxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5wYXVzZScpIHx8IHt9KSxcbiAgICAvLyAgICAgICAgIHNlZWs6IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcuc2VlaycpIHx8IHt9KSxcbiAgICAvLyAgICAgICAgIHByZXY6IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcucHJldicpIHx8IHt9KSxcbiAgICAgICAgICAgIG5leHQ6IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcubmV4dCcpIHx8IHt9KSxcbiAgICAvLyAgICAgICAgIGJ1dHRvbjogKGpzUGxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5idXR0b24nKSB8fCB7IHN0eWxlOiB7fSB9KSxcbiAgICAvLyAgICAgICAgIHdyYXBMaXN0OiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBsYXlsaXN0LXdyYXAnKSB8fCB7fSksXG4gICAgLy8gICAgICAgICBhY3Rpb246IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcuYWN0aW9uJykgfHwge30pLFxuICAgIC8vICAgICAgICAgdGl0bGU6IChqc1BsYXllci5xdWVyeVNlbGVjdG9yKCcudGl0bGUnKSB8fCB7fSksXG4gICAgLy8gICAgICAgICBjdXJyZW50OiAoanNQbGF5ZXIucXVlcnlTZWxlY3RvcignLmN1cnJlbnQnKSB8fCB7fSksXG4gICAgLy8gICAgICAgICBkdXJhdGlvbjogKGpzUGxheWVyLnF1ZXJ5U2VsZWN0b3IoJy5kdXJhdGlvbicpIHx8IHt9KSxcbiAgICAgICAgICAgIHRyYWNrQ291bnQ6IDAsXG4gICAgLy8gICAgIHNlZWtpbmc6IG51bGwsXG4gICAgICAgICAgICBwbGF5aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHRyYWNrczogW10sXG4gICAgICAgICAgICB0cmFjazogW10sXG4gICAgICAgICAgICBpZHg6IDBcbiAgICAgICAgfTtcblxuICAgIC8vICAgICBqc1BsYXllci5wbGF5Q2xpY2tlZCA9IGZ1bmN0aW9uIGpzUGxheWVyUGxheUNsaWNrZWQoKXtcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLmJ1dHRvbi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wYXVzZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBsYXlpbmcgPSB0cnVlO1xuICAgIC8vICAgICAgICAganNQbGF5ZXIuYWN0aW9uLmlubmVySFRNTCA9ICdOb3cgUGxheWluZyZoZWxsaXA7JztcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBsYXllci5wbGF5KCk7XG4gICAgLy8gICAgICAgICBqc1BsYXllci51cGRhdGVTZWVrKCk7XG4gICAgLy8gICAgIH07XG4gICAgLy8gICAgIGpzUGxheWVyLnBhdXNlQ2xpY2tlZCA9IGZ1bmN0aW9uIGpzUGxheWVyUGF1c2VDbGlja2VkKCl7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIC8vICAgICAgICAganNQbGF5ZXIucGF1c2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAvLyAgICAgICAgIGNsZWFyVGltZW91dChqc1BsYXllci5zZWVraW5nKTtcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLmFjdGlvbi5pbm5lckhUTUwgPSAnUGF1c2VkJmhlbGxpcDsnO1xuICAgIC8vICAgICAgICAganNQbGF5ZXIucGxheWVyLnBhdXNlKCk7XG4gICAgLy8gICAgIH07XG4gICAgLy8gICAgIGpzUGxheWVyLmxvYWRQbGF5bGlzdCA9IGZ1bmN0aW9uIGphUGxheWVyTG9hZFBsYXlsaXN0KCl7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5bGlzdCA9IGpzUGxheWVyLndyYXBMaXN0PyBqc1BsYXllci53cmFwTGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdvbCA+IGxpJykgOiBbXTtcbiAgICAvLyAgICAgICAgIHZhciBsZW4gPSBqc1BsYXllci5wbGF5bGlzdC5sZW5ndGgsXG4gICAgLy8gICAgICAgICAgICAgdG1wLCBpO1xuICAgIC8vICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gICAgICAgICAgICAgaWYgKCFqc1BsYXllci5wbGF5bGlzdFtpXS5kYXRhc2V0KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlsaXN0W2ldLmRhdGFzZXQgPSB7fTtcbiAgICAvLyAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgdG1wID0ganNQbGF5ZXIucGxheWxpc3RbaV0ucXVlcnlTZWxlY3RvcignYScpO1xuICAgIC8vICAgICAgICAgICAgIGlmICh0bXAgJiYgIWpzUGxheWVyLnBsYXlsaXN0W2ldLmRhdGFzZXQuaWR4KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlsaXN0W2ldLmRhdGFzZXQuaWR4ID0gaSArIDE7XG4gICAgLy8gICAgICAgICAgICAgICAgIGpzUGxheWVyLnRyYWNrQ291bnQrKztcbiAgICAvLyAgICAgICAgICAgICAgICAganNQbGF5ZXIudHJhY2tzLnB1c2goe1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgXCJmaWxlXCI6IHRtcC5ocmVmLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6ICh0bXAudGV4dENvbnRlbnQgfHwgdG1wLmlubmVyVGV4dCkucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgXCJ0cmFja1wiOiBpICsgMVxuICAgIC8vICAgICAgICAgICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH07XG4gICAgLy8gICAgIGpzUGxheWVyLmxvYWRUcmFjayA9IGZ1bmN0aW9uIGpzUGxheWVyTG9hZFRyYWNrKGlkeCl7XG4gICAgLy8gICAgICAgICB2YXIgbGVuID0ganNQbGF5ZXIucGxheWxpc3QubGVuZ3RoLFxuICAgIC8vICAgICAgICAgICAgIGk7XG4gICAgLy8gICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gICAgICAgICAgICAgaWYgKGpzUGxheWVyLnBsYXlsaXN0W2ldLmNsYXNzTGlzdCkge1xuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaWR4KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5bGlzdFtpXS5jbGFzc0xpc3QuYWRkKCdzZWwnKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlsaXN0W2ldLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbCcpO1xuICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgICAganNQbGF5ZXIudGl0bGUuaW5uZXJIVE1MID0ganNQbGF5ZXIudHJhY2tzW2lkeF0ubmFtZTtcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBsYXllci5zcmMgPSBqc1BsYXllci50cmFja3NbaWR4XS5maWxlICsgJy5tcDMnO1xuICAgIC8vICAgICB9O1xuICAgIC8vICAgICBqc1BsYXllci5wbGF5VHJhY2sgPSBmdW5jdGlvbiBqc1BsYXllclBsYXlUcmFjayhpZHgpe1xuICAgIC8vICAgICAgICAganNQbGF5ZXIubG9hZFRyYWNrKGlkeCk7XG4gICAgLy8gICAgICAgICBqc1BsYXllci5wbGF5aW5nID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgIGpzUGxheWVyLnBsYXlDbGlja2VkKCk7XG4gICAgLy8gICAgIH07XG4gICAgICAgIGpzUGxheWVyLmluaXQgPSBmdW5jdGlvbiBqc1BsYXllckluaXQoKXtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IChqc1BsYXllci53cmFwICYmIGpzUGxheWVyLndyYXAuZGF0YXNldCAmJiBqc1BsYXllci53cmFwLmRhdGFzZXQudXJsKT8ganNQbGF5ZXIud3JhcCA6IG51bGwsXG4gICAgICAgICAgICAgICAgdG1wLCBpO1xuICAgIC8vICAgICAgICAgaWYgKCEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKS5jYW5QbGF5VHlwZSgnYXVkaW8vbXBlZycpKSB7XG4gICAgLy8gICAgICAgICAgICAgaWYgKGpzUGxheWVyLndyYXBMaXN0ICYmIGpzUGxheWVyLndyYXBMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ29sID4gbGknKS5sZW5ndGggPiAwKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIGpzUGxheWVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIC8vICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2spIHtcbiAgICAvLyAgICAgICAgICAgICAgICAganNQbGF5ZXIudHJhY2tzID0gW3tcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIFwiZmlsZVwiOiB0cmFjay5kYXRhc2V0LnVybCxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiAodHJhY2suZGF0YXNldC50aXRsZSB8fCAnJyksXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBcInRyYWNrXCI6IDFcbiAgICAvLyAgICAgICAgICAgICAgICAgfV07XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgIGlmIChqc1BsYXllci50cmFja3MubGVuZ3RoID4gMCkge1xuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucGxheWVyKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiBwbGF5ZXJFbmRlZCgpe1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc1BsYXllci5pZHggKyAxIDwganNQbGF5ZXIudHJhY2tDb3VudCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5pZHgrKztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheVRyYWNrKGpzUGxheWVyLmlkeCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuYWN0aW9uLmlubmVySFRNTCA9ICdQYXVzZWQmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXllci5wYXVzZSgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5pZHggPSAwO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5sb2FkVHJhY2soanNQbGF5ZXIuaWR4KTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgZnVuY3Rpb24gcGxheWVyTG9hZGVkZGF0YSgpe1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnNldER1cmF0aW9uKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucGxheSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGpzUGxheWVyLnBsYXlDbGlja2VkLCB0cnVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucGF1c2UpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBhdXNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywganNQbGF5ZXIucGF1c2VDbGlja2VkLCB0cnVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIuYnV0dG9uKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBidXR0b25DbGlja2VkKGV2ZW50KXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlDbGlja2VkKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucHJldikge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucHJldi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIHByZXZDbGlja2VkKGV2ZW50KXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc1BsYXllci5pZHggLSAxID4gLTEpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuaWR4LS07XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmxvYWRUcmFjayhqc1BsYXllci5pZHgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucGxheWluZykge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuYWN0aW9uLmlubmVySFRNTCA9ICdOb3cgUGxheWluZyZoZWxsaXA7JztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXllci5wbGF5KCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5hY3Rpb24uaW5uZXJIVE1MID0gJ1BhdXNlZCZoZWxsaXA7JztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheWluZyA9IGZhbHNlO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIucGF1c2UoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuaWR4ID0gMDtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIubG9hZFRyYWNrKGpzUGxheWVyLmlkeCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLm5leHQpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLm5leHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBuZXh0Q2xpY2tlZChldmVudCl7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIuaWR4ICsgMSA8IGpzUGxheWVyLnRyYWNrQ291bnQpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuaWR4Kys7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmxvYWRUcmFjayhqc1BsYXllci5pZHgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNQbGF5ZXIucGxheWluZykge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuYWN0aW9uLmlubmVySFRNTCA9ICdOb3cgUGxheWluZyZoZWxsaXA7JztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXllci5wbGF5KCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5hY3Rpb24uaW5uZXJIVE1MID0gJ1BhdXNlZCZoZWxsaXA7JztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheWluZyA9IGZhbHNlO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5wbGF5ZXIucGF1c2UoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuaWR4ID0gMDtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIubG9hZFRyYWNrKGpzUGxheWVyLmlkeCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLnNlZWspIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnNlZWsuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gc2Vla0NsaWNrZWQoKXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoanNQbGF5ZXIuc2Vla2luZyk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuYWN0aW9uLmlubmVySFRNTCA9ICdQYXVzZWQmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIucGxheWVyLnBhdXNlKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnNlZWsuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uIHNlZWtSZWxlYXNlZCgpe1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXllci5jdXJyZW50VGltZSA9IGpzUGxheWVyLnNlZWsudmFsdWUgKiBqc1BsYXllci5wbGF5ZXIuZHVyYXRpb24gLyAxMDA7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIudXBkYXRlU2VlaygpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc1BsYXllci5wbGF5aW5nKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLmFjdGlvbi5pbm5lckhUTUwgPSAnTm93IFBsYXlpbmcmaGVsbGlwOyc7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXllci5wbGF5KCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGpzUGxheWVyLndyYXBMaXN0KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci53cmFwTGlzdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIGxpc3RDbGlja2VkKGV2ZW50KXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29sJykge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0ganNQbGF5ZXIucGxheWxpc3QubGVuZ3RoLFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuZGF0YXNldC5pZHggPT0gaSArIDEpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5pZHggPSBpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnBsYXlUcmFjayhqc1BsYXllci5pZHgpO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBsZW47XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICBqc1BsYXllci5zZXREdXJhdGlvbiA9IGZ1bmN0aW9uIHNldER1cmF0aW9uKCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuZHVyYXRpb24uaW5uZXJIVE1MID0ganNQbGF5ZXIuZm9ybWF0VGltZShqc1BsYXllci5wbGF5ZXIuZHVyYXRpb24pO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuY3VycmVudC5pbm5lckhUTUwgPSBqc1BsYXllci5mb3JtYXRUaW1lKGpzUGxheWVyLnBsYXllci5jdXJyZW50VGltZSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5zZWVrLnZhbHVlID0ganNQbGF5ZXIucGxheWVyLmN1cnJlbnRUaW1lIC8ganNQbGF5ZXIucGxheWVyLmR1cmF0aW9uO1xuICAgIC8vICAgICAgICAgICAgICAgICB9O1xuICAgIC8vICAgICAgICAgICAgICAgICBqc1BsYXllci51cGRhdGVTZWVrID0gZnVuY3Rpb24gdXBkYXRlU2VlaygpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGpzUGxheWVyLnNlZWsudmFsdWUgPSAxMDAgKiBqc1BsYXllci5wbGF5ZXIuY3VycmVudFRpbWUgLyBqc1BsYXllci5wbGF5ZXIuZHVyYXRpb247XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBqc1BsYXllci5jdXJyZW50LmlubmVySFRNTCA9IGpzUGxheWVyLmZvcm1hdFRpbWUoanNQbGF5ZXIucGxheWVyLmN1cnJlbnRUaW1lKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmIChqc1BsYXllci5wbGF5aW5nKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAganNQbGF5ZXIuc2Vla2luZyA9IHNldFRpbWVvdXQoanNQbGF5ZXIudXBkYXRlU2VlaywgNTAwKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgfTtcbiAgICAvLyAgICAgICAgICAgICAgICAganNQbGF5ZXIuZm9ybWF0VGltZSA9IGZ1bmN0aW9uIGZvcm1hdFRpbWUodmFsKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IDAsIG0gPSAwLCBzO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAodmFsID4gNjAgKiA2MCkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBwYXJzZUludCh2YWwgLyAoNjAgKiA2MCksIDEwKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgLT0gaCAqIDYwICogNjA7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAodmFsID4gNjApIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBtID0gcGFyc2VJbnQodmFsIC8gNjAsIDEwKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgLT0gbSAqIDYwO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgcyA9IHZhbDtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHZhbCA9IChoID4gMCk/IGggKyAnOicgOiAnJztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHZhbCArPSAobSA+IDApPyAoKG0gPCAxMCAmJiBoID4gMCk/ICcwJyA6ICcnKSArIG0gKyAnOicgOiAnMDonO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFsICs9ICgocyA8IDEwKT8gJzAnIDogJycpICsgcztcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgLy8gICAgICAgICAgICAgICAgIH07XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgICAgaWYgKGpzUGxheWVyLnRyYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gICAgICAgICAgICAganNQbGF5ZXIud3JhcC5jbGFzc05hbWUgKz0gJyBlbmFibGVkJztcbiAgICAvLyAgICAgICAgICAgICBqc1BsYXllci5sb2FkVHJhY2soanNQbGF5ZXIuaWR4KTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAganNQbGF5ZXIuaW5pdCgpO1xuICAgIH1cblxuPC9zY3JpcHQ+XG5cblxuXG48IS0tIDxkaXYgY2xhc3M9XCJwYWdlXCI+IC0tPlxuICAgIDwhLS0gPGF1ZGlvIHNyYz1cImJvbzEubXAzXCIgY29udHJvbHMgPjwvYXVkaW8+IC0tPlxuXHQ8IS0tIDxkaXYgY2xhc3M9XCJwbGF5ZXItd3JhcFwiIGRhdGEtdXJsPVwiXCIgZGF0YS10aXRsZT1cIkJvbzFcIj5cbiAgICAgICAgICAgIDxhdWRpbyBjb250cm9scyA+PC9hdWRpbz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25cIj5QbGF5PC9kaXY+XG5cbiAgICAgICAgXG4gICAgPC9kaXY+IC0tPlxuICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XCJpbmZvXCI+IC0tPlxuICAgICAgICAgICAgPCEtLSA8aDE+QWxidW06IE15dGhpdW08L2gxPiAtLT5cbiAgICAgICAgICAgIDwhLS0gPHAgY2xhc3M9XCJhY3Rpb25cIj4mbmJzcDs8L3A+XG4gICAgICAgICAgICA8cCBjbGFzcz1cInRpdGxlIGVsbGlwc2lzXCI+PC9wPiAtLT5cblxuICAgICAgICAgICAgPCEtLSA8YXVkaW8gc3JjPVwiXCIgY29udHJvbHMgPjwvYXVkaW8+IC0tPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XCJwbGF5ZXJcIj5cbiAgICAgICAgICAgICAgICA8YXVkaW8gcHJlbG9hZCBjb250cm9scyA+PC9hdWRpbz4gLS0+XG4gICAgICAgICAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwicGxheXBhdXNlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwbGF5XCI+PHN2ZyB2aWV3Qm94PVwiMCAwIDIgMlwiPjxwYXRoIGQ9XCJNMCwwIEwwLDE0IEwxMSw3IEwwLDAgWlwiLz48L3N2Zz48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhdXNlXCI+PHN2ZyB2aWV3Qm94PVwiMCAwIDE0IDE0XCI+PHBhdGggZD1cIk0wLDE0IEw0LDE0IEw0LDAgTDAsMCBMMCwxNCBMMCwxNCBaIE04LDAgTDgsMTQgTDEyLDE0IEwxMiwwIEw4LDAgTDgsMCBaXCIvPjwvc3ZnPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PiAtLT5cbiAgICAgICAgICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XCJ0aW1lclwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY3VycmVudFwiPjA6MDA6MDA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj4vPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkdXJhdGlvblwiPjA6MDA6MDA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gLS0+XG4gICAgICAgICAgICAgICAgPCEtLSA8ZGl2PjxpbnB1dCB0eXBlPVwicmFuZ2VcIiBtaW49XCIwXCIgbWF4PVwiMTAwXCIgc3RlcD1cIi4xXCIgdmFsdWU9XCIwXCIgY2xhc3M9XCJzZWVrXCI+PC9kaXY+IC0tPlxuICAgICAgICAgICAgICAgIDwhLS0gPGRpdiBjbGFzcz1cInByZXZcIj48c3ZnIHZpZXdCb3g9XCIwIDAgMTIgMTJcIj48cGF0aCBkPVwiTTMuNSw2IEwxMiwxMiBMMTIsMCBMMy41LDYgWiBNMCwwIEwwLDEyIEwyLDEyIEwyLDAgTDAsMCBMMCwwIFpcIi8+PC9zdmc+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5leHRcIj48c3ZnIHZpZXdCb3g9XCIwIDAgMTIgMTJcIj48cGF0aCBkPVwiTTAsMTIgTDguNSw2IEwwLDAgTDAsMTIgTDAsMTIgWiBNMTAsMCBMMTAsMTIgTDEyLDEyIEwxMiwwIEwxMCwwIEwxMCwwIFpcIi8+PC9zdmc+PC9kaXY+IC0tPlxuICAgICAgICAgICAgPCEtLSA8L2Rpdj4gLS0+XG4gICAgICAgIDwhLS0gPC9kaXY+IC0tPlxuICAgIDwhLS0gPC9kaXY+IC0tPlxuXG48ZGl2IGNsYXNzPVwicGxheWVyLXdyYXBcIiBkYXRhLXVybD1cImJvbzEubXAzXCIgZGF0YS10aXRsZT1cIkJvbzFcIiA+XG4gICAgPGF1ZGlvIHNyYz1cIlwiIGNvbnRyb2xzID48L2F1ZGlvPlxuPC9kaXY+XG5cblxuPGRpdj5cblx0PGRpdiBjbGFzcz1cInBsYXlsaXN0LXdyYXBcIj5cblx0XHQ8b2w+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cImJvbzEubXAzXCI+Qm9vMTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCJib28yLm1wM1wiPkJvbzI8L2E+PC9saT5cblx0XHRcdDwhLS0gPGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vQlNfQVRLTVwiPkFsbCBUaGUgS2luZydzIE1lbiAtIEJyb2Fkd2luZyBTdHVkaW8gKEZpbmFsIE1peCk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL0JTRk1fVEZcIj5UaGUgRm9yc2FrZW4gLSBCcm9hZHdpbmcgU3R1ZGlvIChGaXJzdCBNaXgpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9CU0ZNX0FUS01cIj5BbGwgVGhlIEtpbmcncyBNZW4gLSBCcm9hZHdpbmcgU3R1ZGlvIChGaXJzdCBNaXgpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9BQ19BVElcIj5BbGwgVGhpcyBJcyAtIEFsdGVybmF0ZSBDdXRzPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9BQ19BVEtNVGFrZV8xXCI+QWxsIFRoZSBLaW5nJ3MgTWVuIChUYWtlIDEpIC0gQWx0ZXJuYXRlIEN1dHM8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL0FDX0FUS01UYWtlXzJcIj5BbGwgVGhlIEtpbmcncyBNZW4gKFRha2UgMikgLSBBbHRlcm5hdGUgQ3V0czwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vQUNfTVwiPk1hZ3VzIC0gQWx0ZXJuYXRlIEN1dHM8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL0FDX1RTT1dBZnVja2VkX3VwXCI+VGhlIFN0YXRlIE9mIFdlYXJpbmcgQWRkcmVzcyAoZnVja2VkIHVwKSAtIEFsdGVybmF0ZSBDdXRzPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9QTlkwNC0wNV9NXCI+TWFndXMgLSBQb3BleWUncyAoTmV3IFllYXJzICcwNCAtICcwNSk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1BOWTA0LTA1X09UV1wiPk9uIFRoZSBXYXRlcmZyb250IC0gUG9wZXllJ3MgKE5ldyBZZWFycyAnMDQgLSAnMDUpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9QTlkwNC0wNV9UXCI+VHJhbmNlIC0gUG9wZXllJ3MgKE5ldyBZZWFycyAnMDQgLSAnMDUpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9QTlkwNC0wNV9URlwiPlRoZSBGb3JzYWtlbiAtIFBvcGV5ZSdzIChOZXcgWWVhcnMgJzA0IC0gJzA1KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vUE5ZMDQtMDVfVFNPV0FcIj5UaGUgU3RhdGUgT2YgV2VhcmluZyBBZGRyZXNzIC0gUG9wZXllJ3MgKE5ldyBZZWFycyAnMDQgLSAnMDUpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9QVkRfTVwiPk1hZ3VzIC0gUG9wZXllJ3MgKFZhbGVudGluZSdzIERheSAnMDUpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9QVkRfVFwiPlRyYW5jZSAtIFBvcGV5ZSdzIChWYWxlbnRpbmUncyBEYXkgJzA1KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vUFZEX1RTT1dBXCI+VGhlIFN0YXRlIE9mIFdlYXJpbmcgQWRkcmVzcyAtIFBvcGV5ZSdzIChWYWxlbnRpbmUncyBEYXkgJzA1KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMDFfMDhfMDRfQVRJXCI+QWxsIFRoaXMgSXMgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKDAxLzA4LzA0KTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMDFfMDhfMDRfTVwiPk1hZ3VzIC0gU21pdGggU3QuIEJhc2VtZW50ICgwMS8wOC8wNCk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjA2XzA2XzAzX0JUUEVcIj5CZW5lYXRoIFRoZSBQYWludGVkIEV5ZSAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMDYvMDYvMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0IwNl8wNl8wM19JXCI+SW5ub2NlbmNlIC0gU21pdGggU3QuIEJhc2VtZW50ICgwNi8wNi8wMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjA2XzA2XzAzX01cIj5NYWd1cyAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMDYvMDYvMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0IwNl8wNl8wM19NRVwiPk1hZG5lc3MgRXhwbG9yZWQgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKDA2LzA2LzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMDZfMDZfMDNfVEZcIj5UaGUgRm9yc2FrZW4gLSBTbWl0aCBTdC4gQmFzZW1lbnQgKDA2LzA2LzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMTJfMjhfMDNfQVRJXCI+QWxsIFRoaXMgSXMgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKDEyLzI4LzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCMTJfMjhfMDNfTVwiPk1hZ3VzIC0gU21pdGggU3QuIEJhc2VtZW50ICgxMi8yOC8wMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjEyXzI4XzAzX01FXCI+TWFkbmVzcyBFeHBsb3JlZCAtIFNtaXRoIFN0LiBCYXNlbWVudCAoMTIvMjgvMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0IxMl8yOF8wM19UXCI+VHJhbmNlIC0gU21pdGggU3QuIEJhc2VtZW50ICgxMi8yOC8wMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQjEyXzI4XzAzX1RGXCI+VGhlIEZvcnNha2VuIC0gU21pdGggU3QuIEJhc2VtZW50ICgxMi8yOC8wMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQl9fXzExXzAzX0FUSVRha2VfMVwiPkFsbCBUaGlzIElzIChUYWtlIDEpIC0gU21pdGggU3QuIEJhc2VtZW50IChOb3YuICcwMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQl9fXzExXzAzX0FUSVRha2VfMlwiPkFsbCBUaGlzIElzIChUYWtlIDIpIC0gU21pdGggU3QuIEJhc2VtZW50IChOb3YuICcwMyk8L2E+PC9saT5cblx0XHRcdDxsaT48YSBocmVmPVwiLy9hcmNoaXZlLm9yZy9kb3dubG9hZC9teXRoaXVtL1NTQl9fXzExXzAzX0JUUEVUYWtlXzFcIj5CZW5lYXRoIFRoZSBQYWludGVkIEV5ZSAoVGFrZSAxKSAtIFNtaXRoIFN0LiBCYXNlbWVudCAoTm92LiAnMDMpPC9hPjwvbGk+XG5cdFx0XHQ8bGk+PGEgaHJlZj1cIi8vYXJjaGl2ZS5vcmcvZG93bmxvYWQvbXl0aGl1bS9TU0JfX18xMV8wM19CVFBFVGFrZV8yXCI+QmVuZWF0aCBUaGUgUGFpbnRlZCBFeWUgKFRha2UgMikgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKE5vdi4gJzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCX19fMTFfMDNfVEZUYWtlXzFcIj5UaGUgRm9yc2FrZW4gKFRha2UgMSkgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKE5vdi4gJzAzKTwvYT48L2xpPlxuXHRcdFx0PGxpPjxhIGhyZWY9XCIvL2FyY2hpdmUub3JnL2Rvd25sb2FkL215dGhpdW0vU1NCX19fMTFfMDNfVEZUYWtlXzJcIj5UaGUgRm9yc2FrZW4gKFRha2UgMikgLSBTbWl0aCBTdC4gQmFzZW1lbnQgKE5vdi4gJzAzKTwvYT48L2xpPiAtLT5cblx0XHQ8L29sPlxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLyogPj4gcmVzZXQgKi9cbiAgICAvKiBodG1sLCBib2R5LCBkaXYsIHNwYW4sIGgxLCBwLCBhLCBvbCwgbGksIGF1ZGlvIHtcbiAgICAgICAgYm9yZGVyOiAwO1xuICAgICAgICBmb250OiBpbmhlcml0O1xuICAgICAgICBmb250LXNpemU6IDEwMCU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xuICAgIH0gKi9cbiAgICBvbCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICB9XG4gICAgb2wgbGkge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGxpc3Qtc3R5bGU6IGRlY2ltYWwgb3V0c2lkZTtcbiAgICB9XG4gICAgKiB7XG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICB9XG4gICAgLyogaHRtbCwgYm9keSB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH0gKi9cbiAgICAvKiBib2R5IHtcbiAgICAgICAgcGFkZGluZzogNXB4IDA7XG4gICAgICAgIGJhY2tncm91bmQ6ICMxMTEgbm9uZTtcbiAgICAgICAgZm9udDogMjBweC8yNHB4ICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmO1xuICAgICAgICBjb2xvcjogI2VlZTtcbiAgICB9ICovXG4gICAgLyogYSwgYTpmb2N1cywgYTphY3RpdmUsIGE6aG92ZXIsIGE6dmlzaXRlZCB7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICB9XG4gICAgYVtocmVmXSwgYVtocmVmXTphY3RpdmUsIGFbaHJlZl06dmlzaXRlZCB7XG4gICAgICAgIGNvbG9yOiAjZGRkO1xuICAgICAgICBvdXRsaW5lOiAwIG5vbmU7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cbiAgICBhW2hyZWZdOmhvdmVyLCBhW2hyZWZdOmZvY3VzIHtcbiAgICAgICAgY29sb3I6ICNiYmI7XG4gICAgfSAqL1xuICAgIC8qIDw8IHJlc2V0ICovXG5cbiAgICAvKiBwYWdlIHN0eWxlICovXG4gICAgLyogLnBhZ2Uge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xuICAgICAgICB3aWR0aDogNzAlO1xuICAgICAgICBtaW4td2lkdGg6IDMwMHB4O1xuICAgICAgICBtYXgtd2lkdGg6IDcwMHB4O1xuICAgIH0gKi9cbiAgICAvKiAuZWxsaXBzaXMge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB9ICovXG5cbiAgICAvKiBBdWRpbyBQbGF5ZXIgKi9cbiAgICAucGxheWVyLXdyYXAge1xuICAgICAgICAvKiBwb3NpdGlvbjogcmVsYXRpdmU7ICovXG4gICAgICAgIG1hcmdpbjogMCAwIDFlbTtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIC8qIGJhY2tncm91bmQtY29sb3I6ICMyMjI7ICovXG4gICAgfVxuICAgIC8qIC5wbGF5ZXItd3JhcC5lbmFibGVkIHtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDRlbTtcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5idXR0b24ge1xuICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgbWFyZ2luOiAxLjVlbSAyZW07XG4gICAgICAgIHdpZHRoOiA1ZW07XG4gICAgICAgIGhlaWdodDogNWVtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBwdXJwbGU7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA1ZW07XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMjUlO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgfSAqL1xuICAgIC8qIC5wbGF5ZXItd3JhcCAuYnV0dG9uOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBwdXJwbGU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG4gICAgLnBsYXllci13cmFwLmVuYWJsZWQgLmJ1dHRvbiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgLmluZm8ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMTBlbTtcbiAgICB9XG4gICAgLnBsYXllci13cmFwIGgxIHtcbiAgICAgICAgcGFkZGluZzogMS41ZW0gMDtcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5hY3Rpb24ge1xuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgfSAqL1xuICAgIC8qIC5wbGF5ZXItd3JhcCAucGxheWVyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgcGFkZGluZzogMCAxZW0gMCA2ZW07XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDFlbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICAgICAgZm9udC1zaXplOiAyZW07XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcC5lbmFibGVkIC5wbGF5ZXIge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5wbGF5ZXIgc3ZnIHtcbiAgICAgICAgbWFyZ2luOiAuMjVlbTtcbiAgICAgICAgd2lkdGg6IC41ZW07XG4gICAgICAgIGhlaWdodDogLjVlbTtcbiAgICAgICAgZmlsbDogY3VycmVudENvbG9yO1xuICAgIH0gKi9cbiAgICAvKiAucGxheWVyLXdyYXAgLnBsYXllciBkaXYge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCBhdWRpbyxcbiAgICAucGxheWVyLXdyYXAgLnBsYXllciAucGF1c2Uge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgLnBsYXlwYXVzZSwgLnBsYXllci13cmFwIC50aW1lcixcbiAgICAucGxheWVyLXdyYXAgLnByZXYsIC5wbGF5ZXItd3JhcCAubmV4dCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgaGVpZ2h0OiAxZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxZW07XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB9ICovXG4gICAgLyogLnBsYXllci13cmFwIC5wbGF5cGF1c2UsXG4gICAgLnBsYXllci13cmFwIC5wcmV2LCAucGxheWVyLXdyYXAgLm5leHQge1xuICAgICAgICB3aWR0aDogMWVtO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCAucGxheXBhdXNlIHtcbiAgICAgICAgbGVmdDogMWVtO1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgLm5leHQge1xuICAgICAgICBsZWZ0OiBhdXRvO1xuICAgICAgICByaWdodDogMDtcbiAgICB9XG4gICAgLnBsYXllci13cmFwIC5wbGF5cGF1c2U6aG92ZXIsXG4gICAgLnBsYXllci13cmFwIC5wcmV2OmhvdmVyLCAucGxheWVyLXdyYXAgLm5leHQ6aG92ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDQ0O1xuICAgIH1cbiAgICAucGxheWVyLXdyYXAgLnBsYXlwYXVzZSwgLnBsYXllci13cmFwIC5wbGF5LCAucGxheWVyLXdyYXAgLnBhdXNlLFxuICAgIC5wbGF5ZXItd3JhcCAucHJldjo6LW1vei1mb2N1cy1pbm5lcixcbiAgICAucGxheWVyLXdyYXAgLm5leHQ6Oi1tb3otZm9jdXMtaW5uZXIge1xuICAgICAgICBib3JkZXI6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgfSAqL1xuICAgIC8qIC5wbGF5ZXItd3JhcCAudGltZXIge1xuICAgICAgICBsZWZ0OiAyZW07XG4gICAgICAgIHdpZHRoOiA0ZW07XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCAudGltZXIgZGl2IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICAgIGZvbnQtc2l6ZTogLjQ1ZW07XG4gICAgfVxuICAgIC5wbGF5ZXItd3JhcCAuc2VlayB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfSAqL1xuICAgIC5wbGF5bGlzdC13cmFwIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzIyMjtcbiAgICB9XG4gICAgLnBsYXlsaXN0LXdyYXAgbGkge1xuICAgICAgICBtYXJnaW46IDAgMCAwIDNlbTtcbiAgICAgICAgcGFkZGluZzogLjI1ZW0gMCAuMjVlbSAuNWVtO1xuICAgICAgICBsaXN0LXN0eWxlOiBkZWNpbWFsIG91dHNpZGU7XG4gICAgfVxuICAgIC8qIC5wbGF5bGlzdC13cmFwIGxpLnNlbCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgfVxuICAgIC5wbGF5bGlzdC13cmFwIGxpOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzQ0NDtcbiAgICB9ICovXG5cbiAgICAvKiA+PiBpbnB1dFt0eXBlPXJhbmdlXSBjbGFzczogc2VlayAqL1xuICAgIC8qIGlucHV0LnNlZWtbdHlwZT1yYW5nZV0ge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICBmb250LXNpemU6IDFlbTtcbiAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgIH1cbiAgICBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdOmZvY3VzIHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTo6LXdlYmtpdC1zbGlkZXItcnVubmFibGUtdHJhY2sge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICB3aWR0aDogOTglO1xuICAgICAgICBoZWlnaHQ6IC4xN2VtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IC4xZW07XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAuMnMgZWFzZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTo6LXdlYmtpdC1zbGlkZXItdGh1bWIge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICB3aWR0aDogLjE3ZW07XG4gICAgICAgIGhlaWdodDogLjdlbTtcbiAgICAgICAgbWFyZ2luLXRvcDogLS4yN2VtO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAuMWVtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTpmb2N1czo6LXdlYmtpdC1zbGlkZXItcnVubmFibGUtdHJhY2sge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgIH1cbiAgICBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdOjotbW96LXJhbmdlLXRyYWNrIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYm9yZGVyOiAwIHNvbGlkICNlZWU7XG4gICAgICAgIHdpZHRoOiA5OCU7XG4gICAgICAgIGhlaWdodDogLjE3ZW07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogLjFlbTtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIC4ycyBlYXNlO1xuICAgIH1cbiAgICBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdOjotbW96LXJhbmdlLXRodW1iIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgYm9yZGVyOiAwIHNvbGlkICNlZWU7XG4gICAgICAgIHdpZHRoOiAuMTdlbTtcbiAgICAgICAgaGVpZ2h0OiAuN2VtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IC4xZW07XG4gICAgfVxuICAgIGlucHV0LnNlZWtbdHlwZT1yYW5nZV06Oi1tcy10cmFjayB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJvcmRlcjogMCBub25lO1xuICAgICAgICB3aWR0aDogOTglO1xuICAgICAgICBoZWlnaHQ6IC4xN2VtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAuMnMgZWFzZTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTo6LW1zLWZpbGwtbG93ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAuMWVtO1xuICAgIH1cbiAgICBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdOjotbXMtZmlsbC11cHBlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IC4xZW07XG4gICAgfVxuICAgIGlucHV0LnNlZWtbdHlwZT1yYW5nZV06Oi1tcy10aHVtYiB7XG4gICAgICAgIG1hcmdpbi10b3A6IC0uMDFlbTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgd2lkdGg6IC4xN2VtO1xuICAgICAgICBoZWlnaHQ6IC43ZW07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogLjFlbTtcbiAgICB9XG4gICAgaW5wdXQuc2Vla1t0eXBlPXJhbmdlXTpmb2N1czo6LW1zLWZpbGwtbG93ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgIH1cbiAgICBpbnB1dC5zZWVrW3R5cGU9cmFuZ2VdOmZvY3VzOjotbXMtZmlsbC11cHBlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XG4gICAgfSAqL1xuICAgIC8qIDw8IGlucHV0W3R5cGU9cmFuZ2VdIGNsYXNzOiBzZWVrICovXG5cbjwvc3R5bGU+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBFQXFDcUMsR0FBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUQ1QyxHQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzREFGRyxHQUFPOzs7OztzQkFFcEIsR0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWpDUCxVQUFVLEdBQUcsS0FBSzs7S0FDbEIsT0FBTztNQUNILFVBQVU7bUJBQ1YsVUFBVSxHQUFHLEtBQUs7O21CQUVsQixVQUFVLEdBQUcsSUFBSTs7OztLQUlyQixNQUFNO0tBQ04sT0FBTztLQUNQLFNBQVM7O2dCQUVFLFlBQVksQ0FBQyxLQUFLO2tCQUM3QixVQUFVLEdBQUcsS0FBSztFQUNsQixNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSztFQUNsQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSztNQUNoQyxPQUFPLEdBQUcsb0JBQW9CLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUc7OztnQkFHekQsb0JBQW9CO1FBQzVCLEtBQUssNERBQTRELE1BQU0sa0JBQWtCLE9BQU8sTUFBSyxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLElBQ3JJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFDaEIsSUFBSSxDQUFDLElBQUk7R0FDQSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU07R0FDdkIsYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTO0tBQzVCLEtBQUssQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2RkNLRixHQUErQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQUQvRCxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttREFGTSxHQUFJOzs7OzttQkFFakIsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTdCSixPQUFPLEdBQUcsS0FBSzs7S0FDZixJQUFJO01BQ0EsT0FBTzttQkFDUCxPQUFPLEdBQUcsS0FBSzs7bUJBRWYsT0FBTyxHQUFHLElBQUk7Ozs7S0FJbEIsU0FBUzs7Z0JBQ0UsK0JBQStCLENBQUMsS0FBSztrQkFDaEQsT0FBTyxHQUFHLEtBQUs7RUFDZixTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSztNQUNqQyxPQUFPLEdBQUcsc0JBQXNCLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUc7OztnQkFHM0Qsc0JBQXNCO0VBQ3BDLEtBQUssOERBQThELFNBQVMsTUFBSyxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLElBQzNHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFDaEIsSUFBSSxDQUFDLElBQUk7T0FDSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU07R0FDdkIsYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLO0tBQ3hCLEtBQUssQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswRENSVCxHQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWhCMUIsSUFBSTtLQUNYLEdBQUc7O2dCQUNLLHVCQUF1QjtFQUMvQixLQUFLLDJEQUEyRCxJQUFJLE1BQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxJQUNuRyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQ2hCLElBQUksQ0FBQyxJQUFJO0dBQ04sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO0dBQ2QsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHOzs7O0tBR3pCLFdBQVc7TUFDUCxPQUFPLEdBQUcsdUJBQXVCLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQ2lCakUsR0FBSzs7OztnQ0FBVixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQUFDLEdBQUs7Ozs7K0JBQVYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBR00sR0FBQyxJQUFDLE1BQU07Ozs7c0JBQ1IsR0FBQyxJQUFDLEtBQUs7Ozs7c0JBQ1AsR0FBQyxJQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQUhBLEdBQUMsSUFBQyxTQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUVBQVgsR0FBQyxJQUFDLFNBQVM7Ozs7NkRBQ2pCLEdBQUMsSUFBQyxNQUFNOzZEQUNSLEdBQUMsSUFBQyxLQUFLOzZEQUNQLEdBQUMsSUFBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFOakIsR0FBSSxRQUFLLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytEQUZ1QixHQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ExQnhDLElBQUk7S0FHZCxLQUFLOztnQkFDTSx1QkFBdUI7TUFDM0IsSUFBSSwrREFBK0QsSUFBSTtFQUMzRSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUk7O1FBQ2hCLEtBQUssQ0FBQyxJQUFJLElBQUcsSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxJQUM3QyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQ2hCLElBQUksQ0FBQyxJQUFJO21CQUNBLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTTtHQUNuQixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3BCLEtBQUssQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHOzs7O2dCQUlwQixnQkFBZ0I7OztNQUd2QixPQUFPLEdBQUcsdUJBQXVCLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUc7O0VBQ3BFLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0NBQXNDO0VBQ2xELE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJDZ0JoQixHQUFjLE1BQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUNaLEdBQVE7Ozs7Z0NBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttREFPWSxHQUFJOzs7Ozs7OEJBUGYsR0FBUTs7OzsrQkFBYixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O29DQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBR3VCLEdBQUksSUFBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQUFoQixHQUFJLElBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O21FQUFJLEdBQUksSUFBQyxDQUFDOzt1RUFBaEIsR0FBSSxJQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FMNUIsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUZBREUsR0FBa0M7Ozs7O3VCQUMvQyxHQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcENELElBQUk7O0tBRVgsa0NBQWtDO2tCQUNsQyxXQUFXLEdBQUcsSUFBSTtNQUNkLE9BQU8sR0FBRyx5QkFBeUIsR0FBRyxLQUFLLENBQUMsR0FBRyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRzs7O0tBRXpFLFFBQVE7S0FDTCxjQUFjOztnQkFDTix5QkFBeUI7RUFDdkMsS0FBSywrREFBK0QsSUFBSSxNQUFLLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssSUFDdkcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUNoQixJQUFJLENBQUMsSUFBSTttQkFDQSxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUc7bUJBQ25CLGNBQWMsR0FBRyxRQUFRLENBQUMsTUFBTTtLQUNqQyxLQUFLLENBQUMsR0FBRyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRzs7O0tBRy9CLFdBQVcsR0FBRyxJQUFJOztLQUNsQixJQUFJO01BQ0EsV0FBVzttQkFDWCxXQUFXLEdBQUcsS0FBSzs7bUJBRW5CLFdBQVcsR0FBRyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQzhCUCxHQUFPOzs7O2tDQUFaLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQUMsR0FBTzs7OztpQ0FBWixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O3NDQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFFdUIsR0FBRyxLQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBQWQsR0FBRyxLQUFDLENBQUM7O2tEQUNZLEdBQUcsS0FBQyxDQUFDO3NEQUFTLEdBQUcsS0FBQyxDQUFDOzsrQ0FBdUIsR0FBRyxLQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs4Q0FBekQsR0FBSTs7Ozs7Ozs7O2lFQURGLEdBQUcsS0FBQyxDQUFDOzsrRUFBZCxHQUFHLEtBQUMsQ0FBQzs7Ozs2RUFDWSxHQUFHLEtBQUMsQ0FBQzs7OztpRkFBUyxHQUFHLEtBQUMsQ0FBQzs7OzttRkFBdUIsR0FBRyxLQUFDLENBQUM7Ozs7OzsrQ0FBekQsR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBb0JiLEdBQVEsSUFBQyxDQUFDLEVBQUUsWUFBWTs7Ozs2QkFDRixHQUFRLElBQUMsQ0FBQyxFQUFFLGNBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lEQUF0RCxHQUFRLElBQUMsQ0FBQyxFQUFFLFlBQVk7O3VEQUNQLEdBQVEsSUFBQyxDQUFDLEVBQUUsWUFBWTsyREFBUyxHQUFRLElBQUMsQ0FBQyxFQUFFLGNBQWM7O29EQUF1QixHQUFRLElBQUMsQ0FBQyxFQUFFLGNBQWM7Ozs7Ozs7Ozs7Ozs7OzhDQUF0SCxHQUFJOzs7Ozs7Ozt1RUFGTCxHQUFRLElBQUMsQ0FBQyxFQUFFLFlBQVk7dUVBQ0YsR0FBUSxJQUFDLENBQUMsRUFBRSxjQUFjOztxRkFBdEQsR0FBUSxJQUFDLENBQUMsRUFBRSxZQUFZOzs7O21GQUNQLEdBQVEsSUFBQyxDQUFDLEVBQUUsWUFBWTs7Ozt1RkFBUyxHQUFRLElBQUMsQ0FBQyxFQUFFLGNBQWM7Ozs7eUZBQXVCLEdBQVEsSUFBQyxDQUFDLEVBQUUsY0FBYzs7Ozs7OytDQUF0SCxHQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFYaEIsR0FBUTs7OztnQ0FBYixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUFDLEdBQVE7Ozs7K0JBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBRWtDLEdBQUcsS0FBQyxjQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQUF0QyxHQUFHLEtBQUMsWUFBWTs7a0RBQ0MsR0FBRyxLQUFDLFlBQVk7c0RBQVUsR0FBRyxLQUFDLFlBQVk7OytDQUF1QixHQUFHLEtBQUMsWUFBWTs7Ozs7Ozs7Ozs7OzhDQUEzRixHQUFJOzs7Ozs7Ozs7a0VBRFMsR0FBRyxLQUFDLGNBQWM7O2dGQUF0QyxHQUFHLEtBQUMsWUFBWTs7Ozs4RUFDQyxHQUFHLEtBQUMsWUFBWTs7OztrRkFBVSxHQUFHLEtBQUMsWUFBWTs7OztvRkFBdUIsR0FBRyxLQUFDLFlBQVk7Ozs7OzsrQ0FBM0YsR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBbEI5QixHQUFPLE1BQUcsQ0FBQztrQkFPTixHQUFPLE1BQUcsQ0FBQzs7Ozs7Ozs7bUJBT2hCLEdBQVEsTUFBRyxDQUFDO21CQU9QLEdBQVEsTUFBRyxDQUFDOzs7Ozs7OzsyQkFZVixHQUFJOzs7OzsyQkFDRixHQUFJOzs7OzsyQkFDTixHQUFJOzs7Ozs7Ozs7c0JBdENTLEdBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBQUosR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lFQUFKLEdBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnRUFvQ2pCLEdBQUk7OztrRUFDRixHQUFJOzs7Z0VBQ04sR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWhGcEIsSUFBSSxHQUFHLEVBQUU7S0FDVCxPQUFPO0tBQ1AsT0FBTyxHQUFHLENBQUM7O0NBRWxCLE9BQU8sZ0JBQWdCLGVBQWU7RUFDckMsS0FBSyw0Q0FBMkMsSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxJQUMxRSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQ2hCLElBQUksQ0FBQyxJQUFJO09BQ0ksSUFBSTtPQUNKLEdBQUc7O09BQ0gsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFFLEVBQUU7SUFDMUIsR0FBRyxLQUNDLFlBQVksRUFBRyxFQUFFLENBQUMsQ0FBQyxHQUNuQixVQUFVLEVBQUcsRUFBRSxDQUFDLENBQUM7SUFFckIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHOzs7bUJBRWpCLE9BQU8sR0FBRyxJQUFJO0dBQ2QsYUFBYSxDQUFDLEdBQUcsQ0FBQyxPQUFPO0dBQ3pCLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSTs7T0FDcEIsT0FBTyxJQUFJLFNBQVM7b0JBQ3BCLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTTs7Ozs7S0FLaEMsUUFBUTtLQUNSLFFBQVE7O09BQ04sV0FBVyxHQUFHLGFBQWEsQ0FBQyxTQUFTLENBQUMsS0FBSztrQkFDN0MsT0FBTyxHQUFHLFNBQVM7a0JBQ25CLE9BQU8sR0FBRyxTQUFTO2tCQUNuQixRQUFRLEdBQUcsS0FBSztrQkFDaEIsUUFBUSxHQUFHLFFBQVEsQ0FBQyxNQUFNOzs7S0FFMUIscUJBQXFCOztPQUNuQixTQUFTLEdBQUcsZUFBZSxDQUFDLFNBQVMsQ0FBQyxLQUFLO0VBQzdDLHFCQUFxQixHQUFHLEtBQUs7Ozs7Ozs7Ozs7Ozs7O0VBYU0sSUFBSTs7Ozs7RUFjSixJQUFJOzs7OztFQVFaLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0M1RS9CLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGNBQWM7O0tBQ2hELFFBQVE7RUFDUixRQUFRO0dBQ0osSUFBSSxFQUFFLFFBQVE7R0FDZCxNQUFNLEVBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPOzs7Ozs7R0FPdkMsSUFBSSxFQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTzs7Ozs7OztHQU9yQyxVQUFVLEVBQUUsQ0FBQzs7R0FFYixPQUFPLEVBQUUsS0FBSztHQUNkLE1BQU07R0FDTixLQUFLO0dBQ0wsR0FBRyxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTREVixRQUFRLENBQUMsSUFBSSxZQUFZLFlBQVk7T0FDN0IsS0FBSyxHQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRztNQUFHLFFBQVEsQ0FBQyxJQUFJO01BQUcsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFtSjNHLFFBQVEsQ0FBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
