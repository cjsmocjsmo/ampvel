import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, o as onMount, v as validate_slots, U as TVlocalplayURL, e as element, c as claim_element, a as children, f as detach_dev, h as attr_dev, j as add_location, k as insert_dev, B as validate_each_argument, A as empty, C as destroy_each, t as text, p as space, b as claim_text, q as claim_space, l as append_dev, m as listen_dev, O as is_function, w as set_data_dev, n as noop, r as run_all, V as set_store_value, E as create_component, F as claim_component, G as mount_component, H as transition_in, I as transition_out, J as destroy_component, u as query_selector_all, P as check_outros, Q as group_outros } from './client.cdce950b.js';
import { C as Controls } from './Controls.adfd2c7f.js';

/* src/components/TVComps/Discovery.svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;
const file = "src/components/TVComps/Discovery.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (60:0) {#if visibleDis}
function create_if_block(ctx) {
	let ul;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-11aboip");
			add_location(ul, file, 60, 4, 1623);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(60:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (62:8) {#if showlistcount > 0}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handleDiscovery*/ 17) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(62:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (63:12) {#each showlist as sshow }
function create_each_block(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[6].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[6].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-11aboip");
			add_location(a, file, 64, 20, 1740);
			attr_dev(span, "class", "svelte-11aboip");
			add_location(span, file, 65, 20, 1839);
			attr_dev(li, "class", "svelte-11aboip");
			add_location(li, file, 63, 16, 1715);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handleDiscovery*/ ctx[4](/*sshow*/ ctx[6].tvfspath))) /*handleDiscovery*/ ctx[4](/*sshow*/ ctx[6].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[6].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[6].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(63:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Discovery");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Discovery");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file, 57, 0, 1555);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	onMount(async function getDiscovery() {
		let addr = `http://192.168.0.42:8888/intDiscovery?season=01`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			console.log(data[0].episode);
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	});

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handleDiscovery = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Discovery> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Discovery", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(5, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		fuckDis,
		getPlayMedia,
		handleDiscovery
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(5, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("fuckDis" in $$props) $$invalidate(3, fuckDis = $$props.fuckDis);
		if ("handleDiscovery" in $$props) $$invalidate(4, handleDiscovery = $$props.handleDiscovery);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [showlist, showlistcount, visibleDis, fuckDis, handleDiscovery, LP];
}

class Discovery extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { LP: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Discovery",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[5] === undefined && !("LP" in props)) {
			console_1.warn("<Discovery> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Discovery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Discovery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Enterprise.svelte generated by Svelte v3.24.0 */

const { console: console_1$1 } = globals;
const file$1 = "src/components/TVComps/Enterprise.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (70:0) {#if visibleEnt}
function create_if_block$1(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*Entshowlistcount*/ ctx[1] > 0 && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$1, 71, 8, 2032);
			add_location(button1, file$1, 72, 8, 2089);
			add_location(button2, file$1, 73, 8, 2146);
			add_location(button3, file$1, 74, 8, 2203);
			add_location(nav, file$1, 70, 4, 2018);
			attr_dev(ul, "class", "svelte-13j0val");
			add_location(ul, file$1, 77, 4, 2268);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleEnterprise1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleEnterprise2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleEnterprise3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleEnterprise4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*Entshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(70:0) {#if visibleEnt}",
		ctx
	});

	return block;
}

// (79:8) {#if Entshowlistcount > 0}
function create_if_block_1$1(ctx) {
	let each_1_anchor;
	let each_value = /*Entshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Entshowlist, handlePlayShow*/ 257) {
				each_value = /*Entshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(79:8) {#if Entshowlistcount > 0}",
		ctx
	});

	return block;
}

// (80:12) {#each Entshowlist as sshow }
function create_each_block$1(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-13j0val");
			add_location(a, file$1, 81, 20, 2391);
			attr_dev(span, "class", "svelte-13j0val");
			add_location(span, file$1, 82, 20, 2489);
			attr_dev(li, "class", "svelte-13j0val");
			add_location(li, file$1, 80, 16, 2366);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].tvfspath))) /*handlePlayShow*/ ctx[8](/*sshow*/ ctx[11].tvfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*Entshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*Entshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(80:12) {#each Entshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleEnt*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Enterprise");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Enterprise");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$1, 67, 0, 1948);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckEnt*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleEnt*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$1(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$1($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let Entshowlist;
	let Entshowlistcount;
	let visibleEnt = false;

	async function getEnterprise(x) {
		let addr = `http://192.168.0.42:8888/intEnterprise?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, Entshowlist = data);
			$$invalidate(1, Entshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleEnterprise1 = () => {
		let promise = getEnterprise(`01`).catch(err => console.log(err));
	};

	let handleEnterprise2 = () => {
		let promise = getEnterprise(`02`).catch(err => console.log(err));
	};

	let handleEnterprise3 = () => {
		let promise = getEnterprise(`03`).catch(err => console.log(err));
	};

	let handleEnterprise4 = () => {
		let promise = getEnterprise(`04`).catch(err => console.log(err));
	};

	let fuckEnt = () => {
		if (visibleEnt) {
			$$invalidate(2, visibleEnt = false);
		} else {
			$$invalidate(2, visibleEnt = true);
		}
	};

	let handlePlayShow = media => {
		if (LP) {
			console.log("this is media");
			console.log(media);

			// let foo = media.split("TVShows", 2)
			let newpath = `http://192.168.0.42:8082` + "/" + media;

			console.log("this is newpath");
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleEnt = false);
		} else {
			let promise = getPlayMedia$1(media).catch(err => console.log(err));
			$$invalidate(2, visibleEnt = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Enterprise> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Enterprise", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		getEnterprise,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		getPlayMedia: getPlayMedia$1,
		handlePlayShow
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("Entshowlist" in $$props) $$invalidate(0, Entshowlist = $$props.Entshowlist);
		if ("Entshowlistcount" in $$props) $$invalidate(1, Entshowlistcount = $$props.Entshowlistcount);
		if ("visibleEnt" in $$props) $$invalidate(2, visibleEnt = $$props.visibleEnt);
		if ("handleEnterprise1" in $$props) $$invalidate(3, handleEnterprise1 = $$props.handleEnterprise1);
		if ("handleEnterprise2" in $$props) $$invalidate(4, handleEnterprise2 = $$props.handleEnterprise2);
		if ("handleEnterprise3" in $$props) $$invalidate(5, handleEnterprise3 = $$props.handleEnterprise3);
		if ("handleEnterprise4" in $$props) $$invalidate(6, handleEnterprise4 = $$props.handleEnterprise4);
		if ("fuckEnt" in $$props) $$invalidate(7, fuckEnt = $$props.fuckEnt);
		if ("handlePlayShow" in $$props) $$invalidate(8, handlePlayShow = $$props.handlePlayShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		Entshowlist,
		Entshowlistcount,
		visibleEnt,
		handleEnterprise1,
		handleEnterprise2,
		handleEnterprise3,
		handleEnterprise4,
		fuckEnt,
		handlePlayShow,
		LP
	];
}

class Enterprise extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Enterprise",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$1.warn("<Enterprise> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Enterprise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Enterprise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Orville.svelte generated by Svelte v3.24.0 */

const { console: console_1$2 } = globals;
const file$2 = "src/components/TVComps/Orville.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (61:0) {#if visibleOrv}
function create_if_block$2(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*ORVshowlistcount*/ ctx[1] > 0 && create_if_block_1$2(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$2, 62, 8, 1713);
			add_location(button1, file$2, 63, 8, 1762);
			add_location(nav, file$2, 61, 4, 1699);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$2, 66, 4, 1819);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleOR1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleOR2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*ORVshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(61:0) {#if visibleOrv}",
		ctx
	});

	return block;
}

// (68:8) {#if ORVshowlistcount > 0}
function create_if_block_1$2(ctx) {
	let each_1_anchor;
	let each_value = /*ORVshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ORVshowlist, handlePlayShowOr*/ 65) {
				each_value = /*ORVshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(68:8) {#if ORVshowlistcount > 0}",
		ctx
	});

	return block;
}

// (69:12) {#each ORVshowlist as sshow }
function create_each_block$2(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$2, 70, 20, 1942);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$2, 71, 20, 2043);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$2, 69, 16, 1917);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].movfspath))) /*handlePlayShowOr*/ ctx[6](/*sshow*/ ctx[9].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*ORVshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*ORVshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(69:12) {#each ORVshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleOrv*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Orville");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Orville");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$2, 58, 0, 1633);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckOrv*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleOrv*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$2(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$2($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let ORVshowlist;
	let ORVshowlistcount;
	let visibleOrv = false;

	async function getOrville(x) {
		let addr = `http://192.168.0.42:8888/intOrville?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, ORVshowlist = data);
			$$invalidate(1, ORVshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleOR1 = () => {
		let promise = getOrville(`01`).catch(err => console.log(err));
	};

	let handleOR2 = () => {
		let promise = getOrville(`02`).catch(err => console.log(err));
	};

	let fuckOrv = () => {
		if (visibleOrv) {
			$$invalidate(2, visibleOrv = false);
		} else {
			$$invalidate(2, visibleOrv = true);
		}
	};

	let handlePlayShowOr = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleOrv = false);
		} else {
			let promise = getPlayMedia$2(media).catch(err => console.log(err));
			$$invalidate(2, visibleOrv = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Orville> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Orville", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		getOrville,
		handleOR1,
		handleOR2,
		fuckOrv,
		getPlayMedia: getPlayMedia$2,
		handlePlayShowOr
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("ORVshowlist" in $$props) $$invalidate(0, ORVshowlist = $$props.ORVshowlist);
		if ("ORVshowlistcount" in $$props) $$invalidate(1, ORVshowlistcount = $$props.ORVshowlistcount);
		if ("visibleOrv" in $$props) $$invalidate(2, visibleOrv = $$props.visibleOrv);
		if ("handleOR1" in $$props) $$invalidate(3, handleOR1 = $$props.handleOR1);
		if ("handleOR2" in $$props) $$invalidate(4, handleOR2 = $$props.handleOR2);
		if ("fuckOrv" in $$props) $$invalidate(5, fuckOrv = $$props.fuckOrv);
		if ("handlePlayShowOr" in $$props) $$invalidate(6, handlePlayShowOr = $$props.handlePlayShowOr);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		ORVshowlist,
		ORVshowlistcount,
		visibleOrv,
		handleOR1,
		handleOR2,
		fuckOrv,
		handlePlayShowOr,
		LP
	];
}

class Orville extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Orville",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$2.warn("<Orville> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Orville>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Orville>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/STTV.svelte generated by Svelte v3.24.0 */

const { console: console_1$3 } = globals;
const file$3 = "src/components/TVComps/STTV.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (65:0) {#if visibleDis}
function create_if_block$3(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*showlistcount*/ ctx[1] > 0 && create_if_block_1$3(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$3, 66, 8, 1776);
			add_location(button1, file$3, 67, 8, 1832);
			add_location(button2, file$3, 68, 8, 1888);
			add_location(nav, file$3, 65, 4, 1762);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$3, 71, 4, 1952);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleSTTVClick1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleSTTVClick2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleSTTVClick3*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*showlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(65:0) {#if visibleDis}",
		ctx
	});

	return block;
}

// (73:8) {#if showlistcount > 0}
function create_if_block_1$3(ctx) {
	let each_1_anchor;
	let each_value = /*showlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*showlist, handlePlayShowSTTV*/ 129) {
				each_value = /*showlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(73:8) {#if showlistcount > 0}",
		ctx
	});

	return block;
}

// (74:12) {#each showlist as sshow }
function create_each_block$3(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[10].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[10].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$3, 75, 20, 2069);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$3, 76, 20, 2172);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$3, 74, 16, 2044);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].movfspath))) /*handlePlayShowSTTV*/ ctx[7](/*sshow*/ ctx[10].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*showlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[10].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*showlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[10].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(74:12) {#each showlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleDis*/ ctx[2] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("STTV");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "STTV");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$3, 62, 0, 1698);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckDis*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleDis*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$3(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$3($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let showlist;
	let showlistcount;
	let visibleDis = false;

	async function getSTTV(x) {
		let addr = `http://192.168.0.42:8888/intSTTV?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, showlist = data);
			$$invalidate(1, showlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleSTTVClick1 = () => {
		let promise = getSTTV(`01`).catch(err => console.log(err));
	};

	let handleSTTVClick2 = () => {
		let promise = getSTTV(`02`).catch(err => console.log(err));
	};

	let handleSTTVClick3 = () => {
		let promise = getSTTV(`03`).catch(err => console.log(err));
	};

	let fuckDis = () => {
		if (visibleDis) {
			$$invalidate(2, visibleDis = false);
		} else {
			$$invalidate(2, visibleDis = true);
		}
	};

	let handlePlayShowSTTV = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleDis = false);
		} else {
			let promise = getPlayMedia$3(media).catch(err => console.log(err));
			$$invalidate(2, visibleDis = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<STTV> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("STTV", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		showlist,
		showlistcount,
		visibleDis,
		getSTTV,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		getPlayMedia: getPlayMedia$3,
		handlePlayShowSTTV
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(8, LP = $$props.LP);
		if ("showlist" in $$props) $$invalidate(0, showlist = $$props.showlist);
		if ("showlistcount" in $$props) $$invalidate(1, showlistcount = $$props.showlistcount);
		if ("visibleDis" in $$props) $$invalidate(2, visibleDis = $$props.visibleDis);
		if ("handleSTTVClick1" in $$props) $$invalidate(3, handleSTTVClick1 = $$props.handleSTTVClick1);
		if ("handleSTTVClick2" in $$props) $$invalidate(4, handleSTTVClick2 = $$props.handleSTTVClick2);
		if ("handleSTTVClick3" in $$props) $$invalidate(5, handleSTTVClick3 = $$props.handleSTTVClick3);
		if ("fuckDis" in $$props) $$invalidate(6, fuckDis = $$props.fuckDis);
		if ("handlePlayShowSTTV" in $$props) $$invalidate(7, handlePlayShowSTTV = $$props.handlePlayShowSTTV);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		showlist,
		showlistcount,
		visibleDis,
		handleSTTVClick1,
		handleSTTVClick2,
		handleSTTVClick3,
		fuckDis,
		handlePlayShowSTTV,
		LP
	];
}

class STTV extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { LP: 8 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "STTV",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[8] === undefined && !("LP" in props)) {
			console_1$3.warn("<STTV> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<STTV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<STTV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/TNG.svelte generated by Svelte v3.24.0 */

const { console: console_1$4 } = globals;
const file$4 = "src/components/TVComps/TNG.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (80:0) {#if visibleTNG}
function create_if_block$4(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*TNGshowlistcount*/ ctx[1] > 0 && create_if_block_1$4(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$4, 81, 8, 2185);
			add_location(button1, file$4, 82, 8, 2235);
			add_location(button2, file$4, 83, 8, 2285);
			add_location(button3, file$4, 84, 8, 2335);
			add_location(button4, file$4, 85, 8, 2385);
			add_location(button5, file$4, 86, 8, 2435);
			add_location(button6, file$4, 87, 8, 2485);
			add_location(nav, file$4, 80, 4, 2171);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$4, 90, 4, 2543);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleTNG1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleTNG2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleTNG3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleTNG4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleTNG5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleTNG6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleTNG7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*TNGshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(80:0) {#if visibleTNG}",
		ctx
	});

	return block;
}

// (92:8) {#if TNGshowlistcount > 0}
function create_if_block_1$4(ctx) {
	let each_1_anchor;
	let each_value = /*TNGshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TNGshowlist, handlePlayTNG*/ 2049) {
				each_value = /*TNGshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(92:8) {#if TNGshowlistcount > 0}",
		ctx
	});

	return block;
}

// (93:12) {#each TNGshowlist as sshow }
function create_each_block$4(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$4, 94, 20, 2666);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$4, 95, 20, 2764);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$4, 93, 16, 2641);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].movfspath))) /*handlePlayTNG*/ ctx[11](/*sshow*/ ctx[14].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*TNGshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*TNGshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(93:12) {#each TNGshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleTNG*/ ctx[2] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Next Generation");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Next Generation");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$4, 77, 0, 2093);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckTNG*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleTNG*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$4(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$4($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let TNGshowlist;
	let TNGshowlistcount;
	let visibleTNG = false;

	async function getTNG(x) {
		let addr = `http://192.168.0.42:8888/intTNG?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, TNGshowlist = data);
			$$invalidate(1, TNGshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleTNG1 = () => {
		let promise = getTNG(`01`).catch(err => console.log(err));
	};

	let handleTNG2 = () => {
		let promise = getTNG(`02`).catch(err => console.log(err));
	};

	let handleTNG3 = () => {
		let promise = getTNG(`03`).catch(err => console.log(err));
	};

	let handleTNG4 = () => {
		let promise = getTNG(`04`).catch(err => console.log(err));
	};

	let handleTNG5 = () => {
		let promise = getTNG(`05`).catch(err => console.log(err));
	};

	let handleTNG6 = () => {
		let promise = getTNG(`06`).catch(err => console.log(err));
	};

	let handleTNG7 = () => {
		let promise = getTNG(`07`).catch(err => console.log(err));
	};

	let fuckTNG = () => {
		if (visibleTNG) {
			$$invalidate(2, visibleTNG = false);
		} else {
			$$invalidate(2, visibleTNG = true);
		}
	};

	let handlePlayTNG = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleTNG = false);
		} else {
			let promise = getPlayMedia$4(media).catch(err => console.log(err));
			$$invalidate(2, visibleTNG = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<TNG> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TNG", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		getTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		getPlayMedia: getPlayMedia$4,
		handlePlayTNG
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("TNGshowlist" in $$props) $$invalidate(0, TNGshowlist = $$props.TNGshowlist);
		if ("TNGshowlistcount" in $$props) $$invalidate(1, TNGshowlistcount = $$props.TNGshowlistcount);
		if ("visibleTNG" in $$props) $$invalidate(2, visibleTNG = $$props.visibleTNG);
		if ("handleTNG1" in $$props) $$invalidate(3, handleTNG1 = $$props.handleTNG1);
		if ("handleTNG2" in $$props) $$invalidate(4, handleTNG2 = $$props.handleTNG2);
		if ("handleTNG3" in $$props) $$invalidate(5, handleTNG3 = $$props.handleTNG3);
		if ("handleTNG4" in $$props) $$invalidate(6, handleTNG4 = $$props.handleTNG4);
		if ("handleTNG5" in $$props) $$invalidate(7, handleTNG5 = $$props.handleTNG5);
		if ("handleTNG6" in $$props) $$invalidate(8, handleTNG6 = $$props.handleTNG6);
		if ("handleTNG7" in $$props) $$invalidate(9, handleTNG7 = $$props.handleTNG7);
		if ("fuckTNG" in $$props) $$invalidate(10, fuckTNG = $$props.fuckTNG);
		if ("handlePlayTNG" in $$props) $$invalidate(11, handlePlayTNG = $$props.handlePlayTNG);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		TNGshowlist,
		TNGshowlistcount,
		visibleTNG,
		handleTNG1,
		handleTNG2,
		handleTNG3,
		handleTNG4,
		handleTNG5,
		handleTNG6,
		handleTNG7,
		fuckTNG,
		handlePlayTNG,
		LP
	];
}

class TNG extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TNG",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$4.warn("<TNG> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<TNG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<TNG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/Voyager.svelte generated by Svelte v3.24.0 */

const { console: console_1$5 } = globals;
const file$5 = "src/components/TVComps/Voyager.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (80:0) {#if visibleVoy}
function create_if_block$5(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let button4;
	let t8;
	let t9;
	let button5;
	let t10;
	let t11;
	let button6;
	let t12;
	let t13;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*VOYshowlistcount*/ ctx[1] > 0 && create_if_block_1$5(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			button4 = element("button");
			t8 = text("s5");
			t9 = space();
			button5 = element("button");
			t10 = text("s6");
			t11 = space();
			button6 = element("button");
			t12 = text("s7");
			t13 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			button4 = claim_element(nav_nodes, "BUTTON", {});
			var button4_nodes = children(button4);
			t8 = claim_text(button4_nodes, "s5");
			button4_nodes.forEach(detach_dev);
			t9 = claim_space(nav_nodes);
			button5 = claim_element(nav_nodes, "BUTTON", {});
			var button5_nodes = children(button5);
			t10 = claim_text(button5_nodes, "s6");
			button5_nodes.forEach(detach_dev);
			t11 = claim_space(nav_nodes);
			button6 = claim_element(nav_nodes, "BUTTON", {});
			var button6_nodes = children(button6);
			t12 = claim_text(button6_nodes, "s7");
			button6_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$5, 81, 8, 2177);
			add_location(button1, file$5, 82, 8, 2227);
			add_location(button2, file$5, 83, 8, 2277);
			add_location(button3, file$5, 84, 8, 2327);
			add_location(button4, file$5, 85, 8, 2377);
			add_location(button5, file$5, 86, 8, 2427);
			add_location(button6, file$5, 87, 8, 2477);
			add_location(nav, file$5, 80, 4, 2163);
			attr_dev(ul, "class", "svelte-10dqnzh");
			add_location(ul, file$5, 90, 4, 2535);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			append_dev(nav, t7);
			append_dev(nav, button4);
			append_dev(button4, t8);
			append_dev(nav, t9);
			append_dev(nav, button5);
			append_dev(button5, t10);
			append_dev(nav, t11);
			append_dev(nav, button6);
			append_dev(button6, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleVOY1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleVOY2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleVOY3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleVOY4*/ ctx[6], false, false, false),
					listen_dev(button4, "click", /*handleVOY5*/ ctx[7], false, false, false),
					listen_dev(button5, "click", /*handleVOY6*/ ctx[8], false, false, false),
					listen_dev(button6, "click", /*handleVOY7*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*VOYshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(80:0) {#if visibleVoy}",
		ctx
	});

	return block;
}

// (92:8) {#if VOYshowlistcount > 0}
function create_if_block_1$5(ctx) {
	let each_1_anchor;
	let each_value = /*VOYshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*VOYshowlist, handlePlayVOY*/ 2049) {
				each_value = /*VOYshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(92:8) {#if VOYshowlistcount > 0}",
		ctx
	});

	return block;
}

// (93:12) {#each VOYshowlist as sshow }
function create_each_block$5(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[14].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[14].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-10dqnzh");
			add_location(a, file$5, 94, 20, 2658);
			attr_dev(span, "class", "svelte-10dqnzh");
			add_location(span, file$5, 95, 20, 2756);
			attr_dev(li, "class", "svelte-10dqnzh");
			add_location(li, file$5, 93, 16, 2633);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].movfspath))) /*handlePlayVOY*/ ctx[11](/*sshow*/ ctx[14].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*VOYshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[14].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*VOYshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[14].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(93:12) {#each VOYshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleVoy*/ ctx[2] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Voyager");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Voyager");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$5, 77, 0, 2097);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckVOY*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleVoy*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$5(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$5($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let VOYshowlist;
	let VOYshowlistcount;
	let visibleVoy = false;

	async function getVOY(x) {
		let addr = `http://192.168.0.42:8888/intVoyager?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, VOYshowlist = data);
			$$invalidate(1, VOYshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleVOY1 = () => {
		let promise = getVOY(`01`).catch(err => console.log(err));
	};

	let handleVOY2 = () => {
		let promise = getVOY(`02`).catch(err => console.log(err));
	};

	let handleVOY3 = () => {
		let promise = getVOY(`03`).catch(err => console.log(err));
	};

	let handleVOY4 = () => {
		let promise = getVOY(`04`).catch(err => console.log(err));
	};

	let handleVOY5 = () => {
		let promise = getVOY(`05`).catch(err => console.log(err));
	};

	let handleVOY6 = () => {
		let promise = getVOY(`06`).catch(err => console.log(err));
	};

	let handleVOY7 = () => {
		let promise = getVOY(`07`).catch(err => console.log(err));
	};

	let fuckVOY = () => {
		if (visibleVoy) {
			$$invalidate(2, visibleVoy = false);
		} else {
			$$invalidate(2, visibleVoy = true);
		}
	};

	let handlePlayVOY = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			visibleVOY = false;
		} else {
			let promise = getPlayMedia$5(media).catch(err => console.log(err));
			visibleVOY = false;
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Voyager> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Voyager", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		getVOY,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		getPlayMedia: getPlayMedia$5,
		handlePlayVOY
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(12, LP = $$props.LP);
		if ("VOYshowlist" in $$props) $$invalidate(0, VOYshowlist = $$props.VOYshowlist);
		if ("VOYshowlistcount" in $$props) $$invalidate(1, VOYshowlistcount = $$props.VOYshowlistcount);
		if ("visibleVoy" in $$props) $$invalidate(2, visibleVoy = $$props.visibleVoy);
		if ("handleVOY1" in $$props) $$invalidate(3, handleVOY1 = $$props.handleVOY1);
		if ("handleVOY2" in $$props) $$invalidate(4, handleVOY2 = $$props.handleVOY2);
		if ("handleVOY3" in $$props) $$invalidate(5, handleVOY3 = $$props.handleVOY3);
		if ("handleVOY4" in $$props) $$invalidate(6, handleVOY4 = $$props.handleVOY4);
		if ("handleVOY5" in $$props) $$invalidate(7, handleVOY5 = $$props.handleVOY5);
		if ("handleVOY6" in $$props) $$invalidate(8, handleVOY6 = $$props.handleVOY6);
		if ("handleVOY7" in $$props) $$invalidate(9, handleVOY7 = $$props.handleVOY7);
		if ("fuckVOY" in $$props) $$invalidate(10, fuckVOY = $$props.fuckVOY);
		if ("handlePlayVOY" in $$props) $$invalidate(11, handlePlayVOY = $$props.handlePlayVOY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		VOYshowlist,
		VOYshowlistcount,
		visibleVoy,
		handleVOY1,
		handleVOY2,
		handleVOY3,
		handleVOY4,
		handleVOY5,
		handleVOY6,
		handleVOY7,
		fuckVOY,
		handlePlayVOY,
		LP
	];
}

class Voyager extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { LP: 12 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Voyager",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[12] === undefined && !("LP" in props)) {
			console_1$5.warn("<Voyager> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<Voyager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<Voyager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LastShip.svelte generated by Svelte v3.24.0 */

const { console: console_1$6 } = globals;
const file$6 = "src/components/TVComps/LastShip.svelte";

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (69:0) {#if visibleLS}
function create_if_block$6(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let t4;
	let t5;
	let button3;
	let t6;
	let t7;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LSshowlistcount*/ ctx[1] > 0 && create_if_block_1$6(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			button2 = element("button");
			t4 = text("s3");
			t5 = space();
			button3 = element("button");
			t6 = text("s4");
			t7 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(nav_nodes);
			button2 = claim_element(nav_nodes, "BUTTON", {});
			var button2_nodes = children(button2);
			t4 = claim_text(button2_nodes, "s3");
			button2_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			button3 = claim_element(nav_nodes, "BUTTON", {});
			var button3_nodes = children(button3);
			t6 = claim_text(button3_nodes, "s4");
			button3_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$6, 70, 8, 1855);
			add_location(button1, file$6, 71, 8, 1904);
			add_location(button2, file$6, 72, 8, 1953);
			add_location(button3, file$6, 73, 8, 2002);
			add_location(nav, file$6, 69, 4, 1841);
			attr_dev(ul, "class", "svelte-1omye9l");
			add_location(ul, file$6, 76, 4, 2059);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			append_dev(nav, t3);
			append_dev(nav, button2);
			append_dev(button2, t4);
			append_dev(nav, t5);
			append_dev(nav, button3);
			append_dev(button3, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLS2*/ ctx[4], false, false, false),
					listen_dev(button2, "click", /*handleLS3*/ ctx[5], false, false, false),
					listen_dev(button3, "click", /*handleLS4*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LSshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(69:0) {#if visibleLS}",
		ctx
	});

	return block;
}

// (78:8) {#if LSshowlistcount > 0}
function create_if_block_1$6(ctx) {
	let each_1_anchor;
	let each_value = /*LSshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LSshowlist, handlePlayLS*/ 257) {
				each_value = /*LSshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(78:8) {#if LSshowlistcount > 0}",
		ctx
	});

	return block;
}

// (79:12) {#each LSshowlist as sshow }
function create_each_block$6(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[11].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[11].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-1omye9l");
			add_location(a, file$6, 80, 20, 2180);
			attr_dev(span, "class", "svelte-1omye9l");
			add_location(span, file$6, 81, 20, 2277);
			attr_dev(li, "class", "svelte-1omye9l");
			add_location(li, file$6, 79, 16, 2155);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].movfspath))) /*handlePlayLS*/ ctx[8](/*sshow*/ ctx[11].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LSshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[11].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LSshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[11].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(79:12) {#each LSshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLS*/ ctx[2] && create_if_block$6(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("The Last Ship");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "The Last Ship");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$6, 66, 0, 1770);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLS*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$6(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$6($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LSshowlist;
	let LSshowlistcount;

	async function getLS(x) {
		let addr = `http://192.168.0.42:8888/intLastShip?season=${x}`;

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			$$invalidate(0, LSshowlist = data);
			$$invalidate(1, LSshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLS1 = () => {
		let promise = getLS(`01`).catch(err => console.log(err));
	};

	let handleLS2 = () => {
		let promise = getLS(`02`).catch(err => console.log(err));
	};

	let handleLS3 = () => {
		let promise = getLS(`03`).catch(err => console.log(err));
	};

	let handleLS4 = () => {
		let promise = getLS(`04`).catch(err => console.log(err));
	};

	let visibleLS = false;

	let fuckLS = () => {
		if (visibleLS) {
			$$invalidate(2, visibleLS = false);
		} else {
			$$invalidate(2, visibleLS = true);
		}
	};

	let handlePlayLS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + foo[1];
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleLS = false);
		} else {
			let promise = getPlayMedia$6(media).catch(err => console.log(err));
			$$invalidate(2, visibleLS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<LastShip> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LastShip", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		TVlocalplayURL,
		LP,
		LSshowlist,
		LSshowlistcount,
		getLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		visibleLS,
		fuckLS,
		getPlayMedia: getPlayMedia$6,
		handlePlayLS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(9, LP = $$props.LP);
		if ("LSshowlist" in $$props) $$invalidate(0, LSshowlist = $$props.LSshowlist);
		if ("LSshowlistcount" in $$props) $$invalidate(1, LSshowlistcount = $$props.LSshowlistcount);
		if ("handleLS1" in $$props) $$invalidate(3, handleLS1 = $$props.handleLS1);
		if ("handleLS2" in $$props) $$invalidate(4, handleLS2 = $$props.handleLS2);
		if ("handleLS3" in $$props) $$invalidate(5, handleLS3 = $$props.handleLS3);
		if ("handleLS4" in $$props) $$invalidate(6, handleLS4 = $$props.handleLS4);
		if ("visibleLS" in $$props) $$invalidate(2, visibleLS = $$props.visibleLS);
		if ("fuckLS" in $$props) $$invalidate(7, fuckLS = $$props.fuckLS);
		if ("handlePlayLS" in $$props) $$invalidate(8, handlePlayLS = $$props.handlePlayLS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LSshowlist,
		LSshowlistcount,
		visibleLS,
		handleLS1,
		handleLS2,
		handleLS3,
		handleLS4,
		fuckLS,
		handlePlayLS,
		LP
	];
}

class LastShip extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { LP: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LastShip",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[9] === undefined && !("LP" in props)) {
			console_1$6.warn("<LastShip> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LastShip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LastShip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVComps/LostInSpace.svelte generated by Svelte v3.24.0 */

const { console: console_1$7 } = globals;
const file$7 = "src/components/TVComps/LostInSpace.svelte";

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (63:0) {#if visibleLIS}
function create_if_block$7(ctx) {
	let nav;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let t3;
	let ul;
	let mounted;
	let dispose;
	let if_block = /*LISshowlistcount*/ ctx[1] > 0 && create_if_block_1$7(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			button0 = element("button");
			t0 = text("s1");
			t1 = space();
			button1 = element("button");
			t2 = text("s2");
			t3 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", {});
			var nav_nodes = children(nav);
			button0 = claim_element(nav_nodes, "BUTTON", {});
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "s1");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			button1 = claim_element(nav_nodes, "BUTTON", {});
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "s2");
			button1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(button0, file$7, 64, 8, 1794);
			add_location(button1, file$7, 65, 8, 1844);
			add_location(nav, file$7, 63, 4, 1780);
			attr_dev(ul, "class", "svelte-nhp1xt");
			add_location(ul, file$7, 68, 4, 1902);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, button0);
			append_dev(button0, t0);
			append_dev(nav, t1);
			append_dev(nav, button1);
			append_dev(button1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*handleLIS1*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*handleLIS2*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*LISshowlistcount*/ ctx[1] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$7(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(63:0) {#if visibleLIS}",
		ctx
	});

	return block;
}

// (70:8) {#if LISshowlistcount > 0}
function create_if_block_1$7(ctx) {
	let each_1_anchor;
	let each_value = /*LISshowlist*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*LISshowlist, handlePlayShowLIS*/ 65) {
				each_value = /*LISshowlist*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(70:8) {#if LISshowlistcount > 0}",
		ctx
	});

	return block;
}

// (71:12) {#each LISshowlist as sshow }
function create_each_block$7(ctx) {
	let li;
	let a;
	let t0_value = /*sshow*/ ctx[9].title + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*sshow*/ ctx[9].episode + "";
	let t2;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "tvshows");
			attr_dev(a, "class", "svelte-nhp1xt");
			add_location(a, file$7, 72, 20, 2025);
			attr_dev(span, "class", "svelte-nhp1xt");
			add_location(span, file$7, 73, 20, 2127);
			attr_dev(li, "class", "svelte-nhp1xt");
			add_location(li, file$7, 71, 16, 2000);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t0);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(li, t3);

			if (!mounted) {
				dispose = listen_dev(
					a,
					"click",
					function () {
						if (is_function(/*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].movfspath))) /*handlePlayShowLIS*/ ctx[6](/*sshow*/ ctx[9].movfspath).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*LISshowlist*/ 1 && t0_value !== (t0_value = /*sshow*/ ctx[9].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*LISshowlist*/ 1 && t2_value !== (t2_value = /*sshow*/ ctx[9].episode + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(71:12) {#each LISshowlist as sshow }",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let button;
	let t0;
	let t1;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*visibleLIS*/ ctx[2] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			button = element("button");
			t0 = text("Lost In Space");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t0 = claim_text(button_nodes, "Lost In Space");
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(button, file$7, 60, 0, 1708);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t0);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*fuckLIS*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visibleLIS*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function getPlayMedia$7(x) {
	let addr = `http://192.168.0.42:8888/playMediaReact?tvshow=${x}`;

	fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
		console.log(data);
	}).catch(err => console.log(err));
}

function instance$7($$self, $$props, $$invalidate) {
	let { LP } = $$props;
	let LISshowlist;
	let LISshowlistcount;
	let visibleLIS = false;

	async function getLostInSpace(x) {
		let addr = `http://192.168.0.42:8888/intLostInSpace?season=${x}`;
		console.log(addr);

		fetch(addr, { mode: "cors", method: "GET" }).then(r => r.json()).then(data => {
			console.log(data);
			$$invalidate(0, LISshowlist = data);
			$$invalidate(1, LISshowlistcount = data.length);
		}).catch(err => console.log(err));
	}

	let handleLIS1 = () => {
		let promise = getLostInSpace(`01`).catch(err => console.log(err));
	};

	let handleLIS2 = () => {
		let promise = getLostInSpace(`02`).catch(err => console.log(err));
	};

	let fuckLIS = () => {
		if (visibleLIS) {
			$$invalidate(2, visibleLIS = false);
		} else {
			$$invalidate(2, visibleLIS = true);
		}
	};

	let handlePlayShowLIS = media => {
		if (LP) {
			console.log(media);
			let foo = media.split("TVShows", 2);
			let newpath = `http://192.168.0.42:8082` + media;
			console.log(newpath);
			TVlocalplayURL.set(newpath);
			$$invalidate(2, visibleLIS = false);
		} else {
			let promise = getPlayMedia$7(media).catch(err => console.log(err));
			$$invalidate(2, visibleLIS = false);
		}
	};

	const writable_props = ["LP"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<LostInSpace> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LostInSpace", $$slots, []);

	$$self.$set = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
	};

	$$self.$capture_state = () => ({
		onMount,
		TVlocalplayURL,
		LP,
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		getLostInSpace,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		getPlayMedia: getPlayMedia$7,
		handlePlayShowLIS
	});

	$$self.$inject_state = $$props => {
		if ("LP" in $$props) $$invalidate(7, LP = $$props.LP);
		if ("LISshowlist" in $$props) $$invalidate(0, LISshowlist = $$props.LISshowlist);
		if ("LISshowlistcount" in $$props) $$invalidate(1, LISshowlistcount = $$props.LISshowlistcount);
		if ("visibleLIS" in $$props) $$invalidate(2, visibleLIS = $$props.visibleLIS);
		if ("handleLIS1" in $$props) $$invalidate(3, handleLIS1 = $$props.handleLIS1);
		if ("handleLIS2" in $$props) $$invalidate(4, handleLIS2 = $$props.handleLIS2);
		if ("fuckLIS" in $$props) $$invalidate(5, fuckLIS = $$props.fuckLIS);
		if ("handlePlayShowLIS" in $$props) $$invalidate(6, handlePlayShowLIS = $$props.handlePlayShowLIS);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		LISshowlist,
		LISshowlistcount,
		visibleLIS,
		handleLIS1,
		handleLIS2,
		fuckLIS,
		handlePlayShowLIS,
		LP
	];
}

class LostInSpace extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { LP: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LostInSpace",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LP*/ ctx[7] === undefined && !("LP" in props)) {
			console_1$7.warn("<LostInSpace> was created without expected prop 'LP'");
		}
	}

	get LP() {
		throw new Error("<LostInSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LP(value) {
		throw new Error("<LostInSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/TVShowsListComp.svelte generated by Svelte v3.24.0 */
const file$8 = "src/components/TVShowsListComp.svelte";

function create_fragment$8(ctx) {
	let nav;
	let discovery;
	let t0;
	let enterprise;
	let t1;
	let orville;
	let t2;
	let sttv;
	let t3;
	let tng;
	let t4;
	let voy;
	let t5;
	let ls;
	let t6;
	let lis;
	let current;

	discovery = new Discovery({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	enterprise = new Enterprise({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	orville = new Orville({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	sttv = new STTV({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	tng = new TNG({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	voy = new Voyager({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	ls = new LastShip({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	lis = new LostInSpace({
			props: { LP: /*LOCALPLAY*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			create_component(discovery.$$.fragment);
			t0 = space();
			create_component(enterprise.$$.fragment);
			t1 = space();
			create_component(orville.$$.fragment);
			t2 = space();
			create_component(sttv.$$.fragment);
			t3 = space();
			create_component(tng.$$.fragment);
			t4 = space();
			create_component(voy.$$.fragment);
			t5 = space();
			create_component(ls.$$.fragment);
			t6 = space();
			create_component(lis.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(discovery.$$.fragment, nav_nodes);
			t0 = claim_space(nav_nodes);
			claim_component(enterprise.$$.fragment, nav_nodes);
			t1 = claim_space(nav_nodes);
			claim_component(orville.$$.fragment, nav_nodes);
			t2 = claim_space(nav_nodes);
			claim_component(sttv.$$.fragment, nav_nodes);
			t3 = claim_space(nav_nodes);
			claim_component(tng.$$.fragment, nav_nodes);
			t4 = claim_space(nav_nodes);
			claim_component(voy.$$.fragment, nav_nodes);
			t5 = claim_space(nav_nodes);
			claim_component(ls.$$.fragment, nav_nodes);
			t6 = claim_space(nav_nodes);
			claim_component(lis.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(nav, "class", "svelte-14m8txd");
			add_location(nav, file$8, 13, 0, 593);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			mount_component(discovery, nav, null);
			append_dev(nav, t0);
			mount_component(enterprise, nav, null);
			append_dev(nav, t1);
			mount_component(orville, nav, null);
			append_dev(nav, t2);
			mount_component(sttv, nav, null);
			append_dev(nav, t3);
			mount_component(tng, nav, null);
			append_dev(nav, t4);
			mount_component(voy, nav, null);
			append_dev(nav, t5);
			mount_component(ls, nav, null);
			append_dev(nav, t6);
			mount_component(lis, nav, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const discovery_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) discovery_changes.LP = /*LOCALPLAY*/ ctx[0];
			discovery.$set(discovery_changes);
			const enterprise_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) enterprise_changes.LP = /*LOCALPLAY*/ ctx[0];
			enterprise.$set(enterprise_changes);
			const orville_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) orville_changes.LP = /*LOCALPLAY*/ ctx[0];
			orville.$set(orville_changes);
			const sttv_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) sttv_changes.LP = /*LOCALPLAY*/ ctx[0];
			sttv.$set(sttv_changes);
			const tng_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) tng_changes.LP = /*LOCALPLAY*/ ctx[0];
			tng.$set(tng_changes);
			const voy_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) voy_changes.LP = /*LOCALPLAY*/ ctx[0];
			voy.$set(voy_changes);
			const ls_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) ls_changes.LP = /*LOCALPLAY*/ ctx[0];
			ls.$set(ls_changes);
			const lis_changes = {};
			if (dirty & /*LOCALPLAY*/ 1) lis_changes.LP = /*LOCALPLAY*/ ctx[0];
			lis.$set(lis_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(discovery.$$.fragment, local);
			transition_in(enterprise.$$.fragment, local);
			transition_in(orville.$$.fragment, local);
			transition_in(sttv.$$.fragment, local);
			transition_in(tng.$$.fragment, local);
			transition_in(voy.$$.fragment, local);
			transition_in(ls.$$.fragment, local);
			transition_in(lis.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(discovery.$$.fragment, local);
			transition_out(enterprise.$$.fragment, local);
			transition_out(orville.$$.fragment, local);
			transition_out(sttv.$$.fragment, local);
			transition_out(tng.$$.fragment, local);
			transition_out(voy.$$.fragment, local);
			transition_out(ls.$$.fragment, local);
			transition_out(lis.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(discovery);
			destroy_component(enterprise);
			destroy_component(orville);
			destroy_component(sttv);
			destroy_component(tng);
			destroy_component(voy);
			destroy_component(ls);
			destroy_component(lis);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { LOCALPLAY } = $$props;
	const writable_props = ["LOCALPLAY"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TVShowsListComp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TVShowsListComp", $$slots, []);

	$$self.$set = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	$$self.$capture_state = () => ({
		set_store_value,
		Discovery,
		Enterprise,
		Orville,
		STTV,
		TNG,
		VOY: Voyager,
		LS: LastShip,
		LIS: LostInSpace,
		LOCALPLAY
	});

	$$self.$inject_state = $$props => {
		if ("LOCALPLAY" in $$props) $$invalidate(0, LOCALPLAY = $$props.LOCALPLAY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [LOCALPLAY];
}

class TVShowsListComp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { LOCALPLAY: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TVShowsListComp",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*LOCALPLAY*/ ctx[0] === undefined && !("LOCALPLAY" in props)) {
			console.warn("<TVShowsListComp> was created without expected prop 'LOCALPLAY'");
		}
	}

	get LOCALPLAY() {
		throw new Error("<TVShowsListComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set LOCALPLAY(value) {
		throw new Error("<TVShowsListComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/tvshows.svelte generated by Svelte v3.24.0 */
const file$9 = "src/routes/tvshows.svelte";

// (34:0) {#if visible3}
function create_if_block_1$8(ctx) {
	let div;
	let video;
	let video_src_value;

	const block = {
		c: function create() {
			div = element("div");
			video = element("video");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);

			video = claim_element(div_nodes, "VIDEO", {
				src: true,
				controls: true,
				autoplay: true,
				class: true
			});

			children(video).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) attr_dev(video, "src", video_src_value);
			video.controls = true;
			video.autoplay = true;
			attr_dev(video, "class", "svelte-calnre");
			add_location(video, file$9, 36, 8, 825);
			attr_dev(div, "id", "vid2");
			attr_dev(div, "class", "svelte-calnre");
			add_location(div, file$9, 34, 4, 729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, video);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*TVlocalplayURL_value*/ 2 && video.src !== (video_src_value = /*TVlocalplayURL_value*/ ctx[1])) {
				attr_dev(video, "src", video_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(34:0) {#if visible3}",
		ctx
	});

	return block;
}

// (44:0) {#if !visible3}
function create_if_block$8(ctx) {
	let controls;
	let current;
	controls = new Controls({ $$inline: true });

	const block = {
		c: function create() {
			create_component(controls.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(controls.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(controls, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(controls.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(controls.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(controls, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(44:0) {#if !visible3}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let t0;
	let t1;
	let input;
	let t2;
	let lable;
	let t3;
	let t4;
	let t5;
	let tvshows;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*visible3*/ ctx[0] && create_if_block_1$8(ctx);
	let if_block1 = !/*visible3*/ ctx[0] && create_if_block$8(ctx);

	tvshows = new TVShowsListComp({
			props: { LOCALPLAY: /*visible3*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			lable = element("lable");
			t3 = text("localplay");
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			create_component(tvshows.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-xfr3l7\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			input = claim_element(nodes, "INPUT", { type: true, value: true });
			t2 = claim_space(nodes);
			lable = claim_element(nodes, "LABLE", {});
			var lable_nodes = children(lable);
			t3 = claim_text(lable_nodes, "localplay");
			lable_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t5 = claim_space(nodes);
			claim_component(tvshows.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "TV Shows";
			attr_dev(input, "type", "checkbox");
			input.__value = "fuck";
			input.value = input.__value;
			add_location(input, file$9, 40, 0, 904);
			add_location(lable, file$9, 41, 0, 965);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, input, anchor);
			input.checked = /*visible3*/ ctx[0];
			insert_dev(target, t2, anchor);
			insert_dev(target, lable, anchor);
			append_dev(lable, t3);
			insert_dev(target, t4, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(tvshows, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible3*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$8(ctx);
					if_block0.c();
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*visible3*/ 1) {
				input.checked = /*visible3*/ ctx[0];
			}

			if (!/*visible3*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*visible3*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$8(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t5.parentNode, t5);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const tvshows_changes = {};
			if (dirty & /*visible3*/ 1) tvshows_changes.LOCALPLAY = /*visible3*/ ctx[0];
			tvshows.$set(tvshows_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(tvshows.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(tvshows.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(lable);
			if (detaching) detach_dev(t4);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t5);
			destroy_component(tvshows, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let visible = false;
	let visible3 = false;

	let fuck = () => {
		if (visible) {
			visible = false;
		} else {
			visible = true;
		}
	};

	let fuck3 = () => {
		if (visible3) {
			$$invalidate(0, visible3 = false);
		} else {
			$$invalidate(0, visible3 = true);
		}
	};

	let TVlocalplayURL_value;

	const unsubplid = TVlocalplayURL.subscribe(value => {
		$$invalidate(1, TVlocalplayURL_value = value);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tvshows> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Tvshows", $$slots, []);

	function input_change_handler() {
		visible3 = this.checked;
		$$invalidate(0, visible3);
	}

	$$self.$capture_state = () => ({
		TVShows: TVShowsListComp,
		Controls,
		TVlocalplayURL,
		visible,
		visible3,
		fuck,
		fuck3,
		TVlocalplayURL_value,
		unsubplid
	});

	$$self.$inject_state = $$props => {
		if ("visible" in $$props) visible = $$props.visible;
		if ("visible3" in $$props) $$invalidate(0, visible3 = $$props.visible3);
		if ("fuck" in $$props) fuck = $$props.fuck;
		if ("fuck3" in $$props) fuck3 = $$props.fuck3;
		if ("TVlocalplayURL_value" in $$props) $$invalidate(1, TVlocalplayURL_value = $$props.TVlocalplayURL_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [visible3, TVlocalplayURL_value, input_change_handler];
}

class Tvshows extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tvshows",
			options,
			id: create_fragment$9.name
		});
	}
}

export default Tvshows;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHZzaG93cy5mNjUyMzNiMC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9EaXNjb3Zlcnkuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9FbnRlcnByaXNlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvT3J2aWxsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVkNvbXBzL1NUVFYuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9UTkcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Wb3lhZ2VyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1RWQ29tcHMvTGFzdFNoaXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVFZDb21wcy9Mb3N0SW5TcGFjZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UVlNob3dzTGlzdENvbXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy90dnNob3dzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuXG4gICAgbGV0IHNob3dsaXN0O1xuICAgIGxldCBzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlRGlzID0gZmFsc2VcblxuICAgIG9uTW91bnQoXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldERpc2NvdmVyeSgpIHtcbiAgICAgICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnREaXNjb3Zlcnk/c2Vhc29uPTAxYFxuICAgICAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YVswXS5lcGlzb2RlKVxuICAgICAgICAgICAgICAgIHNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgICAgIHNob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICB9XG4gICAgKVxuXG4gICAgbGV0IGZ1Y2tEaXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlRGlzKSB7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/dHZzaG93PSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZURpc2NvdmVyeSA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lZGlhKVxuXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgZm9vWzFdXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdwYXRoKVxuICAgICAgICAgICAgVFZsb2NhbHBsYXlVUkwuc2V0KG5ld3BhdGgpXG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gZ2V0UGxheU1lZGlhKG1lZGlhKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICAgICAgICB2aXNpYmxlRGlzID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGljaz17ZnVja0Rpc30+RGlzY292ZXJ5PC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZURpc31cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlRGlzY292ZXJ5KHNzaG93LnR2ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuICAgIHVsIHtcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIFxuICAgIH1cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgRW50c2hvd2xpc3Q7XG4gICAgbGV0IEVudHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVFbnQgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0RW50ZXJwcmlzZSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRFbnRlcnByaXNlP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgRW50c2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBFbnRzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVFbnRlcnByaXNlMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRFbnRlcnByaXNlKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlRW50ZXJwcmlzZTIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0RW50ZXJwcmlzZShgMDJgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVFbnRlcnByaXNlMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRFbnRlcnByaXNlKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUVudGVycHJpc2U0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldEVudGVycHJpc2UoYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrRW50ID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZUVudCkge1xuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlRW50ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P3R2c2hvdz0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVQbGF5U2hvdyA9IChtZWRpYSkgPT4ge1xuICAgICAgICBpZiAoTFApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyBtZWRpYVwiKVxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIC8vIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBcIi9cIiArIG1lZGlhXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRoaXMgaXMgbmV3cGF0aFwiKVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZUVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRW50fSA+RW50ZXJwcmlzZTwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVFbnR9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlRW50ZXJwcmlzZTF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUVudGVycHJpc2UyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVFbnRlcnByaXNlM30+czM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlRW50ZXJwcmlzZTR9PnM0PC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgRW50c2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggRW50c2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3coc3Nob3cudHZmc3BhdGgpfT57c3Nob3cudGl0bGV9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3Nob3cuZXBpc29kZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIHNwYW4ge1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICBtYXJnaW46IDEwcHg7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cblxuICAgIGEge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG5cblxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVFZsb2NhbHBsYXlVUkwgfSBmcm9tICcuLi9QbGF5ZXJTdG9yZSdcbiAgICBleHBvcnQgbGV0IExQO1xuICAgIGxldCBPUlZzaG93bGlzdDtcbiAgICBsZXQgT1JWc2hvd2xpc3Rjb3VudDtcbiAgICBsZXQgdmlzaWJsZU9ydiA9IGZhbHNlXG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldE9ydmlsbGUoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvaW50T3J2aWxsZT9zZWFzb249JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIE9SVnNob3dsaXN0ID0gZGF0YVxuICAgICAgICAgICAgT1JWc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZU9SMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRPcnZpbGxlKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZU9SMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRPcnZpbGxlKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cblxuICAgIGxldCBmdWNrT3J2ID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZU9ydikge1xuICAgICAgICAgICAgdmlzaWJsZU9ydiA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlT3J2ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P3R2c2hvdz0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVQbGF5U2hvd09yID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVPcnYgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVPcnYgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tPcnZ9Pk9ydmlsbGU8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlT3J2fVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZU9SMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlT1IyfT5zMjwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIE9SVnNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIE9SVnNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlTaG93T3Ioc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgc2hvd2xpc3Q7XG4gICAgbGV0IHNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVEaXMgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0U1RUVih4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRTVFRWP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgc2hvd2xpc3QgPSBkYXRhXG4gICAgICAgICAgICBzaG93bGlzdGNvdW50ID0gZGF0YS5sZW5ndGhcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVTVFRWQ2xpY2sxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFNUVFYoYDAxYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVTVFRWQ2xpY2syID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFNUVFYoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlU1RUVkNsaWNrMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRTVFRWKGAwM2ApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgZnVja0RpcyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVEaXMpIHtcbiAgICAgICAgICAgIHZpc2libGVEaXMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD90dnNob3c9JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheVNob3dTVFRWID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZURpcyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrRGlzfSA+U1RUVjwvYnV0dG9uPlxuXG57I2lmIHZpc2libGVEaXN9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlU1RUVkNsaWNrMX0+czE8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlU1RUVkNsaWNrMn0+czI8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlU1RUVkNsaWNrM30+czM8L2J1dHRvbj5cbiAgICA8L25hdj5cblxuICAgIDx1bD5cbiAgICAgICAgeyNpZiBzaG93bGlzdGNvdW50ID4gMH1cbiAgICAgICAgICAgIHsjZWFjaCBzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5U2hvd1NUVFYoc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG4gICAgXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IFROR3Nob3dsaXN0O1xuICAgIGxldCBUTkdzaG93bGlzdGNvdW50O1xuICAgIGxldCB2aXNpYmxlVE5HID0gZmFsc2VcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFRORyh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRUTkc/c2Vhc29uPSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBUTkdzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIFROR3Nob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVRORzEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVE5HMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVE5HMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDAzYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVE5HNCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVUTkc1ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFRORyhgMDVgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVRORzYgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0VE5HKGAwNmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVE5HNyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRUTkcoYDA3YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrVE5HID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZVRORykge1xuICAgICAgICAgICAgdmlzaWJsZVRORyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlVE5HID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P3R2c2hvdz0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVQbGF5VE5HID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZVRORyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZVRORyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrVE5HfT5UaGUgTmV4dCBHZW5lcmF0aW9uPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZVROR31cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVUTkcxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVUTkcyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVUTkczfT5zMzwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVUTkc0fT5zNDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVUTkc1fT5zNTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVUTkc2fT5zNjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVUTkc3fT5zNzwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIFROR3Nob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIFROR3Nob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlUTkcoc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgVk9Zc2hvd2xpc3Q7XG4gICAgbGV0IFZPWXNob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVWb3kgPSBmYWxzZVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0Vk9ZKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L2ludFZveWFnZXI/c2Vhc29uPSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBWT1lzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIFZPWXNob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVZPWTEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVk9ZMiA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVk9ZMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDAzYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlVk9ZNCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVWT1k1ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFZPWShgMDVgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVZPWTYgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0Vk9ZKGAwNmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlVk9ZNyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRWT1koYDA3YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBmdWNrVk9ZID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlzaWJsZVZveSkge1xuICAgICAgICAgICAgdmlzaWJsZVZveSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlVm95ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheU1lZGlhKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L3BsYXlNZWRpYVJlYWN0P3R2c2hvdz0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVQbGF5Vk9ZID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBtZWRpYVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3cGF0aClcbiAgICAgICAgICAgIFRWbG9jYWxwbGF5VVJMLnNldChuZXdwYXRoKVxuICAgICAgICAgICAgdmlzaWJsZVZPWSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZVZPWSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrPXtmdWNrVk9ZfT5Wb3lhZ2VyPC9idXR0b24+XG5cbnsjaWYgdmlzaWJsZVZveX1cbiAgICA8bmF2PlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kyfT5zMjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1kzfT5zMzwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k0fT5zNDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k1fT5zNTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k2fT5zNjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVWT1k3fT5zNzwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIFZPWXNob3dsaXN0Y291bnQgPiAwfVxuICAgICAgICAgICAgeyNlYWNoIFZPWXNob3dsaXN0IGFzIHNzaG93IH1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ0dnNob3dzXCIgb246Y2xpY2s9e2hhbmRsZVBsYXlWT1koc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG4gICAgXG4gICAgYSB7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBUVmxvY2FscGxheVVSTCB9IGZyb20gJy4uL1BsYXllclN0b3JlJ1xuICAgIGV4cG9ydCBsZXQgTFA7XG4gICAgbGV0IExTc2hvd2xpc3Q7XG4gICAgbGV0IExTc2hvd2xpc3Rjb3VudDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldExTKHgpIHtcbiAgICAgICAgbGV0IGFkZHIgPSBgaHR0cDovLzE5Mi4xNjguMC40Mjo4ODg4L2ludExhc3RTaGlwP3NlYXNvbj0ke3h9YFxuICAgICAgICBmZXRjaChhZGRyLCB7bW9kZTogXCJjb3JzXCIsIG1ldGhvZDogXCJHRVRcIn0pXG4gICAgICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgTFNzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIExTc2hvd2xpc3Rjb3VudCA9IGRhdGEubGVuZ3RoXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlTFMxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExTKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlTFMyID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExTKGAwMmApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUxTMyA9ICgpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBnZXRMUyhgMDNgKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVMUzQgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TFMoYDA0YCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuXG4gICAgbGV0IHZpc2libGVMUyA9IGZhbHNlXG4gICAgbGV0IGZ1Y2tMUyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGVMUykge1xuICAgICAgICAgICAgdmlzaWJsZUxTID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVMUyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlNZWRpYSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9wbGF5TWVkaWFSZWFjdD90dnNob3c9JHt4fWBcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlUGxheUxTID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG5cbiAgICAgICAgICAgIGxldCBmb28gPSBtZWRpYS5zcGxpdChcIlRWU2hvd3NcIiwgMilcbiAgICAgICAgICAgIGxldCBuZXdwYXRoID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MmAgKyBmb29bMV1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVMUyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFBsYXlNZWRpYShtZWRpYSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgICAgICAgdmlzaWJsZUxTID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tMU30gPlRoZSBMYXN0IFNoaXA8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlTFN9XG4gICAgPG5hdj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTFMxfT5zMTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtoYW5kbGVMUzJ9PnMyPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUxTM30+czM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17aGFuZGxlTFM0fT5zNDwvYnV0dG9uPlxuICAgIDwvbmF2PlxuXG4gICAgPHVsPlxuICAgICAgICB7I2lmIExTc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggTFNzaG93bGlzdCBhcyBzc2hvdyB9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwidHZzaG93c1wiIG9uOmNsaWNrPXtoYW5kbGVQbGF5TFMoc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHsgXG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgIH1cbiAgICBcbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vUGxheWVyU3RvcmUnXG4gICAgZXhwb3J0IGxldCBMUDtcbiAgICBsZXQgTElTc2hvd2xpc3Q7XG4gICAgbGV0IExJU3Nob3dsaXN0Y291bnQ7XG4gICAgbGV0IHZpc2libGVMSVMgPSBmYWxzZVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRMb3N0SW5TcGFjZSh4KSB7XG4gICAgICAgIGxldCBhZGRyID0gYGh0dHA6Ly8xOTIuMTY4LjAuNDI6ODg4OC9pbnRMb3N0SW5TcGFjZT9zZWFzb249JHt4fWBcbiAgICAgICAgY29uc29sZS5sb2coYWRkcilcbiAgICAgICAgZmV0Y2goYWRkciwge21vZGU6IFwiY29yc1wiLCBtZXRob2Q6IFwiR0VUXCJ9KVxuICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICBMSVNzaG93bGlzdCA9IGRhdGFcbiAgICAgICAgICAgIExJU3Nob3dsaXN0Y291bnQgPSBkYXRhLmxlbmd0aFxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVMSVMxID0gKCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IGdldExvc3RJblNwYWNlKGAwMWApLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZUxJUzIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlID0gZ2V0TG9zdEluU3BhY2UoYDAyYCkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgIH1cblxuXG4gICAgbGV0IGZ1Y2tMSVMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aXNpYmxlTElTKSB7XG4gICAgICAgICAgICB2aXNpYmxlTElTID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2libGVMSVMgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRQbGF5TWVkaWEoeCkge1xuICAgICAgICBsZXQgYWRkciA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjg4ODgvcGxheU1lZGlhUmVhY3Q/dHZzaG93PSR7eH1gXG4gICAgICAgIGZldGNoKGFkZHIsIHttb2RlOiBcImNvcnNcIiwgbWV0aG9kOiBcIkdFVFwifSlcbiAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZVBsYXlTaG93TElTID0gKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChMUCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVkaWEpXG4gICAgICAgICAgICBsZXQgZm9vID0gbWVkaWEuc3BsaXQoXCJUVlNob3dzXCIsIDIpXG4gICAgICAgICAgICBsZXQgbmV3cGF0aCA9IGBodHRwOi8vMTkyLjE2OC4wLjQyOjgwODJgICsgbWVkaWFcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld3BhdGgpXG4gICAgICAgICAgICBUVmxvY2FscGxheVVSTC5zZXQobmV3cGF0aClcbiAgICAgICAgICAgIHZpc2libGVMSVMgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBnZXRQbGF5TWVkaWEobWVkaWEpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgICAgICAgIHZpc2libGVMSVMgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e2Z1Y2tMSVN9Pkxvc3QgSW4gU3BhY2U8L2J1dHRvbj5cblxueyNpZiB2aXNpYmxlTElTfVxuICAgIDxuYXY+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUxJUzF9PnMxPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e2hhbmRsZUxJUzJ9PnMyPC9idXR0b24+XG4gICAgPC9uYXY+XG5cbiAgICA8dWw+XG4gICAgICAgIHsjaWYgTElTc2hvd2xpc3Rjb3VudCA+IDB9XG4gICAgICAgICAgICB7I2VhY2ggTElTc2hvd2xpc3QgYXMgc3Nob3cgfVxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cInR2c2hvd3NcIiBvbjpjbGljaz17aGFuZGxlUGxheVNob3dMSVMoc3Nob3cubW92ZnNwYXRoKX0+e3NzaG93LnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3NzaG93LmVwaXNvZGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzcGFuIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgbWFyZ2luOiAxMHB4O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIFxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHNldF9zdG9yZV92YWx1ZSB9IGZyb20gXCJzdmVsdGUvaW50ZXJuYWxcIjtcbiAgICBpbXBvcnQgRGlzY292ZXJ5IGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9EaXNjb3Zlcnkuc3ZlbHRlJ1xuICAgIGltcG9ydCBFbnRlcnByaXNlIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9FbnRlcnByaXNlLnN2ZWx0ZSdcbiAgICBpbXBvcnQgT3J2aWxsZSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvT3J2aWxsZS5zdmVsdGUnXG4gICAgaW1wb3J0IFNUVFYgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL1NUVFYuc3ZlbHRlJ1xuICAgIGltcG9ydCBUTkcgZnJvbSAnLi4vY29tcG9uZW50cy9UVkNvbXBzL1RORy5zdmVsdGUnXG4gICAgaW1wb3J0IFZPWSBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvVm95YWdlci5zdmVsdGUnXG4gICAgaW1wb3J0IExTIGZyb20gJy4uL2NvbXBvbmVudHMvVFZDb21wcy9MYXN0U2hpcC5zdmVsdGUnXG4gICAgaW1wb3J0IExJUyBmcm9tICcuLi9jb21wb25lbnRzL1RWQ29tcHMvTG9zdEluU3BhY2Uuc3ZlbHRlJ1xuICAgIGV4cG9ydCBsZXQgTE9DQUxQTEFZO1xuPC9zY3JpcHQ+XG5cbjxuYXY+XG4gICAgPERpc2NvdmVyeSBMUD17TE9DQUxQTEFZfS8+XG4gICAgPEVudGVycHJpc2UgTFA9e0xPQ0FMUExBWX0vPlxuICAgIDxPcnZpbGxlIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8U1RUViBMUD17TE9DQUxQTEFZfS8+XG4gICAgPFRORyBMUD17TE9DQUxQTEFZfS8+XG4gICAgPFZPWSBMUD17TE9DQUxQTEFZfS8+XG4gICAgPExTIExQPXtMT0NBTFBMQVl9Lz5cbiAgICA8TElTIExQPXtMT0NBTFBMQVl9IC8+XG48L25hdj5cblxuPHN0eWxlPlxuICAgIG5hdiB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVFZTaG93cyBmcm9tICcuLi9jb21wb25lbnRzL1RWU2hvd3NMaXN0Q29tcC5zdmVsdGUnXG4gICAgaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbXBvbmVudHMvQ29udHJvbHMuc3ZlbHRlJ1xuICAgIGltcG9ydCB7IFRWbG9jYWxwbGF5VVJMIH0gZnJvbSAnLi4vY29tcG9uZW50cy9QbGF5ZXJTdG9yZSdcbiAgICBcbiAgICBsZXQgdmlzaWJsZSA9IGZhbHNlXG4gICAgbGV0IHZpc2libGUzID0gZmFsc2VcblxuXHRsZXQgZnVjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIHZpc2libGUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBmdWNrMyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHZpc2libGUzKSB7XG4gICAgICAgICAgICB2aXNpYmxlMyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNpYmxlMyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBUVmxvY2FscGxheVVSTF92YWx1ZVxuXHRjb25zdCB1bnN1YnBsaWQgPSBUVmxvY2FscGxheVVSTC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICBUVmxvY2FscGxheVVSTF92YWx1ZSA9IHZhbHVlXG4gICAgfSlcblxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD48dGl0bGU+VFYgU2hvd3M8L3RpdGxlPjwvc3ZlbHRlOmhlYWQ+XG5cbnsjaWYgdmlzaWJsZTN9XG4gICAgPGRpdiBpZD1cInZpZDJcIj5cbiAgICAgICAgPCEtLSBcImh0dHA6Ly8xOTIuMTY4LjAuNDI6ODA4MS9BY3Rpb24vMTIgU3Ryb25nICgyMDE4KS5tcDRcIiAtLT5cbiAgICAgICAgPHZpZGVvIHNyYz17VFZsb2NhbHBsYXlVUkxfdmFsdWV9IGNvbnRyb2xzIGF1dG9wbGF5PjwvdmlkZW8+XG4gICAgPC9kaXY+XG57L2lmfVxuXG48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXt2aXNpYmxlM30gdmFsdWU9XCJmdWNrXCI+XG48bGFibGU+bG9jYWxwbGF5PC9sYWJsZT5cblxueyNpZiAhdmlzaWJsZTN9XG4gICAgPENvbnRyb2xzIC8+XG4gICAgPCEtLSA8YnV0dG9uIGNsYXNzPVwiY29udHJvbGxlclwiIG9uOmNsaWNrPXtmdWNrfSA+Y29udHJvbHM8L2J1dHRvbj4gLS0+XG57L2lmfVxuXG48VFZTaG93cyBMT0NBTFBMQVk9e3Zpc2libGUzfSAvPlxuXG48c3R5bGU+XG5cbiAgICAjdmlkMiB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB9XG5cbiAgICB2aWRlbyB7XG4gICAgICAgIHdpZHRoOiA4NSU7XG4gICAgfVxuXG48L3N0eWxlPiJdLCJuYW1lcyI6WyJnZXRQbGF5TWVkaWEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQTZEYSxHQUFhLE1BQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQUFqQixHQUFhLE1BQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUNYLEdBQVE7Ozs7Z0NBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFBQyxHQUFROzs7OytCQUFiLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUVnRSxHQUFLLElBQUMsS0FBSzs7OzswQkFDbEUsR0FBSyxJQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQURRLEdBQWUsY0FBQyxHQUFLLElBQUMsUUFBUSx3QkFB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
